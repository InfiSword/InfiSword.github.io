<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minhyuk Lee | Systems & Rendering</title>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500;700&family=Inter:wght@300;400;700&family=Noto+Sans+KR:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0D1117;
            --card-bg: #161B22;
            --text-color: #C9D1D9;
            --accent-color: #58A6FF;
            --sub-accent: #238636;
            --border-color: #30363D;
            --code-bg: #010409;
            --code-comment: #8b949e;
            --code-keyword: #ff7b72;
            --code-type: #79c0ff;
            --code-func: #d2a8ff;
            --code-string: #a5d6ff;
        }

        /* --- Global Styles --- */
        * { box-sizing: border-box; margin: 0; padding: 0; cursor: crosshair; }
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Inter', 'Noto Sans KR', sans-serif;
            line-height: 1.6;
        }
        .mono { font-family: 'Fira Code', monospace; }
        .container { max-width: 1000px; margin: 0 auto; padding: 80px 20px; }

        header { margin-bottom: 60px; }
        .name-tag { font-size: 3.5rem; color: #f0f6fc; font-weight: 700; margin-bottom: 10px; }
        .status-line { color: var(--accent-color); font-size: 1.1rem; border-left: 3px solid var(--accent-color); padding-left: 15px; }

        /* --- Sections --- */
        .section-title {
            font-family: 'Fira Code', monospace; font-size: 1.5rem; color: #f0f6fc;
            margin: 80px 0 30px; display: flex; align-items: center;
        }
        .section-title::after { content: ""; flex: 1; height: 1px; background: var(--border-color); margin-left: 20px; }

        /* --- About Me --- */
        .about-box {
            background: var(--card-bg); padding: 30px; border: 1px solid var(--border-color); border-radius: 12px;
            color: #8b949e; margin-bottom: 50px;
        }
        .about-highlight { color: #f0f6fc; font-weight: 700; font-size: 1.1rem; display: block; margin-bottom: 15px; }

        /* --- Skills --- */
        .skill-container { display: flex; flex-wrap: wrap; gap: 15px; }
        .skill-item {
            background: var(--card-bg); border: 1px solid var(--border-color);
            padding: 12px 24px; border-radius: 6px; transition: 0.3s;
        }
        .skill-item:hover { border-color: var(--accent-color); transform: translateY(-3px); box-shadow: 0 4px 15px rgba(88, 166, 255, 0.1); }
        .skill-label { font-size: 0.75rem; color: var(--accent-color); display: block; margin-bottom: 5px; text-transform: uppercase; font-weight: 700; }

        /* --- Projects --- */
        .project-card {
            background: var(--card-bg); border: 1px solid var(--border-color);
            border-radius: 12px; overflow: hidden; transition: 0.4s cubic-bezier(0.165, 0.84, 0.44, 1); cursor: pointer;
        }
        .project-card:hover { border-color: var(--accent-color); transform: scale(1.02); box-shadow: 0 20px 40px rgba(0,0,0,0.6); }
        .project-info { padding: 40px; }
        .project-tag { color: var(--sub-accent); font-size: 0.85rem; font-weight: 700; margin-bottom: 10px; display: block; }
        .project-name { font-size: 2rem; color: #f0f6fc; margin-bottom: 20px; }
        
        /* --- Modal --- */
        .modal-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92); z-index: 10000; justify-content: center; align-items: center; backdrop-filter: blur(10px);
        }
        .modal-container {
            background: var(--bg-color); width: 95%; max-width: 1000px; max-height: 90vh;
            border: 1px solid var(--border-color); border-radius: 16px; overflow-y: auto;
            animation: modalIn 0.3s ease-out;
        }
        @keyframes modalIn { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

        .modal-body { padding: 60px; }
        .modal-header-nav { display: flex; justify-content: space-between; align-items: center; margin-bottom: 40px; }
        .modal-body h2 { color: var(--accent-color); margin: 60px 0 25px; font-size: 1.8rem; border-left: 6px solid var(--accent-color); padding-left: 20px;}
        .modal-body h3 { color: #f0f6fc; margin: 35px 0 15px; font-size: 1.3rem; font-weight: 600; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        .modal-body p { margin-bottom: 18px; color: #8b949e; font-size: 1.05rem; }
        .modal-body ul { margin: 15px 0 30px 25px; color: #8b949e; }
        .modal-body li { margin-bottom: 10px; }

        /* --- Visual Frames --- */
        .visual-frame {
            width: 100%; padding: 30px; background: rgba(0,0,0,0.4);
            border: 1px solid var(--border-color); border-radius: 8px;
            margin: 25px 0; text-align: center;
        }
        .visual-frame > * {
            text-align: center;
        }
        .diagram-grid {
            display: grid; grid-template-columns: repeat(3, 40px); gap: 5px; justify-content: center; margin: 10px 0;
        }
        .grid-cell { width: 40px; height: 40px; border: 1px solid var(--accent-color); opacity: 0.2; }
        .grid-cell.active { background: var(--accent-color); opacity: 1; box-shadow: 0 0 15px var(--accent-color); }
        .grid-cell.near { border-color: var(--sub-accent); background: rgba(35, 134, 54, 0.2); opacity: 1; }

        .transaction-flow {
            display: flex; align-items: center; justify-content: center; font-size: 0.75rem; font-family: 'Fira Code';
            gap: 10px; flex-wrap: wrap;
        }
        .flow-step { padding: 8px 15px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--card-bg); color: var(--text-color); text-align: center; }
        .flow-arrow { color: var(--accent-color); font-weight: bold; }

        /* --- Tables --- */
        .data-table {
            width: 100%; border-collapse: collapse; margin: 20px 0; font-size: 0.9rem;
            background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px; overflow: hidden;
        }
        .data-table th {
            background: rgba(88, 166, 255, 0.1); color: var(--accent-color);
            padding: 12px 15px; text-align: center; font-weight: 700; border-bottom: 2px solid var(--border-color);
            font-family: 'Fira Code', monospace;
        }
        .data-table td {
            padding: 10px 15px; border-bottom: 1px solid var(--border-color); color: var(--text-color);
            text-align: center;
        }
        .data-table tr:last-child td { border-bottom: none; }
        .data-table tr:hover { background: rgba(88, 166, 255, 0.05); }

        /* --- Architecture Diagrams --- */
        .arch-diagram {
            display: flex; flex-direction: column; gap: 15px; margin: 25px 0;
        }
        .arch-layer {
            padding: 15px 20px; border: 1px solid var(--border-color); border-radius: 6px;
            background: var(--card-bg); position: relative; text-align: center;
        }
        .arch-layer::before {
            content: ""; position: absolute; left: 0; top: 0; bottom: 0; width: 4px;
            background: var(--accent-color);
        }
        .arch-layer-title {
            color: var(--accent-color); font-weight: 700; margin-bottom: 8px;
            font-family: 'Fira Code', monospace; font-size: 0.9rem; text-align: center;
        }
        .arch-layer-items {
            display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; justify-content: center;
        }
        .arch-item {
            padding: 5px 12px; background: rgba(88, 166, 255, 0.1);
            border: 1px solid var(--accent-color); border-radius: 4px;
            font-size: 0.85rem; color: var(--text-color); text-align: center;
        }

        /* --- Coordinate Flow Diagram --- */
        .coord-flow {
            display: flex; gap: 15px; margin: 25px 0;
            align-items: stretch; overflow-x: auto; padding-bottom: 10px;
            scrollbar-width: thin; scrollbar-color: var(--accent-color) rgba(0, 0, 0, 0.2);
        }
        .coord-flow::-webkit-scrollbar {
            height: 8px;
        }
        .coord-flow::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2); border-radius: 4px;
        }
        .coord-flow::-webkit-scrollbar-thumb {
            background: var(--accent-color); border-radius: 4px;
        }
        .coord-flow::-webkit-scrollbar-thumb:hover {
            background: var(--sub-accent);
        }
        .coord-box {
            padding: 20px; border: 2px solid var(--accent-color); border-radius: 8px;
            background: rgba(88, 166, 255, 0.05); text-align: center; display: flex; flex-direction: column;
            justify-content: center; min-height: 120px; min-width: 200px; flex: 0 0 auto;
            white-space: normal;
        }
        .coord-box-title {
            color: var(--accent-color); font-weight: 700; margin-bottom: 12px;
            font-family: 'Fira Code', monospace; font-size: 0.95rem; border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
        }
        .coord-box-desc {
            color: var(--text-color); font-size: 0.85rem; line-height: 1.6;
        }
        .coord-box-formula {
            color: var(--sub-accent); font-size: 0.75rem; font-family: 'Fira Code', monospace;
            margin-top: 8px; padding: 6px; background: rgba(35, 134, 54, 0.1); border-radius: 4px;
        }
        .coord-arrow {
            color: var(--accent-color); font-size: 2rem; text-align: center; display: flex;
            align-items: center; justify-content: center;
        }
        .coord-bidirectional {
            text-align: center; color: var(--sub-accent); margin: 25px 0;
            font-family: 'Fira Code', monospace; font-size: 1rem; font-weight: 700;
            padding: 12px; background: rgba(35, 134, 54, 0.1); border-radius: 6px;
            border: 1px solid var(--sub-accent);
        }

        /* --- Advanced Code Block --- */
        pre {
            background: var(--code-bg); padding: 25px; border-radius: 10px; 
            font-family: 'Fira Code', monospace; font-size: 0.9rem; color: #d1d5da;
            overflow-x: auto; margin: 25px 0; border: 1px solid var(--border-color);
            line-height: 1.6; white-space: pre; 
        }
        .c-kw { color: var(--code-keyword); }
        .c-ty { color: var(--code-type); }
        .c-fn { color: var(--code-func); }
        .c-cm { color: var(--code-comment); }
        .c-st { color: var(--code-string); }

        footer { margin-top: 100px; padding: 60px 0; border-top: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: flex-end; }
        .highlight { color: #f0f6fc; font-weight: 700; }

        /* --- Tab System --- */
        .tab-container {
            display: flex; gap: 10px; margin-bottom: 40px; border-bottom: 2px solid var(--border-color);
        }
        .tab-button {
            background: none; border: none; color: #8b949e; padding: 15px 30px;
            font-family: 'Fira Code', monospace; font-size: 1rem; cursor: pointer;
            border-bottom: 3px solid transparent; transition: all 0.3s;
            position: relative; top: 2px;
        }
        .tab-button:hover {
            color: var(--accent-color);
        }
        .tab-button.active {
            color: var(--accent-color); border-bottom-color: var(--accent-color);
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        /* Video Container Responsive */
        @media (max-width: 768px) {
            .video-container {
                grid-template-columns: 1fr !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1 class="name-tag head">Minhyuk Lee</h1>
            <div class="status-line mono">Gameplay & Systems Programmer</div>
        </header>


        <section id="skills">
            <h2 class="section-title">01. Tech Stack</h2>
            <div class="skill-container">
                <div class="skill-item">
                    <span class="skill-label mono">Languages</span>
                    <span class="mono">C++, C#, HLSL, Python</span>
                </div>
                <div class="skill-item">
                    <span class="skill-label mono">Engine/Graphics</span>
                    <span class="mono">Unity, Unreal, DirectX 11, Computer Graphics</span>
                </div>
                <div class="skill-item">
                    <span class="skill-label mono">Specialized</span>
                    <span class="mono">ML-Agents (Machine Learning)</span>
                </div>
            </div>
        </section>

        <section id="projects">
            <h2 class="section-title">02. Major Achievement</h2>
            <article class="project-card" id="file-tower-defense-card" style="cursor: pointer;">
                <div class="project-info">
                    <span class="project-tag mono">Systems Engineering</span>
                    <h3 class="project-name">File Tower Defense</h3>
                    <p style="color: #8b949e; margin-bottom: 25px;">
                        유니티의 좌표계 특성을 분석하여 <span class="highlight">RectTransform(UI)에서 Transform(GameObject) 기반</span>으로 아키텍처를 전면 재설계. 
                        <span class="highlight">공간 분할 최적화</span>와 <span class="highlight">트랜잭션 기반 배치 시스템</span>을 구축하여 성능 최적화와 확장성 있는 그리드 관리 시스템을 완성. 
                        <span class="highlight">중앙 집중식 마우스 입력 관리(InputManager)</span>와 <span class="highlight">이벤트 기반 상호작용 시스템(InteractionHandler)</span>을 통해 
                        수많은 유닛의 개별 이벤트 수신을 제거하고 통합 관리하여 성능을 최적화.
                    </p>
                    <div class="mono" style="font-size: 0.9rem; color: var(--accent-color);">>> VIEW_TECHNICAL_REPORT</div>
                </div>
            </article>
            <article class="project-card" id="ml-agents-card" style="cursor: pointer;" onclick="openMLAgentsModal(event)">
                <div class="project-info" onclick="event.stopPropagation()">
                    <span class="project-tag mono">ML-Agents & Reinforcement Learning</span>
                    <h3 class="project-name">Autonomous Racing Agent</h3>
                    <p style="color: #8b949e; margin-bottom: 25px;">
                        Unity ML-Agents를 활용한 <span class="highlight">자율 주행 경주차 에이전트</span> 학습 시스템 구축. 
                        <span class="highlight">체크포인트 기반 네비게이션 시스템</span>과 <span class="highlight">목표 지향 보상 설계</span>를 통해 정해진 트랙을 안정적으로 주행하도록 학습. 
                        <span class="highlight">레이캐스트 기반 환경 감지</span>(전방/후방 벽 감지, 도로 감지)와 <span class="highlight">다중 트랙 학습 지원</span>으로 
                        일반화 성능을 향상시키고, <span class="highlight">스플라인 기반 체크포인트 자동 생성 시스템</span>을 설계하여 다양한 트랙에 빠르게 적용 가능.
                    </p>
                    <div class="mono" style="font-size: 0.9rem; color: var(--accent-color);">>> VIEW_TECHNICAL_REPORT</div>
                </div>
            </article>
            <article class="project-card" id="wfk-card" style="cursor: pointer;" onclick="openWFKModal(event)">
                <div class="project-info" onclick="event.stopPropagation()">
                    <span class="project-tag mono">Data Management & Parsing</span>
                    <h3 class="project-name">WorldFirstKill</h3>
                    <p style="color: #8b949e; margin-bottom: 25px;">
                        <span class="highlight">리플렉션 기반 CSV 파싱 시스템</span>과 <span class="highlight">서버 CSV 다운로드 및 버전 관리 시스템</span>을 설계하여 
                        게임 데이터를 효율적으로 관리. <span class="highlight">JSON 기반 저장/불러오기 시스템</span>과 <span class="highlight">Seed/Token 시스템</span>을 구현하여 
                        게임 상태를 안전하게 저장하고 복원. <span class="highlight">비동기 로딩 시스템</span>을 통해 
                        UI 블로킹 없는 부드러운 게임 경험 제공. <span class="highlight">Factory Pattern</span>을 활용한 데이터 기반 객체 생성 시스템으로 
                        확장 가능한 데이터 아키텍처 구축.
                    </p>
                    <div class="mono" style="font-size: 0.9rem; color: var(--accent-color);">>> VIEW_TECHNICAL_REPORT</div>
                </div>
            </article>
        </section>

        <footer>
            <div class="mono" style="font-size: 0.9rem;">
                <span class="highlight">CONTACT:</span> <a href="mailto:lioie6478@gmail.com">lioie6478@gmail.com</a><br>
                <span class="highlight">GITHUB:</span> <a href="https://github.com/InfiSword" target="_blank">InfiSword</a>
            </div>
            <div class="mono" style="font-size: 0.8rem; opacity: 0.5;">
                © 2026 MINHYUK LEE. ALL RIGHTS RESERVED.
            </div>
        </footer>
    </div>

    <!-- MODAL -->
    <div id="modal-overlay" class="modal-overlay" onclick="closeModal('fileTowerDefense')">
        <div class="modal-container" onclick="event.stopPropagation()">
            <div class="modal-body">
                <div class="modal-header-nav">
                    <div class="mono" style="color: var(--accent-color);">PROJECT REPORT // FILE_TOWER_DEFENSE</div>
                    <button onclick="closeModal()" style="background: none; border: 1px solid var(--accent-color); color: var(--accent-color); padding: 8px 20px; border-radius: 6px; cursor: pointer; font-family: 'Fira Code'; font-size: 0.8rem;">[X] DISCONNECT</button>
                </div>
                
                <div class="tab-container">
                    <button class="tab-button active" onclick="switchTab('refactoring')">리팩토링 및 개선</button>
                    <button class="tab-button" onclick="switchTab('existing')">입력 및 상호작용 시스템</button>
                </div>
                
                <div id="refactoring-tab" class="tab-content active">
                <h1 style="font-size: 2.5rem; margin-bottom: 30px; color: #f0f6fc;">시스템 리팩토링 및 개선</h1>


                <h2>1. UI(RectTransform)에서 GameObject(Transform)기반으로의 전환</h2>
                <p>초기 단계에서는 윈도우 바탕화면의 느낌을 구현하고자 파일 유닛을 UI 시스템으로 구축했습니다. 하지만 프로젝트 규모가 커짐에 따라 다음과 같은 <span class="highlight">결정적인 설계적 한계</span>를 마주했습니다.</p>
                
                <ul>
                    <li><span class="highlight">좌표계 종속성:</span> <code>RectTransform</code>은 캔버스의 앵커와 피벗 설정에 따라 월드 좌표값이 상대적으로 변합니다. 이로 인해 유닛의 절대적인 위치를 파악하는 로직이 매우 복잡해졌습니다.</li>
                    <li><span class="highlight">연산 비용의 증가:</span> 월드 좌표 기반의 바이러스(적)가 UI 기반의 파일 유닛 간의 거리 계산 및 물리적 충돌 판정을 수행할 때, <code>Camera.WorldToScreenPoint</code>, <code>Camera.ScreenToWorldPoint</code> 등의 변환 함수를 매 프레임 호출해야 하는 오버헤드가 발생했습니다.</li>
                    <li><span class="highlight">계층 구조의 복잡성:</span> 서로 다른 부모 객체(UI Hierarchy) 간의 위치 변환 로직은 코드의 가독성을 해치고 구조적인 복잡도를 증대시켰습니다.</li>
                </ul>

<div class="visual-frame">
                    <div style="display: flex; justify-content: space-around; align-items: center;">
                        <div class="mono" style="font-size: 0.7rem; border: 1px solid #ff7b72; padding: 10px;">
                            RectTransform (UI)<br>
                            - Anchor Dependent<br>
                            - Pivot Relative<br>
                            - WorldToScreen Required
                        </div>
                        <div class="flow-arrow">>>></div>
                        <div class="mono" style="font-size: 0.7rem; border: 1px solid var(--sub-accent); padding: 10px;">
                            Transform (World)<br>
                            - Absolute Position<br>
                            - Physics 2D Optimized<br>
                            - Unified Coordinate Space
                        </div>
                    </div>
                </div>

                <p>이를 해결하기 위해 모든 유닛을 <span class="highlight">GameObject(Transform) 기반</span>으로 전면 교체하여 월드 좌표계로 통일하였으며, 이를 통해 성능 최적화와 확장성 있는 로직 설계가 가능해졌습니다.</p>

                <h3>1.1 기술적 특징</h3>
                <ul>
                    <li><span class="highlight">좌표계 통일:</span> 월드 좌표계로 통일하여 절대 위치 계산 단순화</li>
                    <li><span class="highlight">성능 최적화:</span> 좌표 변환 오버헤드 제거로 프레임당 연산 비용 감소</li>
                    <li><span class="highlight">물리 시스템 통합:</span> Physics2D와 직접 호환되어 충돌 판정 효율성 향상</li>
                    <li><span class="highlight">확장성:</span> 계층 구조 단순화로 새로운 기능 추가 용이</li>
                </ul>

                <h2>2. FileGrid: 데이터 중심의 개별 셀 매니저</h2>
                <p>유닛을 <code>GameObject</code> 기반으로 전환함에 따라, 윈도우 바탕화면의 아이콘 정렬 시스템을 모방하여 유닛 배치 시스템을 구축했습니다.</p>
                <p><code>FileGrid</code>는 타워(파일)를 설치할 수 있는 최소 단위인 'Slot' 역할을 수행하며, 해당 셀의 점유 상태와 인접 유닛 간의 시너지, 버프를 관리합니다.</p>

                <div class="visual-frame">
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin: 20px 0; align-items: stretch;">
                        <div style="padding: 18px; border: 2px solid var(--accent-color); border-radius: 8px; background: rgba(88, 166, 255, 0.05); text-align: center; display: flex; flex-direction: column; justify-content: flex-start;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">State</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.8; flex-grow: 1;">
                                <div>• GridX, GridY</div>
                                <div>• fileUnit</div>
                                <div>• obstacleObject</div>
                            </div>
                        </div>
                        <div style="padding: 18px; border: 2px solid var(--sub-accent); border-radius: 8px; background: rgba(35, 134, 54, 0.05); text-align: center; display: flex; flex-direction: column; justify-content: flex-start;">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">Buff System</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.8; flex-grow: 1;">
                                <div>• HashSet&lt;File_Base&gt;</div>
                                <div>• O(1) Lookup</div>
                                <div>• Auto Sync</div>
                            </div>
                        </div>
                        <div style="padding: 18px; border: 2px solid var(--border-color); border-radius: 8px; background: rgba(0,0,0,0.2); text-align: center; display: flex; flex-direction: column; justify-content: flex-start;">
                            <div style="color: var(--text-color); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">Visuals</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.8; flex-grow: 1;">
                                <div>• Color State</div>
                                <div>• Hover Effect</div>
                                <div>• Selection</div>
                            </div>
                        </div>
                    </div>
                </div>

<pre><code><span class="c-kw">public class</span> <span class="c-ty">FileGrid</span> : <span class="c-ty">MonoBehaviour</span>
{
    [<span class="c-ty">Header</span>(<span class="c-st">"State"</span>)]
    <span class="c-kw">private</span> <span class="c-ty">File_Base</span> fileUnit; <span class="c-cm">// 현재 그리드를 점유 중인 파일 유닛</span>
    
    <span class="c-cm">// 2차원 배열의 X, Y 위치값</span>
    <span class="c-kw">public int</span> GridX { <span class="c-kw">get</span>; <span class="c-kw">private set</span>; }
    <span class="c-kw">public int</span> GridY { <span class="c-kw">get</span>; <span class="c-kw">private set</span>; }

    [<span class="c-ty">Header</span>(<span class="c-st">"Visuals"</span>)]
    <span class="c-kw">private</span> <span class="c-ty">Color</span> normalColor = <span class="c-kw">new</span> <span class="c-ty">Color</span>(1f, 1f, 1f, 0f);

    <span class="c-cm">// HashSet을 활용한 버프 소스 관리 (중복 방지 및 O(1) 조회 성능 확보)</span>
    <span class="c-kw">private readonly</span> <span class="c-ty">HashSet</span>&lt;<span class="c-ty">File_Base</span>&gt; activeBuffSources = <span class="c-kw">new</span> <span class="c-ty">HashSet</span>&lt;<span class="c-ty">File_Base</span>&gt;(); 
    
    <span class="c-kw">public</span> <span class="c-ty">GameObject</span> obstacleObject { <span class="c-kw">get</span>; <span class="c-kw">private set</span>; }

    <span class="c-cm">// ... 각종 초기화, 점유 파일 세팅/제거, 동적 버프 갱신 로직</span>
}</code></pre>
      
  <p>각 그리드 셀은 단순한 위치 정보가 아닌, <span class="highlight">HashSet 기반의 버프 관리</span>를 통해 중복 버프를 방지하고 상태 변화를 실시간으로 동기화하는 지능형 컨테이너입니다.</p>

                <h3>2.1 기술적 특징</h3>
                <ul>
                    <li><span class="highlight">상태 관리:</span> GridX, GridY, fileUnit, obstacleObject를 통한 셀 상태 추적</li>
                    <li><span class="highlight">HashSet 기반 버프 관리:</span> O(1) 조회 성능과 중복 방지</li>
                    <li><span class="highlight">시각적 피드백:</span> Color State, Hover Effect, Selection을 통한 사용자 경험 향상</li>
                    <li><span class="highlight">자동 동기화:</span> 버프 소스 변경 시 자동으로 상태 업데이트</li>
                </ul>

                <h3>2.2 이벤트 기반 자동 버프 시스템 (Observer Pattern)</h3>
                <p>유닛 배치 시 이미 그리드에 활성화된 버프 소스(Aura)를 즉각 적용받도록 설계되었습니다. <code>HashSet</code>을 사용하여 중복을 원천 차단합니다.</p>

                <div class="visual-frame">
                    <div class="arch-diagram">
                        <div class="arch-layer">
                            <div class="arch-layer-title">Buff Source (File_Base)</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">AddBuffSource()</span>
                                <span class="arch-item">RemoveBuffSource()</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓ Notify</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">FileGrid (Observer)</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">HashSet&lt;File_Base&gt;</span>
                                <span class="arch-item">O(1) Lookup</span>
                                <span class="arch-item">Auto Apply Buff</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓ Apply</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">FileUnit (Target)</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">ApplyBuffFromSource()</span>
                                <span class="arch-item">Real-time Sync</span>
                            </div>
                        </div>
                    </div>
                </div>

<pre><code><span class="c-cm">// FileGrid.cs: 버프 소스 추가 시 즉시 반응 로직</span>
<span class="c-kw">private readonly</span> <span class="c-ty">HashSet</span>&lt;<span class="c-ty">File_Base</span>&gt; _activeBuffSources = <span class="c-kw">new</span> <span class="c-ty">HashSet</span>&lt;<span class="c-ty">File_Base</span>&gt;(); 

<span class="c-kw">public void</span> <span class="c-fn">AddBuffSource</span>(<span class="c-ty">File_Base</span> source)
{
    <span class="c-kw">if</span> (source == <span class="c-kw">null</span>) <span class="c-kw">return</span>;

    <span class="c-cm">// HashSet을 통한 O(1) 중복 체크 및 빠른 조회</span>
    <span class="c-kw">if</span> (!_activeBuffSources.<span class="c-fn">Contains</span>(source)) {
        _activeBuffSources.<span class="c-fn">Add</span>(source);
    }

    <span class="c-cm">// 파일 배치 시 활성화된 버프 소스들을 즉시 적용</span>
    <span class="c-kw">if</span> (fileUnit != <span class="c-kw">null</span>) {
        <span class="c-fn">ApplyBuffFromSource</span>(fileUnit, source, <span class="c-kw">true</span>);
    }
}</code></pre>

                <h4>2.2.1 기술적 특징</h4>
                <ul>
                    <li><span class="highlight">Observer Pattern:</span> 버프 소스와 그리드 간의 느슨한 결합으로 확장성 확보</li>
                    <li><span class="highlight">O(1) 조회:</span> HashSet을 통한 빠른 버프 소스 조회</li>
                    <li><span class="highlight">즉시 적용:</span> 유닛 배치 시 활성화된 버프를 즉시 적용</li>
                    <li><span class="highlight">중복 방지:</span> HashSet을 통한 자동 중복 제거</li>
                </ul>

                <h2>3. GameObjectGridLayout: 커스텀 레이아웃 엔진</h2>
                <p>화면 해상도에 맞춰 그리드의 간격과 셀 크기를 동적으로 계산하고, 전체 시스템의 시작 월드 좌표를 제공하는 핵심 컴포넌트입니다.</p>

                <div class="visual-frame">
                    <div class="transaction-flow mono" style="margin-bottom: 20px;">
                        <div class="flow-step">Camera Resolution</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-step">Calculate Available Space</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-step">Compute Cell Size</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-step">Set Start Position</div>
                    </div>
                    <div style="padding: 18px; background: rgba(88, 166, 255, 0.05); border-radius: 6px; border: 1px solid var(--border-color); text-align: center;">
                        <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">계산 공식:</div>
                        <div style="color: var(--text-color); font-size: 0.9rem; font-family: 'Fira Code'; line-height: 1.8;">
                            <div style="margin-bottom: 8px;">cellSize = (screenSize - padding×2 - spacing×(n-1)) / n</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">n: 그리드 개수 (columns/rows)</div>
                        </div>
                    </div>
                </div>

<pre><code><span class="c-kw">public class</span> <span class="c-ty">GameObjectGridLayout</span> : <span class="c-ty">MonoBehaviour</span>
{
    [<span class="c-ty">Header</span>(<span class="c-st">"Grid Settings"</span>)]
    <span class="c-kw">[SerializeField] private int</span> columns = <span class="string">13</span>; <span class="c-cm">// X축 그리드 수</span>
    <span class="c-kw">[SerializeField] private int</span> rows = <span class="string">7</span>;     <span class="c-cm">// Y축 그리드 수</span>

    <span class="c-kw">[SerializeField] private Vector2</span> cellSize = <span class="type">Vector2</span>.one;
    <span class="c-kw">[SerializeField] private Vector2</span> spacing = <span class="type">Vector2</span>.zero;
    <span class="c-kw">[SerializeField] private Vector2</span> padding = <span class="type">Vector2</span>.zero;

    [<span class="c-ty">Header</span>(<span class="c-st">"Layout Settings"</span>)]
    <span class="c-kw">[SerializeField] private bool</span> fitToScreen;

    <span class="c-kw">public int</span> Columns => columns;
    <span class="c-kw">public int</span> Rows => rows;
    <span class="c-kw">public Vector2</span> CellSize => cellSize;
    <span class="c-kw">public Vector2</span> Spacing => spacing;
    <span class="c-kw">public bool</span> GetFitToScreen => fitToScreen;
    <span class="c-kw">public Vector2</span> StartPos { <span class="c-kw">get</span>; <span class="c-kw">private set</span>; }

    <span class="c-cm">// ... </span>

    <span class="c-cm">// 카메라 해상도에 맞춰 그리드 데이터 동적 계산</span>
    <span class="c-kw">public void</span> <span class="c-fn">FitToScreen</span>() {
        <span class="c-ty">Camera</span> cam = <span class="c-ty">Camera</span>.main;
        <span class="c-kw">float</span> height = cam.orthographicSize * <span class="string">2f</span>;
        <span class="c-kw">float</span> width = height * cam.aspect;

        <span class="c-cm">// 여백과 간격을 제외한 실제 가용 셀 크기 역산</span>
        cellSize.x = (width - (padding.x * <span class="string">2</span>) - (spacing.x * (columns - <span class="string">1</span>))) / columns;
        cellSize.y = (height - (padding.y * <span class="string">2</span>) - (spacing.y * (rows - <span class="string">1</span>))) / rows;

        <span class="c-cm">// 좌상단 기준 월드 시작 좌표 설정</span>
        StartPos = <span class="c-kw">new</span> <span class="c-ty">Vector2</span>(-(width / <span class="string">2</span>) + padding.x + (cellSize.x / <span class="string">2</span>), 
                                (height / <span class="string">2</span>) - padding.y - (cellSize.y / <span class="string">2</span>));
    }
}</code></pre>

                <h3>3.1 기술적 특징</h3>
                <ul>
                    <li><span class="highlight">동적 계산:</span> 화면 해상도에 맞춰 그리드 크기 자동 조정</li>
                    <li><span class="highlight">유연한 설정:</span> columns, rows, spacing, padding을 통한 커스터마이징</li>
                    <li><span class="highlight">시작 위치 제공:</span> StartPos를 통한 그리드 배치 기준점 제공</li>
                    <li><span class="highlight">수학적 정확성:</span> 정확한 셀 크기 계산으로 일관된 레이아웃 보장</li>
                </ul>

                <h2>4. FileGridManager: 그리드 관련 매니저</h2>
                <p>전체 그리드 시스템을 총괄하며, 좌표 변환, 조건부 탐색, 유닛 배치 트랜잭션을 총괄합니다.</p>

                <h3>4.1 공간 분할 최적화: 3x3 국소 영역 탐색 (Spatial Partitioning)</h3>
                <p>전체 그리드(91개)를 순회하는 대신, 중심 그리드 기준 3x3 영역만 검사하여 탐색 비용을 <strong>O(n)에서 O(1)</strong>로 단축했습니다. (약 10배 이상 성능 향상)</p>
                <div class="visual-frame">
                    <div class="diagram-grid">
                        <div class="grid-cell near"></div><div class="grid-cell near"></div><div class="grid-cell near"></div>
                        <div class="grid-cell near"></div><div class="grid-cell active"></div><div class="grid-cell near"></div>
                        <div class="grid-cell near"></div><div class="grid-cell near"></div><div class="grid-cell near"></div>
                    </div>
                </div>

<pre><code><span class="c-cm">// FileGridManager.cs: 공간 분할 기반 국소 탐색 최적화</span>
<span class="c-kw">private</span> <span class="c-ty">FileGrid</span> <span class="c-fn">FindClosestGridInRange</span>(<span class="c-ty">Vector2</span> worldPos, <span class="c-kw">int</span> centerX, <span class="c-kw">int</span> centerY)
{
    <span class="c-kw">float</span> minDistSqr = <span class="c-kw">float</span>.MaxValue;
    <span class="c-ty">FileGrid</span> closestGrid = <span class="c-kw">null</span>;

    <span class="c-kw">for</span> (<span class="c-kw">int</span> dx = -<span class="string">1</span>; dx <= <span class="string">1</span>; dx++) {
        <span class="c-kw">for</span> (<span class="c-kw">int</span> dy = -<span class="string">1</span>; dy <= <span class="string">1</span>; dy++) {
            <span class="c-kw">int</span> x = centerX + dx; <span class="c-kw">int</span> y = centerY + dy;
            <span class="c-kw">if</span> (<span class="c-fn">IsValidGridIndex</span>(x, y)) {
                <span class="c-fn">SearchClosestBetter</span>(gridArray[x, y], worldPos, <span class="c-kw">ref</span> minDistSqr, <span class="c-kw">ref</span> closestGrid);
            }
        }
    }
    <span class="c-kw">return</span> closestGrid;
}

<span class="c-cm">// 제곱 거리(sqrMagnitude) 사용으로 sqrt 연산 제거 최적화</span>
<span class="c-kw">private void</span> <span class="c-fn">SearchClosestBetter</span>(<span class="c-ty">FileGrid</span> candidate, <span class="c-ty">Vector2</span> worldPos, <span class="c-kw">ref float</span> bestDistSqr, <span class="c-kw">ref FileGrid</span> bestGrid)
{
    <span class="c-kw">if</span> (candidate == <span class="c-kw">null</span>) <span class="c-kw">return</span>;
    <span class="c-kw">float</span> distSqr = ((<span class="c-ty">Vector2</span>)candidate.transform.position - worldPos).sqrMagnitude;
    <span class="c-kw">if</span> (distSqr < bestDistSqr) {
        bestDistSqr = distSqr;
        bestGrid = candidate;
    }
}</code></pre>

                <h3>[트랜잭션 보장 패턴] 원자적 배치 로직 (Transactional Pattern)</h3>
                <p>유닛 배치 시 데이터 불일치를 방지하고 실패 시 이전 상태를 유지하기 위해 <strong>원자적(Atomic) 배치 로직</strong>을 설계했습니다.</p>

<pre><code><span class="c-kw">public bool</span> <span class="c-fn">TrySetUnitAtGrid</span>(<span class="c-ty">File_Base</span> unit, <span class="c-ty">FileGrid</span> targetGrid)
{
    <span class="c-cm">// 1. 유효성 검사 (Pre-validation)</span>
    <span class="c-kw">if</span> (unit == <span class="c-kw">null</span> || targetGrid == <span class="c-kw">null</span> || targetGrid.obstacleObject != <span class="c-kw">null</span>) <span class="c-kw">return false</span>;

    <span class="c-cm">// 2. 기존 그리드에서 안전하게 제거 (Rollback 준비)</span>
    <span class="c-ty">FileGrid</span> currentGrid = unit.CurrentGrid;
    <span class="c-kw">if</span> (currentGrid != <span class="c-kw">null</span> && currentGrid != targetGrid) {
        currentGrid.<span class="c-fn">RemoveFileUnit</span>(); 
    }

    <span class="c-cm">// 3. Commit: 상태 변경 및 물리/논리 계층 구조 설정</span>
    unit.FileState = <span class="c-ty">FileStatus</span>.normal;
    unit.transform.position = targetGrid.transform.position;
    unit.transform.<span class="c-fn">SetParent</span>(targetGrid.transform);
    
    <span class="c-cm">// 4. Notify: 새 그리드 등록 및 버프 자동 적용</span>
    targetGrid.<span class="c-fn">SetFileUnit</span>(unit); 
    <span class="c-kw">return true</span>;
}</code></pre>

                <h4>4.2.1 기술적 특징</h4>
                <ul>
                    <li><span class="highlight">원자적 연산:</span> 모든 상태 변경이 성공하거나 모두 롤백되는 트랜잭션 보장</li>
                    <li><span class="highlight">사전 검증:</span> Pre-validation을 통한 실패 가능성 사전 차단</li>
                    <li><span class="highlight">롤백 지원:</span> 실패 시 이전 상태로 안전하게 복원</li>
                    <li><span class="highlight">데이터 일관성:</span> 물리/논리 계층 구조의 동기화 보장</li>
                </ul>
                
                <h3>4.3 동적 좌표 변환 시스템: 양방향 좌표 변환 (Dynamic Coordinate Transformation)</h3>
                <p>월드 좌표와 그리드 인덱스 간의 <span class="highlight">양방향 변환</span>을 지원하여, 마우스 위치나 유닛의 월드 좌표를 그리드 인덱스로 변환하거나, 그리드 인덱스를 월드 좌표로 변환할 수 있습니다.</p>
                <p>Unity의 Transform 계층 구조를 활용하여 부모 객체의 변환을 자동으로 적용하며, 그리드 레이아웃의 셀 크기, 간격, 패딩을 동적으로 계산합니다.</p>

                <div class="visual-frame">
                    <div style="margin-bottom: 30px;">
                        <div style="text-align: center; color: var(--accent-color); font-weight: 700; margin-bottom: 15px; font-family: 'Fira Code'; font-size: 1rem;">
                            월드 좌표 → 그리드 인덱스 변환
                        </div>
                        <div class="coord-flow">
                            <div class="coord-box">
                                <div class="coord-box-title">World Position</div>
                                <div class="coord-box-desc">
                                    <strong>입력:</strong> Vector2 worldPos<br/>
                                    <span style="color: #8b949e;">마우스 위치 또는<br/>유닛의 월드 좌표</span>
                                </div>
                            </div>
                            <div class="coord-arrow">→</div>
                            <div class="coord-box">
                                <div class="coord-box-title">Local Position</div>
                                <div class="coord-box-desc">
                                    <strong>변환:</strong> InverseTransformPoint()<br/>
                                    <span style="color: #8b949e;">부모 Transform의<br/>로컬 좌표계로 변환</span>
                                </div>
                                <div class="coord-box-formula">localPos = transform.InverseTransformPoint(worldPos)</div>
                            </div>
                            <div class="coord-arrow">→</div>
                            <div class="coord-box">
                                <div class="coord-box-title">Grid Index</div>
                                <div class="coord-box-desc">
                                    <strong>출력:</strong> (x, y)<br/>
                                    <span style="color: #8b949e;">그리드 배열 인덱스<br/>(반올림 적용)</span>
                                </div>
                                <div class="coord-box-formula">x = Round((localPos.x - startPos.x) / cellWidth)</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="coord-bidirectional">↕ 양방향 변환 (Bidirectional)</div>
                    
                    <div>
                        <div style="text-align: center; color: var(--accent-color); font-weight: 700; margin-bottom: 15px; font-family: 'Fira Code'; font-size: 1rem;">
                            그리드 인덱스 → 월드 좌표 변환
                        </div>
                        <div class="coord-flow">
                            <div class="coord-box">
                                <div class="coord-box-title">Grid Index</div>
                                <div class="coord-box-desc">
                                    <strong>입력:</strong> (x, y)<br/>
                                    <span style="color: #8b949e;">그리드 배열의<br/>인덱스 좌표</span>
                                </div>
                            </div>
                            <div class="coord-arrow">→</div>
                            <div class="coord-box">
                                <div class="coord-box-title">Local Position</div>
                                <div class="coord-box-desc">
                                    <strong>계산:</strong> startPos + offset<br/>
                                    <span style="color: #8b949e;">시작 위치 + (셀 크기 × 인덱스)<br/>+ 간격(spacing) 적용</span>
                                </div>
                                <div class="coord-box-formula">localPos = startPos + x × (cellSize + spacing)</div>
                            </div>
                            <div class="coord-arrow">→</div>
                            <div class="coord-box">
                                <div class="coord-box-title">World Position</div>
                                <div class="coord-box-desc">
                                    <strong>출력:</strong> Vector2<br/>
                                    <span style="color: #8b949e;">월드 좌표계의<br/>절대 위치</span>
                                </div>
                                <div class="coord-box-formula">worldPos = transform.TransformPoint(localPos)</div>
                            </div>
                        </div>
                    </div>
                </div>

<pre><code><span class="c-cm">// 월드 좌표 → 그리드 인덱스</span>
<span class="c-kw">private bool</span> <span class="c-fn">WorldToGridIndex</span>(<span class="c-ty">Vector2</span> worldPos, <span class="c-kw">out int</span> x, <span class="c-kw">out int</span> y)
{
    x = <span class="string">0</span>;
    y = <span class="string">0</span>;

    <span class="c-kw">if</span> (gridLayout == <span class="c-kw">null</span>) <span class="c-kw">return false</span>;

    <span class="c-cm">// 1. 월드 → 로컬 변환</span>
    <span class="c-ty">Vector2</span> localPos = transform.<span class="c-fn">InverseTransformPoint</span>(worldPos);

    <span class="c-cm">// 2. 그리드 시작 위치 계산 (중앙 기준)</span>
    <span class="c-ty">Vector2</span> startPos = <span class="c-kw">new</span> <span class="c-ty">Vector2</span>(
        -gridLayout.CellSize.x * (GridWidth - <span class="string">1</span>) * <span class="string">0.5f</span>,
        -gridLayout.CellSize.y * (GridHeight - <span class="string">1</span>) * <span class="string">0.5f</span>
    );
    startPos += gridLayout.Padding;

    <span class="c-cm">// 3. 인덱스 계산</span>
    <span class="c-kw">float</span> xFloat = (localPos.x - startPos.x) / (gridLayout.CellSize.x + gridLayout.Spacing.x);
    <span class="c-kw">float</span> yFloat = (localPos.y - startPos.y) / (gridLayout.CellSize.y + gridLayout.Spacing.y);

    x = <span class="c-ty">Mathf</span>.<span class="c-fn">RoundToInt</span>(xFloat);
    y = <span class="c-ty">Mathf</span>.<span class="c-fn">RoundToInt</span>(yFloat);

    <span class="c-kw">return true</span>;
}

<span class="c-cm">// 그리드 인덱스 → 월드 좌표</span>
<span class="c-kw">public</span> <span class="c-ty">Vector2</span> <span class="c-fn">GetGridWorldPosition</span>(<span class="c-kw">int</span> x, <span class="c-kw">int</span> y)
{
    <span class="c-kw">if</span> (gridLayout == <span class="c-kw">null</span>) <span class="c-kw">return</span> <span class="c-ty">Vector2</span>.zero;

    <span class="c-cm">// 1. 로컬 위치 계산</span>
    <span class="c-ty">Vector2</span> startPos = <span class="c-kw">new</span> <span class="c-ty">Vector2</span>(
        -gridLayout.CellSize.x * (GridWidth - <span class="string">1</span>) * <span class="string">0.5f</span>,
        -gridLayout.CellSize.y * (GridHeight - <span class="string">1</span>) * <span class="string">0.5f</span>
    );
    startPos += gridLayout.Padding;

    <span class="c-ty">Vector2</span> localPos = <span class="c-kw">new</span> <span class="c-ty">Vector2</span>(
        startPos.x + x * (gridLayout.CellSize.x + gridLayout.Spacing.x),
        startPos.y + y * (gridLayout.CellSize.y + gridLayout.Spacing.y)
    );

    <span class="c-cm">// 2. 로컬 → 월드 변환</span>
    <span class="c-kw">return</span> transform.<span class="c-fn">TransformPoint</span>(localPos);
}</code></pre>

                <h4>4.3.1 기술적 특징</h4>
                <ul>
                    <li><span class="highlight">양방향 변환:</span> 월드 ↔ 그리드 인덱스 완전 호환</li>
                    <li><span class="highlight">동적 계산:</span> 런타임에 그리드 크기 변경 대응</li>
                    <li><span class="highlight">정밀도:</span> 반올림으로 정확한 인덱스 매핑</li>
                    <li><span class="highlight">Transform 계층 지원:</span> 부모 Transform 변환 자동 적용</li>
                </ul>

                <h3>4.4 플래그 기반 확장 가능한 검색 시스템: 확장 가능한 필터링 (Flag-Based Extensible Search)</h3>
                <p>그리드 검색 시 점유 상태, 장애물 존재 여부 등 다양한 조건을 <span class="highlight">플래그 조합</span>으로 필터링할 수 있는 확장 가능한 검색 시스템입니다.</p>
                <p>enum 기반의 플래그 시스템을 통해 새로운 검색 조건을 쉽게 추가할 수 있으며, 여러 플래그를 동시에 사용하여 복합 조건 검색이 가능합니다.</p>

                <div class="visual-frame">
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>플래그</th>
                                <th>설명</th>
                                <th>사용 예시</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>Occupied</code></td>
                                <td>점유된 그리드만 검색</td>
                                <td>유닛이 설치된 위치 찾기</td>
                            </tr>
                            <tr>
                                <td><code>NotOccupied</code></td>
                                <td>비어있는 그리드만 검색</td>
                                <td>새 유닛 배치 가능 위치</td>
                            </tr>
                            <tr>
                                <td><code>Obstacle</code></td>
                                <td>장애물이 있는 그리드만</td>
                                <td>장애물 위치 확인</td>
                            </tr>
                            <tr>
                                <td><code>NotObstacle</code></td>
                                <td>장애물이 없는 그리드만</td>
                                <td>배치 가능한 안전한 위치</td>
                            </tr>
                            <tr>
                                <td><code>None</code></td>
                                <td>필터 없음</td>
                                <td>모든 그리드 검색</td>
                            </tr>
                        </tbody>
                    </table>
                    <div style="margin-top: 20px; padding: 15px; background: rgba(88, 166, 255, 0.05); border-radius: 6px; border: 1px solid var(--border-color); text-align: center;">
                        <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px; font-family: 'Fira Code'; font-size: 0.95rem;">조합 예시:</div>
                        <div style="color: var(--text-color); font-size: 0.9rem; font-family: 'Fira Code'; line-height: 1.6;">
                            <code style="color: var(--code-func);">FindFlagGridWorld</code>(pos, <code style="color: var(--code-type);">NotOccupied</code>, <code style="color: var(--code-type);">NotObstacle</code>)<br/>
                            <span style="color: #8b949e; font-size: 0.85rem;">→ 비어있고 장애물이 없는 가장 가까운 그리드 검색</span>
                        </div>
                    </div>
                </div>

<pre><code><span class="c-kw">public enum</span> <span class="c-ty">SearchGridFlag</span>
{
    Occupied,       <span class="c-cm">// 점유</span>
    NotOccupied,    <span class="c-cm">// 비점유</span>
    Obstacle,       <span class="c-cm">// 장애물이 존재하는 그리드만</span>
    NotObstacle,    <span class="c-cm">// 장애물이 존재하지 않는 그리드만</span>
    None,
}

<span class="c-kw">public</span> <span class="c-ty">FileGrid</span> <span class="c-fn">FindFlagGridWorld</span>(<span class="c-ty">Vector2</span> worldPos, <span class="c-kw">params</span> <span class="c-ty">SearchGridFlag</span>[] flags)
{
    <span class="c-kw">float</span> bestDistSqr = <span class="c-kw">float</span>.MaxValue;
    <span class="c-ty">FileGrid</span> bestGrid = <span class="c-kw">null</span>;

    <span class="c-kw">foreach</span> (<span class="c-ty">FileGrid</span> grid <span class="c-kw">in</span> gridArray)
    {
        <span class="c-kw">if</span> (grid == <span class="c-kw">null</span>) <span class="c-kw">continue</span>;

        <span class="c-cm">// 플래그 조건 체크</span>
        <span class="c-kw">if</span> (!<span class="c-fn">CheckGridMatchesFlags</span>(grid, flags))
            <span class="c-kw">continue</span>;

        <span class="c-fn">SearchClosestBetter</span>(grid, worldPos, <span class="c-kw">ref</span> bestDistSqr, <span class="c-kw">ref</span> bestGrid);
    }

    <span class="c-kw">return</span> bestGrid;
}</code></pre>

                <h4>4.4.1 기술적 특징</h4>
                <ul>
                    <li><span class="highlight">확장성:</span> 새로운 플래그 추가 용이</li>
                    <li><span class="highlight">조합 가능:</span> 여러 플래그 동시 사용</li>
                    <li><span class="highlight">가변 인자:</span> params 키워드로 유연한 호출</li>
                    <li><span class="highlight">AND 조건:</span> 모든 플래그 조건 만족 필요</li>
                </ul>

                <h2>5. 전체 시스템 기술적 특징</h2>
                <p>FileTowerDefense 프로젝트의 리팩토링을 통해 달성한 핵심 기술적 특징입니다.</p>
                <ul>
                    <li><span class="highlight">좌표계 통일:</span> UI에서 GameObject로 전환하여 월드 좌표계 기반 통합 시스템 구축</li>
                    <li><span class="highlight">성능 최적화:</span> 공간 분할 알고리즘으로 O(n)에서 O(1) 탐색 비용 단축</li>
                    <li><span class="highlight">데이터 일관성:</span> 트랜잭션 패턴을 통한 원자적 배치 로직 보장</li>
                    <li><span class="highlight">확장성:</span> 플래그 기반 검색 시스템과 Observer Pattern을 통한 유연한 아키텍처</li>
                    <li><span class="highlight">동적 레이아웃:</span> 화면 해상도에 맞춰 자동으로 조정되는 그리드 시스템</li>
                    <li><span class="highlight">양방향 좌표 변환:</span> 월드 좌표와 그리드 인덱스 간 완전한 호환성</li>
                    <li><span class="highlight">이벤트 기반 버프 시스템:</span> HashSet을 활용한 O(1) 버프 관리 및 자동 동기화</li>
                </ul>
                </div>

                <div id="existing-tab" class="tab-content">
                <h1 style="font-size: 2.5rem; margin-bottom: 30px; color: #f0f6fc;">입력 및 상호작용 시스템</h1>

                <h2>1. Mouse Event: 중앙 집중식 마우스 입력 관리</h2>
                <p>수많은 유닛이 개별 이벤트를 수신하지 않고, <code>InputManager</code>가 모든 마우스 입력을 통합 관리하여 <code>IInteractable</code> 인터페이스를 구현한 객체에 전달합니다.</p>

                <div class="visual-frame">
                    <div class="arch-diagram">
                        <div class="arch-layer">
                            <div class="arch-layer-title">Input Layer</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">Mouse Input</span>
                                <span class="arch-item">Screen Position</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">InputManager (Central Hub)</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">ScreenToWorldPoint()</span>
                                <span class="arch-item">Physics2D.Raycast()</span>
                                <span class="arch-item">GetInteractableUnderMouse()</span>
                                <span class="arch-item">IsOverUI() 우선순위 판정</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓ Dispatch</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">InteractionHandler</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">HandlePointerEnter/Exit</span>
                                <span class="arch-item">HandlePointerDown/Up</span>
                                <span class="arch-item">HandleDrag</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">IInteractable Objects</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">File_Base (Units)</span>
                                <span class="arch-item">Virus (Enemies)</span>
                                <span class="arch-item">UI Elements</span>
                            </div>
                        </div>
                    </div>
                    <p style="margin-top: 20px; padding: 12px; background: rgba(88, 166, 255, 0.05); border-radius: 6px; border: 1px solid var(--border-color); color: #8b949e; font-size: 0.9rem; line-height: 1.6; text-align: center;">
                        <strong style="color: var(--accent-color);">장점:</strong> 개별 객체가 이벤트를 수신하지 않아 성능 최적화 및 중앙 집중식 관리 가능
                    </p>
                </div>

                <h3>핵심 처리 플로우</h3>
                <p>InputManager는 매 프레임 사용자 입력을 감지해서, 다음 순서로 입력을 처리합니다:</p>

                <div class="visual-frame">
                    <div class="transaction-flow mono" style="margin-bottom: 20px;">
                        <div class="flow-step">HandleHover()<br/>객체 탐지</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-step">HandleMouseInput()<br/>클릭/드래그</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-step">InteractionHandler<br/>이벤트 전달</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-step">IInteractable<br/>객체 처리</div>
                    </div>
                </div>

                <h4>1. 객체 탐지 (GetInteractableUnderMouse)</h4>
                <p>Physics2D.Raycast를 사용하여 마우스 위치의 상호작용 가능한 객체를 탐지합니다. <span class="highlight">레이어 우선순위</span>를 적용하여 Unit 레이어를 먼저 검사하고, 없을 경우 바이러스 등 다른 상호작용 객체를 검사합니다.</p>

                <h4>2. 레이어 우선순위 처리 (IsOverUI)</h4>
                <p>UI와 게임 오브젝트가 겹칠 때, <span class="highlight">SortingLayer와 SortingOrder</span>를 비교하여 정확한 우선순위를 판정합니다. UI Raycast와 GameObject Raycast 결과를 비교하여 UI가 위에 있으면 게임 오브젝트 이벤트를 무시합니다.</p>

                <h4>3. 상태 머신 기반 드래그 처리</h4>
                <p>InputState (None → Pressing → DraggingObject/DraggingBox → None) 기반으로 드래그를 관리합니다. <span class="highlight">dragThreshold</span>를 기반으로 드래그 시작을 판정하며, 객체 드래그와 박스 선택 드래그를 자동으로 구분합니다.</p>

                <div class="visual-frame">
                    <div class="transaction-flow mono" style="margin-bottom: 20px;">
                        <div class="flow-step">None</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-step">Pressing<br/>(거리 &lt; threshold)</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-step">DraggingObject<br/>DraggingBox<br/>(거리 &gt; threshold)</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-step">None</div>
                    </div>
                </div>

                <h4>4. 더블클릭 감지</h4>
                <p>0.3초 threshold를 사용하여 같은 객체에 대한 연속 클릭을 더블클릭으로 감지합니다.</p>

                <h4>5. 박스 선택 및 바이러스 특수 처리</h4>
                <p>빈 공간에서 드래그 시 <span class="highlight">Physics2D.OverlapAreaAll</span>을 사용하여 영역 내 모든 객체를 선택합니다. 바이러스 드래그는 <code>HasActiveViruses</code> 플래그로 일반 드래그와 구분하여 처리합니다.</p>

                <p><strong>기술적 특징:</strong></p>
                <ul>
                    <li><span class="highlight">중앙 집중식 관리:</span> 모든 마우스 입력을 InputManager에서 통합 처리</li>
                    <li><span class="highlight">레이어 우선순위:</span> SortingLayer/SortingOrder 기반 정교한 우선순위 판정</li>
                    <li><span class="highlight">상태 머신:</span> InputState 기반 명확한 드래그 상태 관리</li>
                    <li><span class="highlight">성능 최적화:</span> 개별 객체가 이벤트를 수신하지 않아 오버헤드 감소</li>
                </ul>

                <h2>2. InteractionHandler: 이벤트 기반 상호작용 관리 시스템</h2>
                <p><code>InteractionHandler</code>는 <span class="highlight">이벤트 기반 아키텍처</span>를 통해 InputManager와 IInteractable 객체 간의 상호작용을 중재합니다. 각 객체가 개별적으로 이벤트를 수신하지 않고, InteractionHandler가 모든 상호작용을 통합 관리하여 성능을 최적화하고 일관된 동작을 보장합니다.</p>

                <div class="visual-frame">
                    <div class="arch-diagram">
                        <div class="arch-layer">
                            <div class="arch-layer-title">InputManager</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">GetInteractableUnderMouse()</span>
                                <span class="arch-item">HandleLeftMouseDown()</span>
                                <span class="arch-item">HandleDrag()</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">InteractionHandler (Mediator)</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">HandlePointerDown/Up</span>
                                <span class="arch-item">HandleBeginDrag/EndDrag</span>
                                <span class="arch-item">HandleDoubleClick</span>
                                <span class="arch-item">SelectionData 관리</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">IInteractable Objects</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">OnClick()</span>
                                <span class="arch-item">OnDrag()</span>
                                <span class="arch-item">OnHoverEnter/Exit</span>
                            </div>
                        </div>
                    </div>
                </div>

                <h3>IInteractable 인터페이스: 확장 가능한 상호작용 계약</h3>
                <p>모든 상호작용 가능한 객체는 <code>IInteractable</code> 인터페이스를 구현하여 일관된 상호작용 패턴을 제공합니다.</p>

<pre><code><span class="c-cm">// IInteractable.cs: 상호작용 가능한 객체를 위한 인터페이스</span>
<span class="c-kw">public interface</span> <span class="c-ty">IInteractable</span>
{
    <span class="c-ty">GameObject</span> targetObj { <span class="c-kw">get</span>; }
    <span class="c-ty">Transform</span> transform { <span class="c-kw">get</span>; }
    <span class="c-ty">Sprite</span> TooltipImg { <span class="c-kw">get</span>; }
    <span class="c-ty">string</span> ToolTipDes { <span class="c-kw">get</span>; }
    
    <span class="c-cm">// 선택 상태 관리</span>
    <span class="c-kw">bool</span> IsSelectable { <span class="c-kw">get</span>; }
    <span class="c-kw">bool</span> IsDraggable { <span class="c-kw">get</span>; }
    <span class="c-kw">bool</span> IsTooltipEnabled { <span class="c-kw">get</span>; }
    
    <span class="c-cm">// 이벤트 메서드</span>
    <span class="c-kw">void</span> <span class="c-fn">OnHoverEnter</span>();     <span class="c-cm">// 마우스가 객체 위로 올라올 때</span>
    <span class="c-kw">void</span> <span class="c-fn">OnHoverExit</span>();      <span class="c-cm">// 마우스가 객체에서 벗어날 때</span>
    <span class="c-kw">void</span> <span class="c-fn">OnClickEnter</span>();     <span class="c-cm">// 마우스 버튼을 누를 때</span>
    <span class="c-kw">void</span> <span class="c-fn">OnClickExit</span>();      <span class="c-cm">// 마우스 버튼을 뗄 때</span>
    <span class="c-kw">void</span> <span class="c-fn">OnBeginDrag</span>();       <span class="c-cm">// 드래그 시작</span>
    <span class="c-kw">void</span> <span class="c-fn">OnDrag</span>(<span class="c-ty">Vector2</span> mouseDelta); <span class="c-cm">// 드래그 중</span>
    <span class="c-kw">void</span> <span class="c-fn">OnEndDrag</span>();         <span class="c-cm">// 드래그 종료</span>
    <span class="c-kw">void</span> <span class="c-fn">OnClick</span>();            <span class="c-cm">// 클릭 처리</span>
    <span class="c-kw">void</span> <span class="c-fn">OnDoubleClick</span>();    <span class="c-cm">// 더블클릭 처리</span>
    <span class="c-kw">void</span> <span class="c-fn">OnRightClick</span>();     <span class="c-cm">// 우클릭 처리</span>
    <span class="c-kw">void</span> <span class="c-fn">OnSelectSingle</span>();   <span class="c-cm">// 단일 선택</span>
    <span class="c-kw">void</span> <span class="c-fn">OnSelected</span>(<span class="c-kw">bool</span> isSelected); <span class="c-cm">// 선택 상태 표시</span>
}</code></pre>

                <p><strong>기술적 특징:</strong></p>
                <ul>
                    <li><span class="highlight">인터페이스 기반 설계:</span> 다양한 객체 타입(File_Base, Virus, UI)이 동일한 인터페이스로 처리</li>
                    <li><span class="highlight">확장성:</span> 새로운 상호작용 가능한 객체 추가 시 인터페이스만 구현하면 자동 통합</li>
                    <li><span class="highlight">관심사 분리:</span> 각 객체는 자신의 상호작용 로직만 구현, InteractionHandler가 흐름 제어</li>
                </ul>

                <h3>InteractionHandler의 핵심 기능</h3>
                <p>InteractionHandler는 선택 상태 관리, 드래그 처리, ToolTip 관리, 바이러스 특수 처리 등을 담당합니다. 단일 클래스에서 모든 상호작용을 관리합니다.</p>

                <div class="visual-frame">
                    <div class="arch-diagram">
                        <div class="arch-layer">
                            <div class="arch-layer-title">포인터 다운 처리</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">OnClickEnter() 호출</span>
                                <span class="arch-item">선택 상태 관리</span>
                                <span class="arch-item">단일/멀티 선택 처리</span>
                                <span class="arch-item">OnClick() 호출</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">드래그 시작 처리</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">선택된 객체만 드래그 대상</span>
                                <span class="arch-item">원본 위치 저장</span>
                                <span class="arch-item">OnBeginDrag() 호출</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">드래그 중 처리</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">각 객체의 OnDrag() 호출</span>
                                <span class="arch-item">위치 이동 처리</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">드래그 종료 처리</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">OnEndDrag() 호출</span>
                                <span class="arch-item">드래그 상태 초기화</span>
                                <span class="arch-item">선택 해제</span>
                            </div>
                        </div>
                    </div>
                </div>

                <h3>선택 상태 관리 시스템</h3>
                <p>InteractionHandler는 <span class="highlight">Dictionary를 사용한 원본 위치 저장</span>과 <span class="highlight">List 기반 선택 관리</span>를 통해 효율적인 상태 관리를 제공합니다.</p>

                <div class="visual-frame">
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin: 20px 0; align-items: stretch;">
                        <div style="padding: 18px; border: 2px solid var(--accent-color); border-radius: 8px; background: rgba(88, 166, 255, 0.05); text-align: center; display: flex; flex-direction: column; justify-content: flex-start;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">선택 관리</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.8; flex-grow: 1;">
                                <div>• SelectedObjects</div>
                                <div>• 멀티 선택 지원</div>
                                <div>• 단일/다중 선택</div>
                                <div>• Ctrl 키 토글</div>
                            </div>
                        </div>
                        <div style="padding: 18px; border: 2px solid var(--sub-accent); border-radius: 8px; background: rgba(35, 134, 54, 0.05); text-align: center; display: flex; flex-direction: column; justify-content: flex-start;">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">드래그 관리</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.8; flex-grow: 1;">
                                <div>• DragObjects</div>
                                <div>• 원래 위치 저장</div>
                                <div>• 복원 기능</div>
                                <div>• 드래그 상태 추적</div>
                            </div>
                        </div>
                        <div style="padding: 18px; border: 2px solid var(--border-color); border-radius: 8px; background: rgba(0,0,0,0.2); text-align: center; display: flex; flex-direction: column; justify-content: flex-start;">
                            <div style="color: var(--text-color); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">상태 관리</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.8; flex-grow: 1;">
                                <div>• OriginalPositions</div>
                                <div>• 선택 해제</div>
                                <div>• 상태 초기화</div>
                                <div>• 바이러스 처리</div>
                            </div>
                        </div>
                    </div>
                </div>

                <p><strong>기술적 특징:</strong></p>
                <ul>
                    <li><span class="highlight">Mediator 패턴:</span> InputManager와 IInteractable 객체 간의 직접적인 의존성 제거</li>
                    <li><span class="highlight">선택 상태 캡슐화:</span> SelectedObjects, DragObjects, OriginalPositions를 통해 선택 상태를 중앙에서 관리</li>
                    <li><span class="highlight">원본 위치 복원:</span> Dictionary를 사용하여 드래그 실패 시 원래 위치로 복원 가능</li>
                    <li><span class="highlight">멀티 선택 지원:</span> Ctrl 키를 통한 토글 방식 멀티 선택</li>
                    <li><span class="highlight">ToolTip 관리:</span> StageMain_UI와 연동하여 ToolTip 표시/숨김 처리</li>
                    <li><span class="highlight">바이러스 특수 처리:</span> HasActiveViruses 플래그로 일반 드래그와 구분, 별도 핸들러 메서드 제공</li>
                    <li><span class="highlight">확장 가능한 인터페이스:</span> OnClickEnterHandler, OnBeginDragHandler, OnDragHandler 등 명확한 메서드 네이밍</li>
                </ul>

                <div style="height: 100px;"></div>
            </div>
        </div>
    </div>

    <!-- ML-Agents Racing Modal -->
    <div id="modal-overlay-racing" class="modal-overlay" onclick="closeModal('racing')">
        <div class="modal-container" onclick="event.stopPropagation()">
            <div class="modal-body">
                <div class="modal-header-nav">
                    <div class="mono" style="color: var(--accent-color);">PROJECT REPORT // AUTONOMOUS_RACING_AGENT</div>
                    <button onclick="closeModal('racing')" style="background: none; border: 1px solid var(--accent-color); color: var(--accent-color); padding: 8px 20px; border-radius: 6px; cursor: pointer; font-family: 'Fira Code'; font-size: 0.8rem;">[X] DISCONNECT</button>
                </div>
                
                <h1 style="font-size: 2.5rem; margin-bottom: 30px; color: #f0f6fc;">ML-Agents 자율 주행 경주차 학습 시스템</h1>

                <div class="visual-frame" style="margin: 30px 0;">
                    <img src="Gifs/제목 없는 비디오 - Clipchamp로 제작.gif" alt="ML-Agents 학습 시각화" style="width: 100%; border-radius: 8px; border: 2px solid var(--border-color);">
                </div>

                <h2>1. 프로젝트 개요</h2>
                <p>Unity ML-Agents를 활용하여 정해진 트랙을 안정적으로 주행하는 자율 주행 경주차 에이전트를 학습시킨 프로젝트입니다. <span class="highlight">체크포인트 기반 네비게이션 시스템</span>과 <span class="highlight">목표 지향 보상 설계</span>를 통해 에이전트가 트랙을 순차적으로 주행하도록 설계했습니다.</p>

                <div class="visual-frame" style="margin: 30px 0;">
                    <img src="images/mlagent_4.png" alt="ML-Agents 트랙 환경" style="width: 100%; border-radius: 8px; border: 2px solid var(--border-color);">
                    <p style="text-align: center; color: #8b949e; font-size: 0.9rem; margin-top: 10px;">구불구불한 도로와 바위 지형으로 구성된 학습 트랙 환경</p>
                </div>

                <h2>2. 체크포인트 기반 네비게이션 시스템</h2>
                <div style="background: linear-gradient(135deg, rgba(255, 193, 7, 0.1) 0%, rgba(255, 152, 0, 0.1) 100%); border-left: 4px solid #ff9800; padding: 15px 20px; margin: 20px 0; border-radius: 6px;">
                    <p style="margin: 0; color: #e0e0e0;"><strong style="color: #ff9800;">시행착오 및 문제 해결:</strong></p>
                    <p style="margin: 10px 0 0 0; color: #c9d1d9;">초기 설계에서는 차량 Agent들이 자율주행을 수행할 때 <span class="highlight">역주행 현상</span>이 빈번하게 발생했습니다. 목표 지점까지의 최단 경로를 찾는 과정에서 에이전트가 트랙을 거꾸로 주행하거나, 잘못된 방향으로 이동하는 문제가 있었습니다. 이를 해결하기 위해 <span class="highlight">목표 지점까지의 여러 체크포인트를 순차적으로 배치</span>하여 에이전트가 반드시 앞으로 주행하도록 강제하는 시스템을 설계했습니다.</p>
                </div>
                <p>에이전트가 트랙을 올바른 순서로 주행하도록 <span class="highlight">체크포인트 시스템</span>을 구현했습니다. 각 체크포인트를 순차적으로 통과해야 다음 목표로 진행할 수 있으며, 잘못된 순서로 통과 시 페널티를 받습니다.</p>

                <div class="visual-frame">
                    <div class="arch-diagram">
                        <div class="arch-layer">
                            <div class="arch-layer-title">SplineToCheckpointGenerator</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">스플라인에서 체크포인트 자동 생성</span>
                                <span class="arch-item">BoxCollider(Trigger) 설정</span>
                                <span class="arch-item">태그 자동 할당</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">SpawnPointManager</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">체크포인트 배열 관리</span>
                                <span class="arch-item">스폰 포인트 관리</span>
                                <span class="arch-item">Finish 포인트 관리</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">SimcadeCarAgent_Auto</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">체크포인트 통과 감지</span>
                                <span class="arch-item">목표 위치 계산</span>
                                <span class="arch-item">거리 기반 보상</span>
                            </div>
                        </div>
                    </div>
                </div>

                <h3>CheckPoint: 순차적 체크포인트 검증</h3>
                <p><code>CheckPoint</code>는 트리거를 통해 플레이어가 올바른 순서의 체크포인트를 통과했는지 검증합니다. 마지막 체크포인트 통과 시 랩을 증가시키고 체크포인트를 리셋합니다.</p>

<pre><code><span class="c-cm">// CheckPoint.cs: 체크포인트 트리거 처리</span>
<span class="c-kw">private void</span> <span class="c-fn">OnTriggerEnter</span>(<span class="c-ty">Collider</span> other)
{
    <span class="c-kw">if</span> (other.CompareTag(<span class="c-st">"Player"</span>)) {
        <span class="c-ty">CarProgress</span> progress = other.GetComponentInParent&lt;<span class="c-ty">CarProgress</span>&gt;();
        
        <span class="c-cm">// 올바른 순서의 체크포인트인지 확인</span>
        <span class="c-kw">if</span> (progress.currentCheckPoint + <span class="c-st">1</span> == checkPointIndex) {
            progress.currentCheckPoint = checkPointIndex;
        }
        <span class="c-cm">// 마지막 체크포인트 통과 시 랩 증가</span>
        <span class="c-kw">else if</span> (isLast) {
            progress.currentCheckPoint = <span class="c-st">0</span>;
            progress.currentLap++;
        }
    }
}</code></pre>

                <h3>SplineToCheckpointGenerator: 스플라인 기반 자동 생성</h3>
                <p>Unity Spline 시스템을 활용하여 트랙의 스플라인 곡선을 따라 체크포인트를 자동으로 생성합니다. 이를 통해 다양한 트랙에 빠르게 체크포인트 시스템을 적용할 수 있습니다.</p>

                <h3>SpawnPointManager: 다중 스폰 포인트 관리</h3>
                <p>학습 시 다양한 시작 위치에서 에피소드를 시작할 수 있도록 <span class="highlight">다중 스폰 포인트 시스템</span>을 구현했습니다. 스플라인 시작 지점을 기준으로 횡방향으로 여러 스폰 포인트를 자동 생성합니다.</p>

                <h2>3. 보상 설계 (Reward Engineering)</h2>
                <p>에이전트가 올바르게 트랙을 주행하도록 <span class="highlight">다층적 보상 시스템</span>을 설계했습니다.</p>

                <div class="visual-frame">
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin: 20px 0; align-items: stretch;">
                        <div style="padding: 18px; border: 2px solid var(--sub-accent); border-radius: 8px; background: rgba(35, 134, 54, 0.05); text-align: center;">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">목표 지향 보상</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.8;">
                                <div>• 체크포인트 통과: +1.0</div>
                                <div>• Finish 통과: +10.0</div>
                                <div>• 거리 감소 보상</div>
                                <div>• 잘못된 체크포인트: -0.5</div>
                            </div>
                        </div>
                        <div style="padding: 18px; border: 2px solid #ff7b72; border-radius: 8px; background: rgba(255, 123, 114, 0.05); text-align: center;">
                            <div style="color: #ff7b72; font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">안전성 페널티</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.8;">
                                <div>• 벽 충돌: -1.0</div>
                                <div>• 근접 페널티 (전방/후방)</div>
                                <div>• 미끄러짐 페널티</div>
                                <div>• 역주행 페널티: -0.2</div>
                            </div>
                        </div>
                    </div>
                </div>

                <h3>목표 지향 보상 (Goal-Oriented Rewards)</h3>
                <p>에이전트가 체크포인트를 순차적으로 통과하고 목표 지점에 도달하도록 설계된 보상 시스템입니다.</p>

<pre><code><span class="c-cm">// SimcadeCarAgent_Auto.cs: 목표 지향 보상 설정</span>
<span class="c-kw">[Header</span>(<span class="c-st">"Goal-Oriented Rewards (NEW)"</span>)<span class="c-kw">]</span>
<span class="c-kw">public float</span> distanceRewardFactor = <span class="c-st">0.1f</span>;        <span class="c-cm">// 다음 체크포인트에 가까워질 때 보상 계수</span>
<span class="c-kw">public float</span> checkpointReward = <span class="c-st">1.0f</span>;            <span class="c-cm">// 체크포인트 통과 시 보상</span>
<span class="c-kw">public float</span> wrongCheckpointPenalty = -<span class="c-st">0.5f</span>;    <span class="c-cm">// 잘못된 체크포인트 통과 시 페널티</span>
<span class="c-kw">public float</span> finishReward = <span class="c-st">10.0f</span>;              <span class="c-cm">// Finish 라인 통과 시 최종 보상</span>

<span class="c-cm">// 거리 기반 보상 계산</span>
<span class="c-kw">float</span> distanceReward = (lastDistanceToTarget - distanceToTarget) * distanceRewardFactor;
<span class="c-ty">AddReward</span>(distanceReward);  <span class="c-cm">// 목표에 가까워질수록 보상 증가</span></code></pre>

                <ul>
                    <li><span class="highlight">거리 기반 보상:</span> 다음 체크포인트에 가까워질수록 보상 (distanceRewardFactor: 0.1) - 매 프레임 계산</li>
                    <li><span class="highlight">체크포인트 통과:</span> 올바른 순서로 통과 시 <code style="color: var(--sub-accent);">+1.0</code>, 잘못된 순서 <code style="color: #ff7b72;">-0.5</code></li>
                    <li><span class="highlight">Finish 라인:</span> 모든 체크포인트 통과 후 Finish 통과 시 <code style="color: var(--sub-accent);">+10.0</code> (최대 보상)</li>
                    <li><span class="highlight">Finish 우회 방지:</span> 체크포인트를 다 통과하지 않고 Finish 도달 시 <code style="color: #ff7b72;">-2.5</code> (wrongCheckpointPenalty × 5)</li>
                </ul>

                <h3>생존 및 기본 보상 (Survival Rewards)</h3>
                <p>에이전트가 지속적으로 전진하고 시간 낭비를 방지하도록 설계된 보상 시스템입니다.</p>

<pre><code><span class="c-cm">// SimcadeCarAgent_Auto.cs: 생존 보상 설정</span>
<span class="c-kw">[Header</span>(<span class="c-st">"Reward Settings (Autonomous)"</span>)<span class="c-kw">]</span>
<span class="c-kw">public float</span> forwardSpeedReward = <span class="c-st">0.01f</span>;  <span class="c-cm">// 전진 속도 보상 계수</span>

<span class="c-kw">[Header</span>(<span class="c-st">"Reward Settings (Survival)"</span>)<span class="c-kw">]</span>
<span class="c-kw">public float</span> timePenalty = -<span class="c-st">0.001f</span>;  <span class="c-cm">// 시간 페널티 (매 프레임)</span>

<span class="c-cm">// 전진 속도 보상 계산</span>
<span class="c-kw">float</span> forwardSpeed = <span class="c-ty">Vector3</span>.<span class="c-fn">Dot</span>(rb.linearVelocity, transform.forward);
<span class="c-kw">if</span> (forwardSpeed > <span class="c-st">0.5f</span> && !isStuckInWall) {
    <span class="c-ty">AddReward</span>(forwardSpeedReward * (forwardSpeed / vehicleController.MaxSpeed));
}</code></pre>

                <ul>
                    <li><span class="highlight">시간 페널티:</span> 매 프레임마다 <code style="color: #ff7b72;">-0.001</code> (빠른 주행 유도)</li>
                    <li><span class="highlight">전진 속도 보상:</span> 전진 속도가 0.5 이상일 때, 최대 속도 대비 비율로 보상 (최대 <code style="color: var(--sub-accent);">+0.01</code>)</li>
                    <li><span class="highlight">정지 상태 감지:</span> 속도 0.5 미만일 때 정지 상태 체크 시작</li>
                </ul>

                <h3>안전성 및 복구 보상 (Safety & Recovery Rewards)</h3>
                <p>에이전트가 안전하게 주행하고 위험 상황을 회피하도록 설계된 페널티 및 복구 보상 시스템입니다.</p>

<pre><code><span class="c-cm">// SimcadeCarAgent_Auto.cs: 안전성 보상 설정</span>
<span class="c-kw">[Header</span>(<span class="c-st">"Safety Reward Settings"</span>)<span class="c-kw">]</span>
<span class="c-kw">public float</span> slipPenalty = -<span class="c-st">0.005f</span>;           <span class="c-cm">// 미끄러짐 페널티 계수</span>
<span class="c-kw">public float</span> slipThreshold = <span class="c-st">0.9f</span>;              <span class="c-cm">// 드리프트 허용 임계값</span>

<span class="c-kw">[Header</span>(<span class="c-st">"Proximity Penalty Settings (NEW)"</span>)<span class="c-kw">]</span>
<span class="c-kw">public float</span> proximityPenalty = -<span class="c-st">0.015f</span>;      <span class="c-cm">// 전방 벽 근접 페널티 계수</span>
<span class="c-kw">public float</span> rearProximityPenalty = -<span class="c-st">0.02f</span>;  <span class="c-cm">// 후방 벽 근접 페널티 계수</span>

<span class="c-kw">[Header</span>(<span class="c-st">"Wrong Way Driving Penalty (NEW)"</span>)<span class="c-kw">]</span>
<span class="c-kw">public float</span> wrongWayPenalty = -<span class="c-st">0.2f</span>;          <span class="c-cm">// 역주행 페널티 계수</span>
<span class="c-kw">public float</span> wrongWaySpeedThreshold = <span class="c-st">1.5f</span>;  <span class="c-cm">// 역주행 감지 최소 속도</span>
<span class="c-kw">public float</span> wrongWayDotThreshold = -<span class="c-st">0.866f</span>;  <span class="c-cm">// 역주행 감지 각도 (약 150도)</span>

<span class="c-kw">[Header</span>(<span class="c-st">"Recovery Reward Settings"</span>)<span class="c-kw">]</span>
<span class="c-kw">public float</span> wallCollisionPenalty = -<span class="c-st">1.0f</span>;      <span class="c-cm">// 벽 충돌 페널티</span>
<span class="c-kw">public float</span> stuckPenaltyPerSecond = -<span class="c-st">0.5f</span>;  <span class="c-cm">// 벽에 막힌 상태 초당 페널티</span>
<span class="c-kw">public float</span> reverseReward = <span class="c-st">0.01f</span>;            <span class="c-cm">// 벽에 막혔을 때 후진 보상</span></code></pre>

                <h4>근접 페널티 (Proximity Penalty)</h4>
                <ul>
                    <li><span class="highlight">전방 벽 감지:</span> 15m 이내 벽 감지 시 거리 기반 페널티 (최대 <code style="color: #ff7b72;">-0.015</code> per frame)</li>
                    <li><span class="highlight">후방 벽 감지:</span> 후진 중 5m 이내 벽 감지 시 거리 기반 페널티 (최대 <code style="color: #ff7b72;">-0.02</code> per frame)</li>
                    <li><span class="highlight">거리 기반 계산:</span> <code>penalty = penaltyCoefficient × (1 - distance/maxDistance)</code> - 가까울수록 페널티 급증</li>
                </ul>

                <h4>역주행 감지 (Wrong Way Detection)</h4>
                <ul>
                    <li><span class="highlight">역주행 페널티:</span> 목표 방향과 반대 방향 주행 시 <code style="color: #ff7b72;">-0.2</code> per frame</li>
                    <li><span class="highlight">감지 조건:</span> 
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            <li>전진 속도 ≥ 1.5 (wrongWaySpeedThreshold)</li>
                            <li>목표 방향과 차량 방향의 Dot Product < -0.866 (약 150도 이상 차이)</li>
                        </ul>
                    </li>
                    <li><span class="highlight">후진 처리:</span> 벽에 막혔을 때 후진은 <code style="color: var(--sub-accent);">+0.01</code> 보상, 그 외 후진은 거리 증가 시 페널티</li>
                </ul>

                <h4>미끄러짐 및 안정성 (Slip & Stability)</h4>
                <ul>
                    <li><span class="highlight">미끄러짐 페널티:</span> 평균 슬립 계수 0.9 이상 시 <code style="color: #ff7b72;">-0.005 × avgSlipCoeff</code> (드리프트 차량 특성 고려)</li>
                    <li><span class="highlight">드리프트 허용:</span> 슬립 임계값을 0.9로 설정하여 드리프트 주행 허용</li>
                </ul>

                <h4>정지 및 뒤집힘 감지 (Stagnation & Flip Detection)</h4>
                <ul>
                    <li><span class="highlight">정지 상태:</span> 
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            <li>2초 이상 정지: <code style="color: #ff7b72;">-0.02 × (duration/2)</code> (지속 시간에 비례)</li>
                            <li>5초 이상 정지: <code style="color: #ff7b72;">-5.0</code> + 에피소드 종료</li>
                        </ul>
                    </li>
                    <li><span class="highlight">뒤집힘 감지:</span> 
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            <li>160도 이상 기울어지면 감지 시작</li>
                            <li>2초 이상 지속: <code style="color: #ff7b72;">-0.05</code> per frame</li>
                            <li>5초 이상 지속: <code style="color: #ff7b72;">-3.0</code> + 에피소드 종료</li>
                        </ul>
                    </li>
                </ul>

                <h4>충돌 및 복구 (Collision & Recovery)</h4>
                <ul>
                    <li><span class="highlight">벽 충돌:</span> 벽과 충돌 시 즉시 <code style="color: #ff7b72;">-1.0</code> 페널티</li>
                    <li><span class="highlight">벽에 막힘:</span> 
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            <li>1초 이상 막힘: <code style="color: #ff7b72;">-0.5</code> per second</li>
                            <li>10초 이상 막힘: <code style="color: #ff7b72;">-5.0</code> + 에피소드 종료</li>
                        </ul>
                    </li>
                    <li><span class="highlight">맵 밖 낙하:</span> FallZone 감지 시 <code style="color: #ff7b72;">-5.0</code> + 에피소드 종료</li>
                    <li><span class="highlight">속도 부족:</span> 속도 0.1 미만일 때 <code style="color: #ff7b72;">-0.001</code> per frame</li>
                </ul>

                <h2>4. 레이캐스트 기반 환경 감지</h2>
                <p>에이전트가 주변 환경을 정확히 인식할 수 있도록 <span class="highlight">다방향 레이캐스트 시스템</span>을 구현했습니다. 전방 9개, 후방 3개의 레이를 사용하여 도로와 벽을 감지하고, 이를 신경망의 관측 데이터로 변환합니다.</p>

                <div class="visual-frame" style="margin: 30px 0;">
                    <img src="images/mlagent_1.png" alt="레이캐스트 센서 시각화" style="width: 100%; border-radius: 8px; border: 2px solid var(--border-color);">
                    <p style="text-align: center; color: #8b949e; font-size: 0.9rem; margin-top: 10px;">차량의 레이캐스트 센서 시스템 시각화 (빨간색: 감지된 대상, 초록색: 일반 센서 범위, 체크포인트 및 경로 스플라인 표시)</p>
                </div>

                <div class="visual-frame">
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin: 20px 0; align-items: stretch;">
                        <div style="padding: 18px; border: 2px solid var(--accent-color); border-radius: 8px; background: rgba(88, 166, 255, 0.05); text-align: center;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">전방 감지</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.8;">
                                <div>• 레이 개수: 9개</div>
                                <div>• 각도 범위: 180도</div>
                                <div>• 감지 거리: 15m</div>
                                <div>• 도로/벽 감지</div>
                            </div>
                        </div>
                        <div style="padding: 18px; border: 2px solid var(--sub-accent); border-radius: 8px; background: rgba(35, 134, 54, 0.05); text-align: center;">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">후방 감지</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.8;">
                                <div>• 레이 개수: 3개</div>
                                <div>• 각도 범위: 60도</div>
                                <div>• 감지 거리: 5m</div>
                                <div>• 후진 시 활성화</div>
                            </div>
                        </div>
                        <div style="padding: 18px; border: 2px solid var(--border-color); border-radius: 8px; background: rgba(0,0,0,0.2); text-align: center;">
                            <div style="color: var(--text-color); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">관측 데이터</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.8;">
                                <div>• 속도/각속도 (7)</div>
                                <div>• 레이캐스트 (21)</div>
                                <div>• 목표 방향/거리 (4)</div>
                                <div>• 총 36차원</div>
                            </div>
                        </div>
                    </div>
                </div>

                <h3>레이캐스트 설정 및 초기화</h3>
                <p>에이전트 초기화 시 전방과 후방 레이의 방향을 계산하여 저장합니다. <span class="highlight">전방 레이</span>는 180도 범위(-90도 ~ +90도)에 9개의 레이를 균등하게 배치하며, 각 레이는 <code>Quaternion.Euler</code>를 사용하여 회전된 방향 벡터로 계산됩니다. <span class="highlight">후방 레이</span>는 60도 범위(-30도 ~ +30도)에 3개의 레이를 배치하여 후진 시 벽 감지에 활용합니다. 도로 감지 레이는 전방 벽 감지 레이와 동일한 방향을 사용하여 효율성을 높였습니다.</p>
                <p>레이캐스트 설정은 다음과 같이 구성됩니다:</p>
                <ul>
                    <li><span class="highlight">도로 레이어:</span> 도로 감지용 레이어 마스크, 최대 감지 거리 50m</li>
                    <li><span class="highlight">벽 레이어:</span> 벽/장애물 감지용 레이어 마스크</li>
                    <li><span class="highlight">전방 벽 감지:</span> 최대 거리 15m (브레이크 성능 고려), 레이 개수 9개</li>
                    <li><span class="highlight">후방 벽 감지:</span> 최대 거리 5m, 레이 개수 3개</li>
                </ul>

                <h3>관측 데이터 수집 (CollectObservations)</h3>
                <p>매 프레임마다 레이캐스트를 수행하여 환경 정보를 수집하고, 정규화된 거리 값을 신경망의 관측 벡터에 추가합니다.</p>

<pre><code><span class="c-cm">// SimcadeCarAgent_Auto.cs: 관측 데이터 수집</span>
<span class="c-kw">public override void</span> <span class="c-fn">CollectObservations</span>(<span class="c-ty">VectorSensor</span> sensor)
{
    <span class="c-cm">// 기본 관측 데이터 (10차원)</span>
    sensor.<span class="c-fn">AddObservation</span>(transform.<span class="c-fn">InverseTransformDirection</span>(rb.linearVelocity));      <span class="c-cm">// 3: 선속도 (로컬 좌표)</span>
    sensor.<span class="c-fn">AddObservation</span>(transform.<span class="c-fn">InverseTransformDirection</span>(rb.angularVelocity));  <span class="c-cm">// 3: 각속도 (로컬 좌표)</span>
    <span class="c-kw">float</span> normalizedSpeed = rb.linearVelocity.magnitude / vehicleController.MaxSpeed;
    sensor.<span class="c-fn">AddObservation</span>(normalizedSpeed);  <span class="c-cm">// 1: 정규화된 속도</span>
    sensor.<span class="c-fn">AddObservation</span>(vehicleController.vehicleIsGrounded ? <span class="c-st">1f</span> : <span class="c-st">0f</span>);  <span class="c-cm">// 1: 지면 접촉 여부</span>
    sensor.<span class="c-fn">AddObservation</span>(lastSteeringInput);      <span class="c-cm">// 1: 이전 조향 입력</span>
    sensor.<span class="c-fn">AddObservation</span>(lastAccelerationInput);  <span class="c-cm">// 1: 이전 가속 입력</span>

    <span class="c-cm">// 상태 관측 (1차원)</span>
    sensor.<span class="c-fn">AddObservation</span>(isStuckInWall ? <span class="c-st">1f</span> : <span class="c-st">0f</span>);  <span class="c-cm">// 1: 벽에 막혔는지 여부</span>

    <span class="c-cm">// 레이캐스트 관측 (9 + 9 + 3 = 21차원)</span>
    <span class="c-fn">AddRaycastObservations</span>(sensor, roadRayDirections, roadLayer, roadRayDistance);        <span class="c-cm">// 9: 도로 감지</span>
    <span class="c-fn">AddRaycastObservations</span>(sensor, wallRayDirections, wallLayer, wallProximityDistance);      <span class="c-cm">// 9: 전방 벽 감지</span>
    <span class="c-fn">AddRaycastObservations</span>(sensor, rearWallRayDirections, wallLayer, rearWallProximityDistance);  <span class="c-cm">// 3: 후방 벽 감지</span>

    <span class="c-cm">// 목표 지향 관측 (4차원)</span>
    <span class="c-ty">Vector3</span> targetPosition = <span class="c-fn">GetTargetPosition</span>();  <span class="c-cm">// 다음 체크포인트 또는 Finish 위치</span>
    <span class="c-ty">Vector3</span> targetDirLocal = transform.<span class="c-fn">InverseTransformPoint</span>(targetPosition);
    sensor.<span class="c-fn">AddObservation</span>(targetDirLocal.normalized);  <span class="c-cm">// 3: 목표 방향 (로컬 좌표)</span>
    sensor.<span class="c-fn">AddObservation</span>(targetDirLocal.magnitude / roadRayDistance);  <span class="c-cm">// 1: 정규화된 목표 거리</span>

    <span class="c-cm">// 총 관측 차원: 10 + 1 + 21 + 4 = 36차원</span>
}</code></pre>

                <h3>레이캐스트 관측 헬퍼 함수</h3>
                <p>각 레이 방향에 대해 Physics.Raycast를 수행하고, 감지된 거리를 정규화하여 관측 벡터에 추가합니다.</p>

<pre><code><span class="c-cm">// SimcadeCarAgent_Auto.cs: 레이캐스트 관측 헬퍼 함수</span>
<span class="c-kw">private void</span> <span class="c-fn">AddRaycastObservations</span>(<span class="c-ty">VectorSensor</span> sensor, <span class="c-ty">Vector3</span>[] directions, <span class="c-ty">LayerMask</span> layer, <span class="c-kw">float</span> distance)
{
    <span class="c-kw">for</span> (<span class="c-kw">int</span> i = <span class="c-st">0</span>; i < directions.Length; i++) {
        <span class="c-cm">// 로컬 방향을 월드 방향으로 변환</span>
        <span class="c-ty">Vector3</span> worldRayDir = transform.<span class="c-fn">TransformDirection</span>(directions[i]);
        
        <span class="c-cm">// 레이캐스트 수행</span>
        <span class="c-kw">if</span> (<span class="c-ty">Physics</span>.<span class="c-fn">Raycast</span>(transform.position, worldRayDir, <span class="c-kw">out</span> <span class="c-ty">RaycastHit</span> hit, distance, layer)) {
            <span class="c-cm">// 감지된 경우: 거리를 정규화 (0.0 ~ 1.0, 가까울수록 작은 값)</span>
            sensor.<span class="c-fn">AddObservation</span>(hit.distance / distance);
        } <span class="c-kw">else</span> {
            <span class="c-cm">// 감지되지 않은 경우: 1.0 (최대 거리)</span>
            sensor.<span class="c-fn">AddObservation</span>(<span class="c-st">1f</span>);
        }
    }
}</code></pre>

                <h3>근접 페널티 계산 (Proximity Penalty)</h3>
                <p>벽에 가까워질수록 페널티를 부여하여 에이전트가 안전 거리를 유지하도록 유도합니다. 거리가 가까울수록 페널티가 급증하는 비선형 함수를 사용합니다.</p>

<pre><code><span class="c-cm">// SimcadeCarAgent_Auto.cs: 근접 페널티 계산</span>
<span class="c-kw">private void</span> <span class="c-fn">ApplyProximityPenalty</span>(<span class="c-ty">Vector3</span>[] directions, <span class="c-ty">LayerMask</span> layer, <span class="c-kw">float</span> distance, <span class="c-kw">float</span> penaltyCoefficient)
{
    <span class="c-kw">for</span> (<span class="c-kw">int</span> i = <span class="c-st">0</span>; i < directions.Length; i++) {
        <span class="c-ty">Vector3</span> worldRayDir = transform.<span class="c-fn">TransformDirection</span>(directions[i]);
        
        <span class="c-kw">if</span> (<span class="c-ty">Physics</span>.<span class="c-fn">Raycast</span>(transform.position, worldRayDir, <span class="c-kw">out</span> <span class="c-ty">RaycastHit</span> hit, distance, layer)) {
            <span class="c-cm">// 거리 기반 페널티 계산: 가까울수록 페널티 급증</span>
            <span class="c-cm">// penalty = penaltyCoefficient × (1 - distance/maxDistance)</span>
            <span class="c-cm">// 예: distance=0이면 penalty=penaltyCoefficient, distance=maxDistance이면 penalty=0</span>
            <span class="c-kw">float</span> penalty = penaltyCoefficient * (<span class="c-st">1f</span> - (hit.distance / distance));
            
            <span class="c-cm">// FixedUpdate 주기에 맞춰 스케일링</span>
            <span class="c-ty">AddReward</span>(penalty * <span class="c-ty">Time</span>.fixedDeltaTime);
        }
    }
}

<span class="c-cm">// CalculateRewards()에서 호출</span>
<span class="c-kw">private void</span> <span class="c-fn">CalculateRewards</span>()
{
    <span class="c-cm">// 전방 벽 근접 페널티 (항상 적용)</span>
    <span class="c-fn">ApplyProximityPenalty</span>(wallRayDirections, wallLayer, wallProximityDistance, proximityPenalty);
    <span class="c-cm">// proximityPenalty = -0.015f, wallProximityDistance = 15f</span>

    <span class="c-kw">float</span> forwardSpeed = <span class="c-ty">Vector3</span>.<span class="c-fn">Dot</span>(rb.linearVelocity, transform.forward);
    <span class="c-kw">if</span> (forwardSpeed < -<span class="c-st">0.1f</span>) {
        <span class="c-cm">// 후진 중일 때만 후방 벽 근접 페널티 적용</span>
        <span class="c-fn">ApplyProximityPenalty</span>(rearWallRayDirections, wallLayer, rearWallProximityDistance, rearProximityPenalty);
        <span class="c-cm">// rearProximityPenalty = -0.02f, rearWallProximityDistance = 5f</span>
    }
}</code></pre>

                <h3>기술적 특징</h3>
                <ul>
                    <li><span class="highlight">다방향 감지:</span> 전방 180도(9개 레이), 후방 60도(3개 레이)로 넓은 범위의 환경 인식</li>
                    <li><span class="highlight">레이어 분리:</span> 도로 레이어와 벽 레이어를 분리하여 각각 다른 용도로 활용 (도로: 50m, 벽: 15m/5m)</li>
                    <li><span class="highlight">정규화된 관측:</span> 모든 거리 값을 0.0~1.0 범위로 정규화하여 신경망 학습 안정성 향상</li>
                    <li><span class="highlight">비선형 페널티:</span> 거리 기반 비선형 페널티 함수로 가까울수록 급격한 페널티 증가</li>
                    <li><span class="highlight">조건부 후방 감지:</span> 후진 중일 때만 후방 레이캐스트 페널티 적용하여 효율성 향상</li>
                    <li><span class="highlight">전방 감지 거리 최적화:</span> 브레이크 성능을 고려하여 15m 거리에서 미리 감지하도록 설정</li>
                </ul>

                <h2>5. ML-Agents 학습 설정</h2>
                <p>Unity ML-Agents 라이브러리의 PPO(Proximal Policy Optimization) 알고리즘을 사용하여 에이전트를 학습시켰습니다. 하이퍼파라미터 튜닝과 보상 설계를 통해 안정적인 학습을 달성했습니다.</p>

                <div class="visual-frame">
                    <div class="data-table">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="border-bottom: 2px solid var(--border-color);">
                                    <th style="padding: 12px; text-align: left; color: var(--accent-color);">하이퍼파라미터</th>
                                    <th style="padding: 12px; text-align: center; color: var(--accent-color);">값</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 12px;">Trainer Type</td>
                                    <td style="padding: 12px; text-align: center;">PPO</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 12px;">Batch Size</td>
                                    <td style="padding: 12px; text-align: center;">1024</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 12px;">Buffer Size</td>
                                    <td style="padding: 12px; text-align: center;">10240</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 12px;">Learning Rate</td>
                                    <td style="padding: 12px; text-align: center;">0.0003</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 12px;">Hidden Units</td>
                                    <td style="padding: 12px; text-align: center;">256</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 12px;">Num Layers</td>
                                    <td style="padding: 12px; text-align: center;">2</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 12px;">Time Horizon</td>
                                    <td style="padding: 12px; text-align: center;">1000</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 12px;">Max Steps</td>
                                    <td style="padding: 12px; text-align: center;">10,000,000</td>
                                </tr>
                                <tr>
                                    <td style="padding: 12px;">Curiosity Signal</td>
                                    <td style="padding: 12px; text-align: center;">0.02 (활성화)</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <h2>6. 다중 트랙 학습 지원</h2>
                <p>에이전트의 일반화 성능을 향상시키기 위해 <span class="highlight">다중 트랙 학습 시스템</span>을 구현했습니다. 각 에피소드 시작 시 랜덤하게 트랙을 선택하여 학습하므로, 다양한 트랙 환경에 적응할 수 있습니다.</p>

<pre><code><span class="c-cm">// SimcadeCarAgent_Auto.cs: 다중 트랙 학습 지원</span>
<span class="c-kw">public override void</span> <span class="c-fn">OnEpisodeBegin</span>()
{
    <span class="c-cm">// 모든 트랙 중 랜덤 선택</span>
    <span class="c-kw">if</span> (allTracks == <span class="c-kw">null</span> || allTracks.Count == <span class="c-st">0</span>) {
        <span class="c-ty">Debug</span>.<span class="c-fn">LogError</span>(<span class="c-st">"학습할 트랙(AllTracks 리스트)가 설정되지 않았습니다!"</span>);
        <span class="c-kw">return</span>;
    }
    
    <span class="c-cm">// 랜덤 트랙 선택</span>
    currentTrackManager = allTracks[<span class="c-ty">Random</span>.<span class="c-fn">Range</span>(<span class="c-st">0</span>, allTracks.Count)];
    <span class="c-ty">Transform</span> spawnPoint = currentTrackManager.<span class="c-fn">GetSpawnPoint</span>();
    
    <span class="c-cm">// 선택된 트랙의 스폰 포인트로 이동</span>
    transform.position = spawnPoint.position;
    transform.rotation = spawnPoint.rotation;
    
    <span class="c-cm">// 상태 초기화</span>
    rb.linearVelocity = <span class="c-ty">Vector3</span>.zero;
    rb.angularVelocity = <span class="c-ty">Vector3</span>.zero;
    currentCheckpointIndex = <span class="c-st">0</span>;
    <span class="c-cm">// ... 기타 상태 초기화</span>
}</code></pre>

                <p><strong>기술적 특징:</strong></p>
                <ul>
                    <li><span class="highlight">랜덤 트랙 선택:</span> 각 에피소드마다 `allTracks` 리스트에서 랜덤하게 트랙 선택</li>
                    <li><span class="highlight">다양한 시작 위치:</span> 각 트랙의 `SpawnPointManager`에서 랜덤 스폰 포인트 선택</li>
                    <li><span class="highlight">일반화 성능 향상:</span> 다양한 트랙 환경에서 학습하여 단일 트랙에 과적합되지 않도록 방지</li>
                </ul>

                <h2>4.2 연속적 행동 결정 및 입력 보정</h2>
                <p>수집된 관측 정보는 신경망을 통과하여 차량을 제어하기 위한 행동 값으로 변환됩니다.</p>

                <h3>연속적 제어 (Continuous Control)</h3>
                <p>본 프로젝트의 시스템은 불연속적인 이동이 아닌, 차량의 <span class="highlight">조향과 가속/감속을 정밀하게 제어하는 연속 행동 공간</span>을 사용합니다. ML-Agents의 <code>ContinuousActions</code>를 통해 -1.0부터 1.0까지의 연속적인 실수 값을 출력하여, 차량의 핸들 각도와 가속 페달을 부드럽게 제어할 수 있습니다.</p>

                <h3>입력 스무딩 (Input Smoothing)</h3>
                <p>강화학습 초기 단계에서 발생하는 무작위적이고 급격한 지터링을 방지하기 위해, 에이전트의 행동 결정 단계에서 <span class="highlight">입력 스무딩 알고리즘</span>을 적용하였습니다. 이를 통해 직전 프레임에서 차량에 적용된 최종 제어값과 현재 신경망이 출력한 목표값의 차이를 계산하고, 보정된 현재 프레임의 최종 제어값을 차량 컨트롤러에 전달함으로써, 실제 차량과 유사한 부드러운 주행 궤적과 물리적 관성을 구현하였습니다.</p>

                <div class="visual-frame" style="margin: 30px 0;">
                    <img src="images/mlagent_3.png" alt="입력 스무딩 알고리즘 시각화" style="width: 100%; border-radius: 8px; border: 2px solid var(--border-color);">
                    <p style="text-align: center; color: #8b949e; font-size: 0.9rem; margin-top: 10px;">입력 스무딩 알고리즘 시각화: AI의 원시 판단과 이전 상태를 비교하여 부드러운 최종 명령 생성</p>
                </div>

                <div style="background: rgba(88, 166, 255, 0.1); border-left: 4px solid var(--accent-color); padding: 15px 20px; margin: 20px 0; border-radius: 6px;">
                    <p style="margin: 0 0 10px 0; color: var(--accent-color); font-weight: 700;">변수 설명:</p>
                    <ul style="margin: 0; padding-left: 20px; color: #c9d1d9;">
                        <li><code style="color: var(--accent-color);">rawSteering</code>: 신경망이 현재 상황을 보고 판단하여 설정한 차량의 조향 변수 (원시 조향값)</li>
                        <li><code style="color: var(--accent-color);">lastSteeringInput</code>: 이전 프레임의 조향값 (마지막으로 차량에 적용된 최종 조향값)</li>
                        <li><code style="color: var(--accent-color);">steeringInput</code>: 입력 스무딩 알고리즘을 통한 산출 최종 조향값 (차량의 핸들 값으로 사용)</li>
                    </ul>
                </div>

<pre><code><span class="c-cm">// SimcadeCarAgent_Auto.cs: 연속적 행동 결정 및 입력 보정</span>
<span class="c-kw">[Header</span>(<span class="c-st">"Action Smoothing"</span>)<span class="c-kw">]</span>
<span class="c-kw">public float</span> maxSteeringChange = <span class="c-st">0.5f</span>;      <span class="c-cm">// 최대 조향 변화량 (프레임당)</span>
<span class="c-kw">public float</span> maxAccelerationChange = <span class="c-st">0.7f</span>;  <span class="c-cm">// 최대 가속 변화량 (프레임당)</span>

<span class="c-kw">private float</span> lastSteeringInput = <span class="c-st">0f</span>;      <span class="c-cm">// 이전 프레임의 최종 조향값</span>
<span class="c-kw">private float</span> lastAccelerationInput = <span class="c-st">0f</span>;  <span class="c-cm">// 이전 프레임의 최종 가속값</span>

<span class="c-kw">public override void</span> <span class="c-fn">OnActionReceived</span>(<span class="c-ty">ActionBuffers</span> actions)
{
    <span class="c-cm">// 1. 신경망으로부터 연속적 행동 값 수신 (Continuous Actions)</span>
    <span class="c-kw">float</span> rawSteering = <span class="c-ty">Mathf</span>.<span class="c-fn">Clamp</span>(actions.ContinuousActions[<span class="c-st">0</span>], -<span class="c-st">1f</span>, <span class="c-st">1f</span>);
    <span class="c-kw">float</span> rawAcceleration = <span class="c-ty">Mathf</span>.<span class="c-fn">Clamp</span>(actions.ContinuousActions[<span class="c-st">1</span>], -<span class="c-st">1f</span>, <span class="c-st">1f</span>);
    <span class="c-cm">// rawSteering: 신경망이 판단한 원시 조향값 (-1.0 ~ 1.0)</span>

    <span class="c-cm">// 2. 입력 스무딩: 이전 프레임 값과 비교하여 변화량 제한</span>
    <span class="c-cm">//    직전 프레임의 최종 제어값(lastSteeringInput)과 현재 신경망 출력값(rawSteering)의 차이를 계산</span>
    <span class="c-kw">float</span> steeringInput = <span class="c-ty">Mathf</span>.<span class="c-fn">Clamp</span>(rawSteering,
        lastSteeringInput - maxSteeringChange,      <span class="c-cm">// 최소값: 이전값 - 최대변화량</span>
        lastSteeringInput + maxSteeringChange);     <span class="c-cm">// 최대값: 이전값 + 최대변화량</span>
    <span class="c-cm">// steeringInput: 보정된 현재 프레임의 최종 조향값 (차량 핸들 값으로 사용)</span>
    
    <span class="c-kw">float</span> accelerationInput = <span class="c-ty">Mathf</span>.<span class="c-fn">Clamp</span>(rawAcceleration,
        lastAccelerationInput - maxAccelerationChange,
        lastAccelerationInput + maxAccelerationChange);

    <span class="c-cm">// 3. 현재 프레임의 최종 제어값을 다음 프레임을 위해 저장</span>
    lastSteeringInput = steeringInput;        <span class="c-cm">// 다음 프레임의 기준값으로 사용</span>
    lastAccelerationInput = accelerationInput;
    
    <span class="c-cm">// 4. 보정된 최종 제어값을 차량 컨트롤러에 전달</span>
    <span class="c-cm">//    부드러운 주행 궤적과 물리적 관성을 구현</span>
    vehicleController.<span class="c-fn">ProvideInputs</span>(accelerationInput, steeringInput, <span class="c-st">0f</span>);
}</code></pre>

                <p><strong>기술적 특징:</strong></p>
                <ul>
                    <li><span class="highlight">연속 행동 공간:</span> 불연속적인 이동이 아닌 조향과 가속/감속을 정밀하게 제어하는 연속 실수 값 사용</li>
                    <li><span class="highlight">변화량 제한:</span> 조향은 최대 ±0.5, 가속은 최대 ±0.7로 프레임당 변화량 제한하여 급격한 지터링 방지</li>
                    <li><span class="highlight">부드러운 제어:</span> 이전 프레임 값과 현재 신경망 출력값의 차이를 계산하여 보정된 최종 제어값 생성</li>
                    <li><span class="highlight">물리적 관성 구현:</span> 실제 차량과 유사한 부드러운 주행 궤적과 관성 효과 구현</li>
                </ul>

                <h2>8. 기술적 특징</h2>
                <ul>
                    <li><span class="highlight">체크포인트 기반 네비게이션:</span> 순차적 체크포인트 통과를 통한 정확한 트랙 주행</li>
                    <li><span class="highlight">목표 지향 보상 설계:</span> 거리 기반 보상과 체크포인트 보상을 통한 효과적인 학습</li>
                    <li><span class="highlight">다방향 레이캐스트:</span> 전방 9개, 후방 3개 레이로 환경 정확히 인식</li>
                    <li><span class="highlight">안전성 보상:</span> 근접 페널티, 역주행 감지, 미끄러짐 감지로 안전한 주행 유도</li>
                    <li><span class="highlight">스플라인 기반 자동 생성:</span> 다양한 트랙에 빠르게 체크포인트 시스템 적용</li>
                    <li><span class="highlight">다중 트랙 학습:</span> 랜덤 트랙 선택으로 일반화 성능 향상</li>
                </ul>

                <div style="height: 100px;"></div>
            </div>
        </div>
    </div>

    <!-- WorldFirstKill Modal -->
    <div id="modal-overlay-wfk" class="modal-overlay" onclick="closeModal('wfk')">
        <div class="modal-container" onclick="event.stopPropagation()">
            <div class="modal-body">
                <div class="modal-header-nav">
                    <div class="mono" style="color: var(--accent-color);">PROJECT REPORT // WORLDFIRSTKILL</div>
                    <button onclick="closeModal('wfk')" style="background: none; border: 1px solid var(--accent-color); color: var(--accent-color); padding: 8px 20px; border-radius: 6px; cursor: pointer; font-family: 'Fira Code'; font-size: 0.8rem;">[X] DISCONNECT</button>
                </div>
                
                <h1 style="font-size: 2.5rem; margin-bottom: 30px; color: #f0f6fc;">WorldFirstKill: 데이터 저장 및 파싱 시스템</h1>

                <div class="tab-container">
                    <button class="tab-button active" onclick="switchTabWFK('csv')">CSV 서버 다운로드 및 파싱</button>
                    <button class="tab-button" onclick="switchTabWFK('save')">Seed/Token 세이브 로드</button>
                    <button class="tab-button" onclick="switchTabWFK('loading')">비동기 로딩 시스템</button>
                </div>

                <div id="wfk-csv-tab" class="tab-content active">
                <h2>1. 프로젝트 개요</h2>
                <p>WorldFirstKill 게임에서 <span class="highlight">데이터 저장, 파싱, 불러오기 로직</span>을 담당했습니다. 
                <span class="highlight">리플렉션 기반 CSV 파싱 시스템</span>과 <span class="highlight">서버 CSV 다운로드 및 버전 관리</span>를 통해 
                게임 데이터를 효율적으로 관리하고, <span class="highlight">JSON 기반 저장/불러오기 시스템</span>으로 게임 상태를 안전하게 저장합니다.</p>

                <h2>2. 리플렉션 기반 CSV 파싱 시스템</h2>
                <p>CSV 파일의 헤더와 데이터 클래스의 필드를 자동으로 매핑하여 동적으로 파싱하는 시스템을 구현했습니다. 
                <span class="highlight">리플렉션(Reflection)</span>을 활용하여 타입 안전성을 보장하면서도 확장 가능한 파싱 로직을 설계했습니다.</p>

                <h3>2.1 파싱 과정 개요</h3>
                <p>CSV 파싱은 다음과 같은 단계로 진행됩니다:</p>
                <ol>
                    <li><span class="highlight">타입 정보 수집:</span> 리플렉션을 사용하여 제네릭 타입 T의 모든 필드 정보 추출</li>
                    <li><span class="highlight">헤더 매핑:</span> CSV 첫 번째 줄(헤더)과 클래스 필드명을 자동으로 매핑</li>
                    <li><span class="highlight">데이터 행 파싱:</span> 각 데이터 행을 스마트 분할하여 컬럼 단위로 분리</li>
                    <li><span class="highlight">타입 변환 및 할당:</span> 문자열 데이터를 필드 타입에 맞게 변환하여 객체에 할당</li>
                </ol>

                <h3>2.2 핵심 파싱 로직</h3>
                <p>제네릭 메서드를 사용하여 타입에 독립적인 파싱을 수행합니다.</p>

<pre><code><span class="c-cm">// CSVParser.cs: 리플렉션 기반 CSV 파싱</span>
<span class="c-kw">public</span> <span class="c-ty">List</span>&lt;<span class="c-ty">T</span>&gt; <span class="c-fn">parseCSV</span>&lt;<span class="c-ty">T</span>&gt;(<span class="c-kw">string</span> csvData) <span class="c-kw">where T</span> : <span class="c-ty">BaseData</span>, <span class="c-kw">new</span>()
{
    <span class="c-ty">List</span>&lt;<span class="c-ty">T</span>&gt; csvDataList = <span class="c-kw">new</span> <span class="c-ty">List</span>&lt;<span class="c-ty">T</span>&gt;();

    <span class="c-cm">// 1. 리플렉션으로 타입의 모든 필드 정보 가져오기</span>
    <span class="c-ty">Type</span> myType = <span class="c-kw">typeof</span>(<span class="c-ty">T</span>);
    <span class="c-ty">FieldInfo</span>[] myFieldInfo = myType.<span class="c-fn">GetFields</span>(<span class="c-ty">BindingFlags</span>.NonPublic | <span class="c-ty">BindingFlags</span>.Instance | <span class="c-ty">BindingFlags</span>.Public);

    <span class="c-cm">// 2. CSV 데이터를 줄 단위로 분리 (첫 줄은 헤더)</span>
    <span class="c-kw">string</span>[] csvLines = csvData.<span class="c-fn">Split</span>(<span class="c-st">'\n'</span>).<span class="c-fn">Where</span>(x => !<span class="c-ty">string</span>.<span class="c-fn">IsNullOrWhiteSpace</span>(x)).<span class="c-fn">ToArray</span>();
    <span class="c-kw">string</span>[] headers = csvLines[<span class="c-st">0</span>].<span class="c-fn">Trim</span>().<span class="c-fn">Split</span>(<span class="c-st">','</span>);

    <span class="c-cm">// 3. CSV 헤더와 클래스 필드를 매핑 (DataIndex_Dict, Data_Dict 생성)</span>
    <span class="c-fn">SetupFieldDict</span>(headers, myFieldInfo);

    <span class="c-cm">// 4. 각 데이터 행 파싱</span>
    <span class="c-kw">for</span> (<span class="c-kw">int</span> rowIndex = <span class="c-st">1</span>; rowIndex < csvLines.Length; rowIndex++) {
        <span class="c-kw">string</span>[] columns = <span class="c-fn">SmartSplit</span>(csvLines[rowIndex]);  <span class="c-cm">// 쉼표와 따옴표 처리</span>
        <span class="c-ty">T</span> objectData = <span class="c-ty">Activator</span>.<span class="c-fn">CreateInstance</span>&lt;<span class="c-ty">T</span>&gt;();

        <span class="c-cm">// 5. 각 컬럼 데이터를 해당 필드에 할당</span>
        <span class="c-kw">for</span> (<span class="c-kw">int</span> i = <span class="c-st">0</span>; i < columns.Length; i++) {
            <span class="c-kw">if</span> (DataIndex_Dict.<span class="c-fn">TryGetValue</span>(i, <span class="c-kw">out</span> <span class="c-kw">string</span> attribute) &&
                Data_Dict.<span class="c-fn">TryGetValue</span>(attribute, <span class="c-kw">out</span> <span class="c-kw">string</span> fieldName)) {
                <span class="c-ty">FieldInfo</span> fieldInfo = myType.<span class="c-fn">GetField</span>(fieldName);
                <span class="c-fn">SetFieldValue</span>(objectData, fieldInfo, columns[i]);  <span class="c-cm">// 타입 변환 및 할당</span>
            }
        }
        csvDataList.<span class="c-fn">Add</span>(objectData);
    }
    <span class="c-kw">return</span> csvDataList;
}</code></pre>

                <h3>2.3 스마트 분할 (SmartSplit)</h3>
                <p>일반적인 <code>Split(',')</code>는 쉼표가 포함된 문자열이나 따옴표로 감싼 필드를 제대로 처리하지 못합니다. 
                정규식을 사용하여 CSV 표준에 맞게 파싱합니다.</p>

<pre><code><span class="c-cm">// 쉼표와 따옴표를 고려한 스마트 분할</span>
<span class="c-kw">string</span>[] <span class="c-fn">SmartSplit</span>(<span class="c-kw">string</span> line)
{
    <span class="c-cm">// 정규식: 따옴표로 감싼 값 또는 일반 값을 매칭</span>
    <span class="c-kw">return</span> <span class="c-ty">Regex</span>.<span class="c-fn">Matches</span>(line, <span class="c-st">@"(?:^|,)(?:""(?<val>[^""]*)""|(?<val>[^,""]*))"</span>)
                .<span class="c-fn">Cast</span>&lt;<span class="c-ty">Match</span>&gt;()
                .<span class="c-fn">Select</span>(m => m.Groups[<span class="c-st">"val"</span>].Value)
                .<span class="c-fn">ToArray</span>();
}
<span class="c-cm">// 예시: "이름,설명",100,200 → ["이름,설명", "100", "200"]</span></code></pre>

                <h3>2.4 타입 자동 변환</h3>
                <p>필드 타입에 따라 문자열 데이터를 자동으로 변환합니다.</p>

<pre><code><span class="c-cm">// 필드 타입에 따라 자동 변환</span>
<span class="c-kw">protected virtual void</span> <span class="c-fn">SetFieldValue</span>(<span class="c-ty">BaseData</span> instance, <span class="c-ty">FieldInfo</span> fieldInfo, <span class="c-kw">string</span> value)
{
    <span class="c-kw">if</span> (fieldInfo.FieldType == <span class="c-kw">typeof</span>(<span class="c-kw">string</span>))
        fieldInfo.<span class="c-fn">SetValue</span>(instance, value);
    <span class="c-kw">else if</span> (fieldInfo.FieldType == <span class="c-kw">typeof</span>(<span class="c-kw">int</span>) && <span class="c-kw">int</span>.<span class="c-fn">TryParse</span>(value, <span class="c-kw">out</span> <span class="c-kw">int</span> intVal))
        fieldInfo.<span class="c-fn">SetValue</span>(instance, intVal);
    <span class="c-kw">else if</span> (fieldInfo.FieldType == <span class="c-kw">typeof</span>(<span class="c-kw">float</span>) && <span class="c-kw">float</span>.<span class="c-fn">TryParse</span>(value, <span class="c-kw">out</span> <span class="c-kw">float</span> floatVal))
        fieldInfo.<span class="c-fn">SetValue</span>(instance, floatVal);
}</code></pre>

                <h3>2.5 기술적 특징</h3>
                <ul>
                    <li><span class="highlight">리플렉션 기반 동적 매핑:</span> CSV 헤더와 클래스 필드를 자동으로 매핑하여 수동 매핑 코드 불필요</li>
                    <li><span class="highlight">스마트 분할:</span> 정규식을 사용하여 쉼표와 따옴표를 포함한 CSV 데이터를 정확히 파싱</li>
                    <li><span class="highlight">타입 안전성:</span> 제네릭과 리플렉션을 활용하여 컴파일 타임 타입 체크 보장</li>
                    <li><span class="highlight">확장성:</span> 새로운 데이터 타입 추가 시 BaseData만 상속하면 자동으로 파싱 지원</li>
                </ul>

                <h2>3. 서버 CSV 다운로드 및 버전 관리 시스템</h2>
                <p>구글 스프레드시트에서 CSV 데이터를 다운로드하고, 버전을 관리하여 변경된 데이터만 업데이트하는 시스템을 구현했습니다. 
                <span class="highlight">버전 비교</span>를 통해 불필요한 다운로드를 방지하고, <span class="highlight">로컬 캐싱</span>으로 오프라인 사용을 지원합니다.</p>

                <h3>3.1 다운로드 프로세스</h3>
                <p>다운로드 프로세스는 다음과 같이 진행됩니다:</p>
                <ol>
                    <li><span class="highlight">메타 시트 다운로드:</span> 서버의 버전 정보가 담긴 메타 시트를 먼저 다운로드</li>
                    <li><span class="highlight">버전 비교:</span> 각 CSV 파일의 서버 버전과 로컬 버전을 비교</li>
                    <li><span class="highlight">조건부 다운로드:</span> 버전이 다르거나 로컬 파일이 없을 때만 서버에서 다운로드</li>
                    <li><span class="highlight">로컬 캐싱:</span> 다운로드한 파일을 로컬에 저장하고 버전 정보 업데이트</li>
                    <li><span class="highlight">진행률 보고:</span> 각 파일 다운로드 완료 시 진행률 콜백 호출</li>
                </ol>

                <h3>3.2 버전 관리 시스템</h3>
                <p>각 CSV 파일은 고유한 버전 번호를 가지며, 서버의 메타 시트에서 버전 정보를 가져옵니다. 
                로컬에 저장된 버전 정보와 비교하여 변경된 파일만 다운로드합니다.</p>
                <div style="background: rgba(56, 139, 253, 0.1); border-left: 4px solid #388bfd; padding: 15px 20px; margin: 20px 0; border-radius: 6px;">
                    <div style="margin-bottom: 10px;"><strong>버전 비교 로직:</strong></div>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li>로컬 버전 == 서버 버전 → 로컬 파일 사용 (다운로드 스킵)</li>
                        <li>로컬 버전 != 서버 버전 → 서버에서 다운로드</li>
                        <li>로컬 파일 없음 → 서버에서 다운로드</li>
                    </ul>
                </div>

                <h3>3.3 핵심 다운로드 로직</h3>
                <p>비동기 다운로드를 통해 UI 블로킹 없이 데이터를 가져옵니다.</p>

<pre><code><span class="c-cm">// ServerCSV_ConvertData.cs: 서버 CSV 다운로드 및 버전 관리</span>
<span class="c-kw">public static async</span> <span class="c-ty">Task</span>&lt;<span class="c-kw">bool</span>&gt; <span class="c-fn">DownloadAllCSVAsync</span>(<span class="c-ty">Action</span>&lt;<span class="c-kw">float</span>&gt; progressCallback = <span class="c-kw">null</span>)
{
    <span class="c-fn">LoadLocalVersions</span>();  <span class="c-cm">// 로컬 버전 정보 로드</span>

    <span class="c-kw">foreach</span> (<span class="c-kw">var</span> kvp <span class="c-kw">in</span> csvURLDict) {
        <span class="c-ty">CSVDataType</span> dataType = kvp.Key;
        <span class="c-kw">var</span> attrUrlDict = kvp.Value;

        <span class="c-kw">foreach</span> (<span class="c-kw">var</span> attrKvp <span class="c-kw">in</span> attrUrlDict) {
            <span class="c-kw">string</span> attribute = attrKvp.Key;
            <span class="c-kw">string</span> url = attrKvp.Value;

            <span class="c-cm">// 1. 서버 버전과 로컬 버전 비교</span>
            <span class="c-kw">string</span> serverVersion = _serverVersions.<span class="c-fn">TryGetValue</span>(dataType, <span class="c-kw">out</span> <span class="c-kw">var</span> sAttrVerDict) 
                && sAttrVerDict.<span class="c-fn">TryGetValue</span>(attribute, <span class="c-kw">out</span> <span class="c-kw">var</span> sVer) ? sVer : <span class="c-st">"0"</span>;
            <span class="c-kw">string</span> localVersion = _localVersions.<span class="c-fn">TryGetValue</span>(dataType, <span class="c-kw">out</span> <span class="c-kw">var</span> lAttrVerDict) 
                && lAttrVerDict.<span class="c-fn">TryGetValue</span>(attribute, <span class="c-kw">out</span> <span class="c-kw">var</span> lVer) ? lVer : <span class="c-st">"0"</span>;

            <span class="c-kw">string</span> fileName = $<span class="c-st">"{dataType}_{attribute}.csv"</span>;
            <span class="c-kw">string</span> localFilePath = <span class="c-ty">Path</span>.<span class="c-fn">Combine</span>(LocalDataPath, fileName);
            <span class="c-kw">string</span> fileContent = <span class="c-kw">null</span>;

            <span class="c-cm">// 2. 버전이 같으면 로컬 파일 사용, 다르면 서버에서 다운로드</span>
            <span class="c-kw">if</span> (<span class="c-ty">File</span>.<span class="c-fn">Exists</span>(localFilePath) && localVersion == serverVersion) {
                fileContent = <span class="c-ty">File</span>.<span class="c-fn">ReadAllText</span>(localFilePath);  <span class="c-cm">// 로컬 캐시 사용</span>
            } <span class="c-kw">else</span> {
                <span class="c-cm">// 3. 서버에서 비동기 다운로드</span>
                fileContent = <span class="c-kw">await</span> <span class="c-fn">DownloadFileAsync</span>(url);
                <span class="c-kw">if</span> (fileContent != <span class="c-kw">null</span>) {
                    <span class="c-ty">File</span>.<span class="c-fn">WriteAllText</span>(localFilePath, fileContent);  <span class="c-cm">// 로컬에 저장</span>
                    <span class="c-cm">// 4. 로컬 버전 정보 업데이트</span>
                    <span class="c-kw">if</span> (!_localVersions.<span class="c-fn">ContainsKey</span>(dataType)) 
                        _localVersions[dataType] = <span class="c-kw">new</span> <span class="c-ty">Dictionary</span>&lt;<span class="c-kw">string</span>, <span class="c-kw">string</span>&gt;();
                    _localVersions[dataType][attribute] = serverVersion;
                }
            }

            csvDataDict.<span class="c-fn">Add</span>(attribute, fileContent);
            progressCallback?.<span class="c-fn">Invoke</span>((<span class="c-kw">float</span>)currentCount / totalCount);  <span class="c-cm">// 진행률 콜백</span>
        }
    }

    <span class="c-fn">SaveLocalVersions</span>();  <span class="c-cm">// 업데이트된 버전 정보 저장</span>
    <span class="c-kw">return true</span>;
}</code></pre>

                <h3>3.4 비동기 다운로드 구현</h3>
                <p>UnityWebRequest를 사용하여 비동기로 파일을 다운로드합니다.</p>

<pre><code><span class="c-cm">// UnityWebRequest를 사용한 비동기 다운로드</span>
<span class="c-kw">private static async</span> <span class="c-ty">Task</span>&lt;<span class="c-kw">string</span>&gt; <span class="c-fn">DownloadFileAsync</span>(<span class="c-kw">string</span> url)
{
    <span class="c-kw">using</span> (<span class="c-ty">UnityWebRequest</span> request = <span class="c-ty">UnityWebRequest</span>.<span class="c-fn">Get</span>(url)) {
        <span class="c-kw">await</span> request.<span class="c-fn">SendWebRequest</span>();
        
        <span class="c-kw">if</span> (request.result == <span class="c-ty">UnityWebRequest</span>.<span class="c-ty">Result</span>.Success) {
            <span class="c-kw">return</span> request.downloadHandler.text;
        } <span class="c-kw">else</span> {
            <span class="c-ty">Debug</span>.<span class="c-fn">LogError</span>($<span class="c-st">"다운로드 실패: {url}, 에러: {request.error}"</span>);
    <span class="c-kw">return null</span>;
        }
    }
}</code></pre>

                <h3>3.5 기술적 특징</h3>
                <ul>
                    <li><span class="highlight">버전 기반 업데이트:</span> 서버 버전과 로컬 버전을 비교하여 변경된 데이터만 다운로드</li>
                    <li><span class="highlight">비동기 다운로드:</span> UnityWebRequest를 사용한 비동기 CSV 다운로드로 UI 블로킹 방지</li>
                    <li><span class="highlight">로컬 캐싱:</span> 다운로드한 CSV 파일을 로컬에 저장하여 오프라인 사용 가능</li>
                    <li><span class="highlight">진행률 콜백:</span> 다운로드 진행률을 실시간으로 전달하여 UI 업데이트</li>
                    <li><span class="highlight">에러 처리:</span> 다운로드 실패 시 null 반환하여 안전하게 처리</li>
                </ul>

                <h2>3. Factory Pattern을 활용한 데이터 기반 객체 생성</h2>
                <p>파싱된 데이터를 기반으로 게임 객체를 생성하는 Factory Pattern을 구현했습니다. 데이터 타입에 따라 적절한 객체를 생성합니다.</p>

<pre><code><span class="c-cm">// DataFactory.cs: 데이터 기반 객체 생성</span>
<span class="c-kw">public static</span> <span class="c-ty">Unit_Monster</span> <span class="c-fn">MakeMonster</span>(<span class="c-ty">Define</span>.<span class="c-ty">MonsterType</span> monsterType, <span class="c-kw">int</span> grade, <span class="c-ty">GameObject</span> prefab)
{
    <span class="c-cm">// 몬스터 데이터 찾기</span>
    <span class="c-ty">Data_Monster</span> data = Managers.Data.MonsterData.Values.<span class="c-fn">ToList</span>()
        .<span class="c-fn">Find</span>(value => value.m_monsterIndex == (<span class="c-kw">int</span>)monsterType + grade - <span class="c-st">1</span>);

    <span class="c-kw">if</span> (data == <span class="c-kw">null</span>) {
        <span class="c-ty">Debug</span>.<span class="c-fn">LogError</span>($<span class="c-st">"몬스터 데이터를 찾을 수 없습니다: Type={monsterType}, Grade={grade}"</span>);
    <span class="c-kw">return null</span>;
    }

    <span class="c-cm">// 몬스터 인스턴스 생성</span>
    <span class="c-ty">GameObject</span> monsterObj = <span class="c-ty">GameObject</span>.<span class="c-fn">Instantiate</span>(prefab);
    <span class="c-ty">Unit_Monster</span> monster = monsterObj.<span class="c-fn">GetComponent</span>&lt;<span class="c-ty">Unit_Monster</span>&gt;();

    <span class="c-cm">// 드롭 아이템 생성</span>
    <span class="c-ty">Dictionary</span>&lt;<span class="c-ty">Item</span>, <span class="c-kw">int</span>&gt; dropItems = <span class="c-fn">CreateDropItems</span>(grade, data);

    <span class="c-cm">// 몬스터 스탯 계산</span>
    <span class="c-ty">UnitStat</span> monsterStat = <span class="c-fn">CalculateMonsterStat</span>(data, grade, dropItems);

    <span class="c-cm">// 몬스터 데이터 적용</span>
    <span class="c-fn">ApplyMonsterData</span>(monster, data, monsterStat, dropItems, grade);

    <span class="c-kw">return</span> monster;
}</code></pre>

                <h3>기술적 특징</h3>
                <ul>
                    <li><span class="highlight">데이터 기반 생성:</span> CSV에서 파싱된 데이터를 기반으로 게임 객체 생성</li>
                    <li><span class="highlight">타입별 Factory:</span> 몬스터, 장비, 아이템 등 타입별로 전용 Factory 메서드 제공</li>
                    <li><span class="highlight">확장성:</span> 새로운 데이터 타입 추가 시 Factory 메서드만 추가하면 됨</li>
                </ul>

                <h2>4. 기술적 특징</h2>
                <ul>
                    <li><span class="highlight">리플렉션 기반 동적 파싱:</span> 수동 매핑 코드 없이 CSV 헤더와 클래스 필드 자동 매핑</li>
                    <li><span class="highlight">버전 관리 시스템:</span> 서버와 로컬 버전 비교를 통한 효율적인 데이터 업데이트</li>
                    <li><span class="highlight">비동기 다운로드:</span> UnityWebRequest를 활용한 비동기 CSV 다운로드로 UI 반응성 유지</li>
                    <li><span class="highlight">Factory Pattern:</span> 데이터 기반 객체 생성으로 확장 가능한 아키텍처 구축</li>
                    <li><span class="highlight">타입 안전성:</span> 제네릭과 리플렉션을 활용한 컴파일 타임 타입 체크</li>
                </ul>
                </div>

                <div id="wfk-save-tab" class="tab-content">
                <h2>1. JSON 기반 저장/불러오기 시스템</h2>
                <p>게임 상태를 JSON 형식으로 저장하고 불러오는 시스템을 구현했습니다. Unity의 JsonUtility를 활용하여 직렬화/역직렬화를 수행합니다.</p>

<pre><code><span class="c-cm">// DataManager.cs: JSON 기반 저장/불러오기</span>
<span class="c-kw">public void</span> <span class="c-fn">SaveData</span>()
{
    <span class="c-ty">PlayerData</span> saveData = <span class="c-kw">new</span> <span class="c-ty">PlayerData</span>();

    <span class="c-kw">if</span> (Managers.nowPlayerData == <span class="c-kw">null</span>) <span class="c-kw">return</span>;

    saveData = Managers.nowPlayerData;

    <span class="c-cm">// JSON 직렬화</span>
    <span class="c-kw">string</span> data = <span class="c-ty">JsonUtility</span>.<span class="c-fn">ToJson</span>(saveData);
    <span class="c-ty">File</span>.<span class="c-fn">WriteAllText</span>(FilePath + DataNum, data);
}

<span class="c-kw">public void</span> <span class="c-fn">LoadData</span>()
{
    <span class="c-kw">if</span> (!<span class="c-ty">File</span>.<span class="c-fn">Exists</span>(FilePath + DataNum)) <span class="c-kw">return</span>;

    <span class="c-kw">string</span> data = <span class="c-ty">File</span>.<span class="c-fn">ReadAllText</span>(FilePath);

    <span class="c-cm">// JSON 역직렬화</span>
    <span class="c-ty">PlayerData</span> LoadData = <span class="c-ty">JsonUtility</span>.<span class="c-fn">FromJson</span>&lt;<span class="c-ty">PlayerData</span>&gt;(data);

    Managers.nowPlayerData = LoadData;

    <span class="c-cm">// 설정 데이터 복원</span>
    Managers.Sound.BGMSoundVolume = Managers.nowPlayerData.BGMSound;
    Managers.Sound.SFXSoundVolume = Managers.nowPlayerData.SFXSound;
}</code></pre>

                <h2>2. Seed/Token 시스템</h2>
                <p>게임의 랜덤 시드(RNG) 상태를 문자열 토큰으로 인코딩하여 저장하고 복원하는 시스템을 구현했습니다. 
                단순히 초기 시드만 저장하는 것이 아니라, <span class="highlight">각 Domain별로 사용된 랜덤 값의 개수</span>를 추적하여 
                게임의 RNG 상태를 <span class="highlight">완전히 복원</span>할 수 있습니다.</p>

                <h3>2.1 시스템 개요</h3>
                <p>게임에서 랜덤 값이 사용되는 영역(Domain)은 여러 개입니다. 예를 들어, 몬스터 드롭 아이템, 장비 옵션, 던전 생성 등 
                각각 독립적인 RNG 스트림을 사용합니다. 단순히 초기 시드만 저장하면, 세이브 파일을 불러왔을 때 
                <span class="highlight">이미 사용된 랜덤 값들이 다시 생성</span>되어 게임 밸런스가 깨질 수 있습니다.</p>
                
                <p>Seed/Token 시스템은 다음과 같이 동작합니다:</p>
                <ul>
                    <li><span class="highlight">BaseSeed 저장:</span> 게임 시작 시 설정된 초기 시드 값</li>
                    <li><span class="highlight">Domain별 사용량 추적:</span> 각 Domain에서 생성된 랜덤 값의 개수를 카운트</li>
                    <li><span class="highlight">고정 폭 인코딩:</span> 토큰을 고정 길이 문자열로 인코딩하여 파싱 안정성 확보</li>
                    <li><span class="highlight">완전한 상태 복원:</span> BaseSeed와 각 Domain의 사용량을 복원하여 정확한 RNG 상태 재현</li>
                </ul>

                <h3>2.2 토큰 구조</h3>
                <p>토큰은 다음과 같은 구조로 구성됩니다:</p>
                <div style="background: rgba(56, 139, 253, 0.1); border-left: 4px solid #388bfd; padding: 15px 20px; margin: 20px 0; border-radius: 6px; font-family: 'Fira Code', monospace; font-size: 0.9rem;">
                    <div style="margin-bottom: 10px;"><strong>토큰 구조:</strong></div>
                    <div style="margin-left: 20px;">
                        <div>[BaseSeed: 10자리] + [Domain 개수: 3자리] + [Domain1 ID: 3자리] + [Domain1 Usage: 12자리] + [Domain2 ID: 3자리] + [Domain2 Usage: 12자리] + ...</div>
                    </div>
                    <div style="margin-top: 15px; font-size: 0.85rem; color: #8b949e;">
                        예시: <code>0000000123</code> (BaseSeed) + <code>003</code> (3개 Domain) + <code>001</code> (Domain 1) + <code>000000000042</code> (42번 사용) + ...
                    </div>
                </div>

                <h3>2.3 토큰 생성 (BuildSeedToken)</h3>
                <p>현재 게임의 RNG 상태를 문자열 토큰으로 변환합니다. BaseSeed와 각 Domain별 사용량을 고정 폭으로 인코딩하여 
                일관된 토큰 형식을 보장합니다.</p>

<pre><code><span class="c-cm">// SaveLoadManager.cs: Seed Token 생성</span>
<span class="c-kw">public static string</span> <span class="c-fn">BuildSeedToken</span>()
{
    <span class="c-kw">int</span> baseSeed = <span class="c-ty">GameSeed</span>.BaseSeed;  <span class="c-cm">// 초기 시드 값</span>
    <span class="c-ty">Dictionary</span>&lt;<span class="c-ty">GameSeed</span>.<span class="c-ty">Domain</span>, <span class="c-kw">ulong</span>&gt; usage = <span class="c-ty">GameSeed</span>.<span class="c-fn">GetUsageSnapshot</span>();  <span class="c-cm">// Domain별 사용량 스냅샷</span>

    <span class="c-cm">// BaseSeed를 10자리 고정 폭으로 인코딩</span>
    <span class="c-kw">string</span> token = <span class="c-fn">Pad</span>(<span class="c-fn">EncodeIntToUInt</span>(baseSeed), BASE_SEED_WIDTH);

    <span class="c-cm">// Domain 목록을 정렬하여 일관된 토큰 생성</span>
    <span class="c-ty">List</span>&lt;<span class="c-ty">GameSeed</span>.<span class="c-ty">Domain</span>&gt; domains = <span class="c-kw">new</span> <span class="c-ty">List</span>&lt;<span class="c-ty">GameSeed</span>.<span class="c-ty">Domain</span>&gt;((<span class="c-ty">GameSeed</span>.<span class="c-ty">Domain</span>[])<span class="c-ty">Enum</span>.<span class="c-fn">GetValues</span>(<span class="c-kw">typeof</span>(<span class="c-ty">GameSeed</span>.<span class="c-ty">Domain</span>)));
    domains.<span class="c-fn">Sort</span>((a, b) => (a).<span class="c-fn">CompareTo</span>(b));

    <span class="c-cm">// Domain 개수 추가 (3자리)</span>
    token += <span class="c-fn">Pad</span>((<span class="c-kw">uint</span>)domains.Count, COUNT_WIDTH);
    
    <span class="c-cm">// 각 Domain의 ID와 사용량을 토큰에 추가</span>
    <span class="c-kw">foreach</span> (<span class="c-kw">var</span> d <span class="c-kw">in</span> domains) {
        <span class="c-kw">ulong</span> count = usage.<span class="c-fn">GetValueOrDefault</span>(d, <span class="c-st">0UL</span>);
        token += <span class="c-fn">Pad</span>((<span class="c-kw">uint</span>)d, DOMAIN_ID_WIDTH);      <span class="c-cm">// Domain ID (3자리)</span>
        token += <span class="c-fn">Pad</span>(count, USAGE_WIDTH);                    <span class="c-cm">// 사용량 (12자리)</span>
    }

    <span class="c-kw">return</span> token;
}</code></pre>

                <h3>2.4 토큰 복원 (RestoreSeedToken)</h3>
                <p>저장된 토큰을 파싱하여 게임의 RNG 상태를 완전히 복원합니다. 고정 폭 인코딩을 활용하여 
                토큰의 각 부분을 정확히 추출하고, BaseSeed와 Domain별 사용량을 복원합니다.</p>

<pre><code><span class="c-cm">// SaveLoadManager.cs: Seed Token 복원</span>
<span class="c-kw">public static bool</span> <span class="c-fn">RestoreSeedToken</span>(<span class="c-kw">string</span> token)
{
    <span class="c-kw">try</span> {
        <span class="c-kw">int</span> idx = <span class="c-st">0</span>;  <span class="c-cm">// 토큰 읽기 위치 인덱스</span>

        <span class="c-cm">// BaseSeed 디코딩 (10자리)</span>
        <span class="c-kw">ulong</span> baseSeedEncoded = <span class="c-fn">ReadUInt</span>(token, <span class="c-kw">ref</span> idx, BASE_SEED_WIDTH);
        <span class="c-kw">int</span> baseSeed = <span class="c-fn">DecodeUlongToInt</span>(baseSeedEncoded);

        <span class="c-cm">// Domain 개수 읽기 (3자리)</span>
        <span class="c-kw">uint</span> count = (<span class="c-kw">uint</span>)<span class="c-fn">ReadUInt</span>(token, <span class="c-kw">ref</span> idx, COUNT_WIDTH);
        
        <span class="c-ty">Dictionary</span>&lt;<span class="c-ty">GameSeed</span>.<span class="c-ty">Domain</span>, <span class="c-kw">ulong</span>&gt; usage = <span class="c-kw">new</span> <span class="c-ty">Dictionary</span>&lt;<span class="c-ty">GameSeed</span>.<span class="c-ty">Domain</span>, <span class="c-kw">ulong</span>&gt;();
        
        <span class="c-cm">// 각 Domain의 ID와 사용량 복원</span>
        <span class="c-kw">for</span> (<span class="c-kw">int</span> i = <span class="c-st">0</span>; i < count; i++) {
            <span class="c-kw">uint</span> domIdU = (<span class="c-kw">uint</span>)<span class="c-fn">ReadUInt</span>(token, <span class="c-kw">ref</span> idx, DOMAIN_ID_WIDTH);  <span class="c-cm">// Domain ID (3자리)</span>
            <span class="c-kw">ulong</span> u = <span class="c-fn">ReadUInt</span>(token, <span class="c-kw">ref</span> idx, USAGE_WIDTH);              <span class="c-cm">// 사용량 (12자리)</span>
            
            <span class="c-kw">if</span> (<span class="c-ty">Enum</span>.<span class="c-fn">IsDefined</span>(<span class="c-kw">typeof</span>(<span class="c-ty">GameSeed</span>.<span class="c-ty">Domain</span>), domIdU)) {
                usage[(<span class="c-ty">GameSeed</span>.<span class="c-ty">Domain</span>)domIdU] = u;
            }
        }

        <span class="c-cm">// GameSeed 시스템에 상태 복원</span>
        <span class="c-ty">GameSeed</span>.<span class="c-fn">RestoreFromSnapshot</span>(baseSeed, usage);
        <span class="c-kw">return true</span>;
    }
    <span class="c-kw">catch</span> {
        <span class="c-kw">return false</span>;  <span class="c-cm">// 토큰 파싱 실패 시 false 반환</span>
    }
}</code></pre>

                <h3>2.5 고정 폭 인코딩의 장점</h3>
                <p>고정 폭 인코딩을 사용하는 이유는 다음과 같습니다:</p>
                <ul>
                    <li><span class="highlight">파싱 안정성:</span> 각 필드의 위치가 고정되어 있어 파싱 오류 가능성 최소화</li>
                    <li><span class="highlight">검증 용이성:</span> 토큰 길이를 계산하여 유효성 검증 가능</li>
                    <li><span class="highlight">인덱스 기반 접근:</span> 구분자 없이 인덱스만으로 각 필드 추출 가능</li>
                </ul>

                <h3>2.6 기술적 특징</h3>
                <ul>
                    <li><span class="highlight">고정 폭 인코딩:</span> BaseSeed(10자리), Domain ID(3자리), Usage(12자리)로 고정 폭 인코딩하여 파싱 안정성 확보</li>
                    <li><span class="highlight">완전한 RNG 복원:</span> BaseSeed와 각 Domain별 사용량을 저장하여 RNG 상태를 완전히 복원</li>
                    <li><span class="highlight">Domain별 독립 추적:</span> 각 게임 영역의 RNG 사용량을 독립적으로 추적하여 정확한 상태 복원</li>
                    <li><span class="highlight">JSON 저장:</span> Seed Token을 JSON 파일에 저장하여 영구 보존</li>
                    <li><span class="highlight">에러 처리:</span> 토큰 파싱 실패 시 안전하게 false 반환하여 게임 크래시 방지</li>
                </ul>

                <h2>3. 기술적 특징</h2>
                <ul>
                    <li><span class="highlight">완전한 RNG 복원:</span> Seed Token 시스템으로 게임의 랜덤 상태 완전 복원</li>
                    <li><span class="highlight">JSON 기반 저장:</span> Unity JsonUtility를 활용한 직렬화/역직렬화</li>
                    <li><span class="highlight">고정 폭 인코딩:</span> BaseSeed(10자리), Domain ID(3자리), Usage(12자리)로 고정 폭 인코딩하여 파싱 안정성 확보</li>
                </ul>
                </div>

                <div id="wfk-loading-tab" class="tab-content">
                <h2>1. 비동기 로딩 시스템</h2>
                <p>게임 데이터 로딩과 씬 전환 시 UI 블로킹을 방지하기 위해 <span class="highlight">비동기 로딩 시스템</span>을 구현했습니다. 
                Unity의 <code>async/await</code>와 <code>Task</code>를 활용하여 로딩 진행률을 실시간으로 표시하고, 사용자 경험을 향상시켰습니다.</p>

                <h3>1.1 로딩 프로세스 개요</h3>
                <p>게임 시작 시 필요한 모든 데이터를 순차적으로 비동기로 로드합니다:</p>
                <ol>
                    <li><span class="highlight">메타 시트 다운로드:</span> 서버의 버전 정보가 담긴 메타 시트를 먼저 다운로드 (0% ~ 20%)</li>
                    <li><span class="highlight">CSV 데이터 다운로드:</span> 모든 게임 데이터 CSV 파일을 버전 비교 후 다운로드 (20% ~ 80%)</li>
                    <li><span class="highlight">데이터 파싱:</span> 다운로드한 CSV 데이터를 파싱하여 게임 객체로 변환 (80% ~ 90%)</li>
                    <li><span class="highlight">최종 초기화:</span> Managers 시스템 초기화 및 게임 준비 완료 (90% ~ 100%)</li>
                </ol>

                <h3>1.2 핵심 로딩 로직</h3>
                <p>각 단계를 순차적으로 실행하며 진행률을 실시간으로 보고합니다.</p>

<pre><code><span class="c-cm">// LoadingManager.cs: 비동기 게임 데이터 로딩</span>
<span class="c-kw">public async</span> <span class="c-ty">Task</span>&lt;<span class="c-kw">bool</span>&gt; <span class="c-fn">LoadGameDataAsync</span>(<span class="c-ty">Action</span>&lt;<span class="c-kw">float</span>&gt; progressCallback = <span class="c-kw">null</span>)
{
    <span class="c-cm">// 1. 메타 시트 다운로드 (0% ~ 20%)</span>
    <span class="c-kw">bool</span> metaSuccess = <span class="c-kw">await</span> <span class="c-ty">ServerCSV_ConvertData</span>.<span class="c-fn">DownloadMetaSheetAsync</span>();
    <span class="c-kw">if</span> (!metaSuccess) {
        <span class="c-ty">Debug</span>.<span class="c-fn">LogError</span>(<span class="c-st">"메타 시트 다운로드 실패"</span>);
        <span class="c-kw">return false</span>;
    }
    progressCallback?.<span class="c-fn">Invoke</span>(<span class="c-st">0.2f</span>);

    <span class="c-cm">// 2. 모든 CSV 데이터 다운로드 (20% ~ 80%)</span>
    <span class="c-kw">bool</span> csvSuccess = <span class="c-kw">await</span> <span class="c-ty">ServerCSV_ConvertData</span>.<span class="c-fn">DownloadAllCSVAsync</span>((progress) => {
        <span class="c-cm">// CSV 다운로드 진행률을 20% ~ 80% 범위로 매핑</span>
        <span class="c-kw">float</span> mappedProgress = <span class="c-st">0.2f</span> + (progress * <span class="c-st">0.6f</span>);
        progressCallback?.<span class="c-fn">Invoke</span>(mappedProgress);
    });
    <span class="c-kw">if</span> (!csvSuccess) {
        <span class="c-ty">Debug</span>.<span class="c-fn">LogError</span>(<span class="c-st">"CSV 데이터 다운로드 실패"</span>);
        <span class="c-kw">return false</span>;
    }

    <span class="c-cm">// 3. 데이터 파싱 및 초기화 (80% ~ 90%)</span>
    <span class="c-kw">await</span> <span class="c-ty">Task</span>.<span class="c-fn">Run</span>(() => {
        Managers.Data.<span class="c-fn">ServerDataLoad</span>();  <span class="c-cm">// 백그라운드 스레드에서 파싱</span>
    });
    progressCallback?.<span class="c-fn">Invoke</span>(<span class="c-st">0.9f</span>);

    <span class="c-cm">// 4. 최종 초기화 (90% ~ 100%)</span>
    <span class="c-kw">await</span> <span class="c-ty">Task</span>.<span class="c-fn">Yield</span>();  <span class="c-cm">// 메인 스레드로 복귀</span>
    Managers.Game.<span class="c-fn">Init</span>();
    Managers.UI.<span class="c-fn">Init</span>();
    progressCallback?.<span class="c-fn">Invoke</span>(<span class="c-st">1.0f</span>);

    <span class="c-kw">return true</span>;
}</code></pre>

                <h3>1.3 진행률 매핑</h3>
                <p>각 단계의 진행률을 전체 로딩 진행률로 매핑하여 사용자에게 일관된 피드백을 제공합니다.</p>
                <div style="background: rgba(56, 139, 253, 0.1); border-left: 4px solid #388bfd; padding: 15px 20px; margin: 20px 0; border-radius: 6px;">
                    <div style="margin-bottom: 10px;"><strong>진행률 분배:</strong></div>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li>메타 시트 다운로드: 0% ~ 20%</li>
                        <li>CSV 데이터 다운로드: 20% ~ 80% (각 파일 다운로드 진행률을 0.2 ~ 0.8 범위로 매핑)</li>
                        <li>데이터 파싱: 80% ~ 90%</li>
                        <li>최종 초기화: 90% ~ 100%</li>
                    </ul>
                </div>

                <h3>1.4 로딩 UI 업데이트</h3>
                <p>비동기 작업은 백그라운드 스레드에서 실행되므로, UI 업데이트는 메인 스레드에서 안전하게 수행해야 합니다. 
                <span class="highlight">UnityMainThreadDispatcher</span>를 사용하여 백그라운드 스레드에서 메인 스레드로 작업을 전달합니다.</p>

<pre><code><span class="c-cm">// LoadingUI.cs: 로딩 UI 업데이트</span>
<span class="c-kw">public async void</span> <span class="c-fn">StartLoading</span>()
{
    <span class="c-ty">LoadingUI</span> loadingUI = <span class="c-fn">GetLoadingUI</span>();
    loadingUI.<span class="c-fn">Show</span>();  <span class="c-cm">// 로딩 UI 표시</span>

    <span class="c-kw">bool</span> success = <span class="c-kw">await</span> <span class="c-fn">LoadGameDataAsync</span>((progress) => {
        <span class="c-cm">// 백그라운드 스레드에서 호출되므로 메인 스레드로 전달</span>
        <span class="c-ty">UnityMainThreadDispatcher</span>.<span class="c-fn">Instance</span>().<span class="c-fn">Enqueue</span>(() => {
            loadingUI.<span class="c-fn">UpdateProgress</span>(progress);  <span class="c-cm">// 진행률 바 업데이트</span>
            loadingUI.<span class="c-fn">UpdateText</span>($<span class="c-st">"로딩 중... {progress * 100:F0}%"</span>);  <span class="c-cm">// 텍스트 업데이트</span>
        });
    });

    <span class="c-kw">if</span> (success) {
        loadingUI.<span class="c-fn">Hide</span>();
        <span class="c-fn">OnLoadingComplete</span>();  <span class="c-cm">// 로딩 완료 처리</span>
    } <span class="c-kw">else</span> {
        loadingUI.<span class="c-fn">ShowError</span>(<span class="c-st">"로딩 실패"</span>);  <span class="c-cm">// 에러 표시</span>
    }
}</code></pre>

                <h3>1.5 UnityMainThreadDispatcher</h3>
                <p>비동기 작업 중 UI 업데이트를 위해 사용하는 유틸리티입니다. 백그라운드 스레드에서 메인 스레드로 작업을 큐에 추가하여 
                다음 프레임에 실행되도록 합니다.</p>

<pre><code><span class="c-cm">// UnityMainThreadDispatcher.cs: 메인 스레드 작업 큐</span>
<span class="c-kw">public void</span> <span class="c-fn">Enqueue</span>(<span class="c-ty">Action</span> action)
{
    lock (executionQueue) {
        executionQueue.<span class="c-fn">Enqueue</span>(action);  <span class="c-cm">// 작업을 큐에 추가</span>
    }
}

<span class="c-kw">void</span> <span class="c-fn">Update</span>()
{
    <span class="c-cm">// 매 프레임 큐에 있는 작업들을 메인 스레드에서 실행</span>
    <span class="c-kw">while</span> (executionQueue.Count > <span class="c-st">0</span>) {
        executionQueue.<span class="c-fn">Dequeue</span>().<span class="c-fn">Invoke</span>();
    }
}</code></pre>

                <h3>1.6 기술적 특징</h3>
                <ul>
                    <li><span class="highlight">비동기 처리:</span> async/await를 활용하여 메인 스레드 블로킹 방지</li>
                    <li><span class="highlight">진행률 표시:</span> 실시간 진행률 콜백으로 사용자에게 명확한 피드백 제공</li>
                    <li><span class="highlight">에러 처리:</span> 각 단계별 실패 시 적절한 에러 메시지 표시</li>
                    <li><span class="highlight">UI 반응성:</span> UnityMainThreadDispatcher를 통한 안전한 UI 업데이트</li>
                    <li><span class="highlight">백그라운드 파싱:</span> Task.Run을 사용하여 무거운 파싱 작업을 백그라운드에서 수행</li>
                    <li><span class="highlight">순차적 로딩:</span> 각 단계를 순차적으로 실행하여 의존성 문제 방지</li>
                </ul>
                </div>

                <div style="height: 100px;"></div>
            </div>
        </div>
    </div>

    <script>
        function openMLAgentsModal(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            console.log('openMLAgentsModal called');
            try {
                // 다른 모달이 열려있으면 먼저 닫기
                const fileTowerModal = document.getElementById('modal-overlay');
                if (fileTowerModal && fileTowerModal.style.display === 'flex') {
                    console.log('Closing File Tower Defense modal first');
                    fileTowerModal.style.display = 'none';
                }
                
                // 모달 찾기
                const modal = document.getElementById('modal-overlay-racing');
                
                // 모달 요소 검증
                if (!modal) {
                    console.error('modal-overlay-racing not found!');
                    console.log('All modals:', document.querySelectorAll('.modal-overlay'));
                    alert('모달을 찾을 수 없습니다. 페이지를 새로고침해주세요.');
                    return;
                }
                
                console.log('Modal element found:', modal);
                console.log('Modal ID:', modal.id);
                console.log('Modal classList:', modal.classList.toString());
                console.log('Modal innerHTML preview:', modal.innerHTML.substring(0, 100));
                
                // 모달 위치 및 크기 확인
                const initialRect = modal.getBoundingClientRect();
                console.log('Modal initial bounding rect:', {
                    top: initialRect.top,
                    left: initialRect.left,
                    width: initialRect.width,
                    height: initialRect.height,
                    bottom: initialRect.bottom,
                    right: initialRect.right
                });
                
                // modal-container와 modal-body 확인
                const modalContainer = modal.querySelector('.modal-container');
                const modalBody = modal.querySelector('.modal-body');
                console.log('Modal container:', modalContainer);
                console.log('Modal body:', modalBody);
                
                if (modalContainer) {
                    const containerStyle = window.getComputedStyle(modalContainer);
                    console.log('Container display:', containerStyle.display);
                    console.log('Container visibility:', containerStyle.visibility);
                }
                
                if (modalBody) {
                    const bodyStyle = window.getComputedStyle(modalBody);
                    console.log('Body display:', bodyStyle.display);
                    console.log('Body visibility:', bodyStyle.visibility);
                }
                
                // 모달이 body의 직접 자식인지 확인하고, 아니면 이동
                if (modal.parentElement !== document.body) {
                    console.log('Moving modal to body');
                    document.body.appendChild(modal);
                }
                
                // 모달의 기본 스타일 강제 적용 (인라인 스타일)
                modal.style.setProperty('display', 'flex', 'important');
                modal.style.setProperty('position', 'fixed', 'important');
                modal.style.setProperty('top', '0', 'important');
                modal.style.setProperty('left', '0', 'important');
                modal.style.setProperty('width', '100vw', 'important');
                modal.style.setProperty('height', '100vh', 'important');
                modal.style.setProperty('z-index', '99999', 'important');
                modal.style.setProperty('background', 'rgba(0,0,0,0.92)', 'important');
                modal.style.setProperty('justify-content', 'center', 'important');
                modal.style.setProperty('align-items', 'center', 'important');
                modal.style.setProperty('visibility', 'visible', 'important');
                modal.style.setProperty('opacity', '1', 'important');
                modal.style.setProperty('margin', '0', 'important');
                modal.style.setProperty('padding', '0', 'important');
                
            document.body.style.overflow = 'hidden';
                
                // 자식 요소 강제 표시 및 크기 확인
                if (modalContainer) {
                    modalContainer.style.setProperty('display', 'block', 'important');
                    modalContainer.style.setProperty('visibility', 'visible', 'important');
                    modalContainer.style.setProperty('opacity', '1', 'important');
                    modalContainer.style.setProperty('width', '95%', 'important');
                    modalContainer.style.setProperty('max-width', '1000px', 'important');
                }
                
                if (modalBody) {
                    modalBody.style.setProperty('display', 'block', 'important');
                    modalBody.style.setProperty('visibility', 'visible', 'important');
                    modalBody.style.setProperty('opacity', '1', 'important');
                }
                
                // 강제 리플로우 트리거
                void modal.offsetHeight;
                
                // 리플로우 후 크기 확인
                requestAnimationFrame(function() {
                    const checkRect = modal.getBoundingClientRect();
                    const checkComputed = window.getComputedStyle(modal);
                    console.log('After reflow - Modal state:', {
                        computedDisplay: checkComputed.display,
                        computedWidth: checkComputed.width,
                        computedHeight: checkComputed.height,
                        rectWidth: checkRect.width,
                        rectHeight: checkRect.height,
                        offsetWidth: modal.offsetWidth,
                        offsetHeight: modal.offsetHeight,
                        parentElement: modal.parentElement.tagName
                    });
                    
                    if (checkRect.width === 0 || checkRect.height === 0) {
                        console.error('Modal still zero size! Trying alternative approach...');
                        // 최후의 수단: 모달을 완전히 재생성
                        modal.style.cssText = 'display: flex !important; position: fixed !important; top: 0 !important; left: 0 !important; width: 100vw !important; height: 100vh !important; z-index: 99999 !important; background: rgba(0,0,0,0.92) !important; justify-content: center !important; align-items: center !important; visibility: visible !important; opacity: 1 !important; margin: 0 !important; padding: 0 !important;';
                    }
                });
                
            } catch (error) {
                console.error('Error in openMLAgentsModal:', error);
                alert('모달을 열 수 없습니다: ' + error.message);
            }
        }
        
        function openWFKModal(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            console.log('openWFKModal called');
            try {
                // 다른 모달이 열려있으면 먼저 닫기
                const fileTowerModal = document.getElementById('modal-overlay');
                if (fileTowerModal && fileTowerModal.style.display === 'flex') {
                    fileTowerModal.style.display = 'none';
                }
                const mlAgentsModal = document.getElementById('modal-overlay-racing');
                if (mlAgentsModal && mlAgentsModal.style.display === 'flex') {
                    mlAgentsModal.style.display = 'none';
                }
                
                const modal = document.getElementById('modal-overlay-wfk');
                if (!modal) {
                    console.error('modal-overlay-wfk not found!');
                    console.log('All modals:', document.querySelectorAll('.modal-overlay'));
                    alert('모달을 찾을 수 없습니다. 페이지를 새로고침해주세요.');
                    return;
                }
                
                console.log('WFK Modal element found:', modal);
                
                // 모달이 body의 직접 자식이 아니면 body에 추가
                if (modal.parentElement !== document.body) {
                    document.body.appendChild(modal);
                    console.log('Modal moved to body');
                }
                
                const modalContainer = modal.querySelector('.modal-container');
                const modalBody = modal.querySelector('.modal-body');
                
                // 강제 스타일 적용
                modal.style.setProperty('display', 'flex', 'important');
                modal.style.setProperty('position', 'fixed', 'important');
                modal.style.setProperty('top', '0', 'important');
                modal.style.setProperty('left', '0', 'important');
                modal.style.setProperty('width', '100vw', 'important');
                modal.style.setProperty('height', '100vh', 'important');
                modal.style.setProperty('z-index', '99999', 'important');
                modal.style.setProperty('background', 'rgba(0,0,0,0.92)', 'important');
                modal.style.setProperty('justify-content', 'center', 'important');
                modal.style.setProperty('align-items', 'center', 'important');
                modal.style.setProperty('visibility', 'visible', 'important');
                modal.style.setProperty('opacity', '1', 'important');
                modal.style.setProperty('margin', '0', 'important');
                modal.style.setProperty('padding', '0', 'important');
                
                document.body.style.overflow = 'hidden';
                
                // 첫 번째 탭(csv) 활성화
                switchTabWFK('csv');
                
                // 자식 요소 강제 표시
                if (modalContainer) {
                    modalContainer.style.setProperty('display', 'block', 'important');
                    modalContainer.style.setProperty('visibility', 'visible', 'important');
                    modalContainer.style.setProperty('opacity', '1', 'important');
                    modalContainer.style.setProperty('width', '95%', 'important');
                    modalContainer.style.setProperty('max-width', '1000px', 'important');
                }
                
                if (modalBody) {
                    modalBody.style.setProperty('display', 'block', 'important');
                    modalBody.style.setProperty('visibility', 'visible', 'important');
                    modalBody.style.setProperty('opacity', '1', 'important');
                }
                
                // 강제 리플로우 트리거
                void modal.offsetHeight;
                
                // 리플로우 후 크기 확인
                requestAnimationFrame(function() {
                    const checkRect = modal.getBoundingClientRect();
                    const checkComputed = window.getComputedStyle(modal);
                    console.log('WFK Modal after reflow:', {
                        computedDisplay: checkComputed.display,
                        computedWidth: checkComputed.width,
                        computedHeight: checkComputed.height,
                        rectWidth: checkRect.width,
                        rectHeight: checkRect.height,
                        offsetWidth: modal.offsetWidth,
                        offsetHeight: modal.offsetHeight
                    });
                    
                    if (checkRect.width === 0 || checkRect.height === 0) {
                        console.warn('WFK Modal has zero size, forcing dimensions');
                        modal.style.setProperty('width', '100vw', 'important');
                        modal.style.setProperty('height', '100vh', 'important');
                    }
                });
            } catch (error) {
                console.error('Error in openWFKModal:', error);
                alert('모달을 열 수 없습니다: ' + error.message);
            }
        }
        
        function closeWFKModal() {
            const modal = document.getElementById('modal-overlay-wfk');
            if (modal) {
                modal.style.display = 'none';
                modal.style.visibility = 'hidden';
                modal.style.opacity = '0';
                document.body.style.overflow = '';
            }
        }
        
        function openModal(projectType) {
            console.log('openModal called with:', projectType);
            try {
                if (projectType === 'mlAgentsRacing') {
                    openMLAgentsModal(null);
                } else if (projectType === 'wfk') {
                    const modal = document.getElementById('modal-overlay-wfk');
                    if (modal) {
                        const fileTowerModal = document.getElementById('modal-overlay');
                        if (fileTowerModal) fileTowerModal.style.display = 'none';
                        const mlAgentsModal = document.getElementById('modal-overlay-racing');
                        if (mlAgentsModal) mlAgentsModal.style.display = 'none';
                        modal.style.display = 'flex';
                        document.body.style.overflow = 'hidden';
                    }
                } else {
                    const modal = document.getElementById('modal-overlay');
                    if (modal) {
                        modal.style.display = 'flex';
                        // 기본적으로 리팩토링 탭 활성화
                        if (typeof switchTab === 'function') {
                            switchTab('refactoring');
                        }
                        document.body.style.overflow = 'hidden';
                    } else {
                        console.error('modal-overlay element not found');
                        return;
                    }
                }
            } catch (error) {
                console.error('Error opening modal:', error);
                alert('모달을 열 수 없습니다: ' + error.message);
            }
        }
        function closeModal(projectType) {
            if (projectType === 'racing' || projectType === 'mlAgentsRacing') {
                document.getElementById('modal-overlay-racing').style.display = 'none';
            } else if (projectType === 'wfk') {
                document.getElementById('modal-overlay-wfk').style.display = 'none';
            } else {
            document.getElementById('modal-overlay').style.display = 'none';
            }
            document.body.style.overflow = 'auto';
        }
        function switchTab(tabName) {
            // 모든 탭 버튼 비활성화
            const buttons = document.querySelectorAll('.tab-button');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            // 모든 탭 콘텐츠 숨기기
            const contents = document.querySelectorAll('.tab-content');
            contents.forEach(content => content.classList.remove('active'));
            
            // 선택된 탭 활성화
            if (tabName === 'refactoring') {
                document.querySelector('.tab-button:first-child').classList.add('active');
                document.getElementById('refactoring-tab').classList.add('active');
            } else if (tabName === 'existing') {
                document.querySelector('.tab-button:last-child').classList.add('active');
                document.getElementById('existing-tab').classList.add('active');
            }
        }

        function switchTabWFK(tabName) {
            // WFK 모달 내의 탭 버튼만 선택
            const wfkModal = document.getElementById('modal-overlay-wfk');
            if (!wfkModal) return;
            
            const buttons = wfkModal.querySelectorAll('.tab-button');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            const contents = wfkModal.querySelectorAll('.tab-content');
            contents.forEach(content => content.classList.remove('active'));
            
            // 선택된 탭 활성화
            if (tabName === 'csv') {
                buttons[0].classList.add('active');
                document.getElementById('wfk-csv-tab').classList.add('active');
            } else if (tabName === 'save') {
                buttons[1].classList.add('active');
                document.getElementById('wfk-save-tab').classList.add('active');
            } else if (tabName === 'loading') {
                buttons[2].classList.add('active');
                document.getElementById('wfk-loading-tab').classList.add('active');
            }
        }
        
        // 페이지 로드 시 이벤트 리스너 추가 (백업용)
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOMContentLoaded - setting up event listeners');
            
            // ML-Agents 카드 클릭 이벤트 (백업)
            const mlAgentsCard = document.getElementById('ml-agents-card');
            if (mlAgentsCard) {
                // onclick이 이미 있지만, 추가로 이벤트 리스너도 추가
                mlAgentsCard.addEventListener('click', function(e) {
                    console.log('ML-Agents card clicked via event listener');
                    e.preventDefault();
                    e.stopPropagation();
                    openMLAgentsModal(e);
                }, true); // capture phase에서도 작동하도록
                console.log('ML-Agents card event listener added');
            } else {
                console.error('ml-agents-card not found');
            }
            
            // File Tower Defense 카드 클릭 이벤트
            const fileTowerDefenseCard = document.getElementById('file-tower-defense-card');
            if (fileTowerDefenseCard) {
                fileTowerDefenseCard.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    openModal('fileTowerDefense');
                });
                console.log('File Tower Defense card event listener added');
            } else {
                console.error('file-tower-defense-card not found');
            }
            
            // WFK 카드 이벤트 리스너
            const wfkCard = document.getElementById('wfk-card');
            if (wfkCard) {
                wfkCard.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    openWFKModal(e);
                }, true);
                console.log('WFK card event listener added');
            } else {
                console.error('wfk-card not found');
            }
        });
    </script>
</body>
</html>
