<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minhyuk Lee | Systems & Rendering</title>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500;700&family=Inter:wght@300;400;700&family=Noto+Sans+KR:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0D1117;
            --card-bg: #161B22;
            --text-color: #C9D1D9;
            --accent-color: #58A6FF;
            --sub-accent: #238636;
            --border-color: #30363D;
            --code-bg: #010409;
            --code-comment: #8b949e;
            --code-keyword: #ff7b72;
            --code-type: #79c0ff;
            --code-func: #d2a8ff;
            --code-string: #a5d6ff;
        }

        /* --- Global Styles --- */
        * { box-sizing: border-box; margin: 0; padding: 0; cursor: crosshair; }
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Inter', 'Noto Sans KR', sans-serif;
            line-height: 1.6;
        }
        .mono { font-family: 'Fira Code', monospace; }
        .container { max-width: 1000px; margin: 0 auto; padding: 80px 20px; }

        header { margin-bottom: 60px; }
        .name-tag { font-size: 3.5rem; color: #f0f6fc; font-weight: 700; margin-bottom: 10px; }
        .status-line { color: var(--accent-color); font-size: 1.1rem; border-left: 3px solid var(--accent-color); padding-left: 15px; }

        /* --- Sections --- */
        .section-title {
            font-family: 'Fira Code', monospace; font-size: 1.5rem; color: #f0f6fc;
            margin: 80px 0 30px; display: flex; align-items: center;
        }
        .section-title::after { content: ""; flex: 1; height: 1px; background: var(--border-color); margin-left: 20px; }

        /* --- About Me --- */
        .about-box {
            background: var(--card-bg); padding: 30px; border: 1px solid var(--border-color); border-radius: 12px;
            color: #8b949e; margin-bottom: 50px;
        }
        .about-highlight { color: #f0f6fc; font-weight: 700; font-size: 1.1rem; display: block; margin-bottom: 15px; }

        /* --- Skills --- */
        .skill-container { display: flex; flex-wrap: wrap; gap: 15px; }
        .skill-item {
            background: var(--card-bg); border: 1px solid var(--border-color);
            padding: 12px 24px; border-radius: 6px; transition: 0.3s;
        }
        .skill-item:hover { border-color: var(--accent-color); transform: translateY(-3px); box-shadow: 0 4px 15px rgba(88, 166, 255, 0.1); }
        .skill-label { font-size: 0.75rem; color: var(--accent-color); display: block; margin-bottom: 5px; text-transform: uppercase; font-weight: 700; }

        /* --- Projects --- */
        .project-card {
            background: var(--card-bg); border: 1px solid var(--border-color);
            border-radius: 12px; overflow: hidden; transition: 0.4s cubic-bezier(0.165, 0.84, 0.44, 1); cursor: pointer;
        }
        .project-card:hover { border-color: var(--accent-color); transform: scale(1.02); box-shadow: 0 20px 40px rgba(0,0,0,0.6); }
        .project-info { padding: 40px; }
        .project-tag { color: var(--sub-accent); font-size: 0.85rem; font-weight: 700; margin-bottom: 10px; display: block; }
        .project-name { font-size: 2rem; color: #f0f6fc; margin-bottom: 20px; }
        
        /* --- Modal --- */
        .modal-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92); z-index: 10000; justify-content: center; align-items: center; backdrop-filter: blur(10px);
        }
        .modal-container {
            background: var(--bg-color); width: 95%; max-width: 1000px; max-height: 90vh;
            border: 1px solid var(--border-color); border-radius: 16px; overflow-y: auto;
            animation: modalIn 0.3s ease-out;
        }
        @keyframes modalIn { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

        .modal-body { padding: 60px; }
        .modal-header-nav { display: flex; justify-content: space-between; align-items: center; margin-bottom: 40px; }
        .modal-body h2 { color: var(--accent-color); margin: 60px 0 25px; font-size: 1.8rem; border-left: 6px solid var(--accent-color); padding-left: 20px;}
        .modal-body h3 { color: #f0f6fc; margin: 35px 0 15px; font-size: 1.3rem; font-weight: 600; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        .modal-body p { margin-bottom: 18px; color: #8b949e; font-size: 1.05rem; }
        .modal-body ul { margin: 15px 0 30px 25px; color: #8b949e; }
        .modal-body li { margin-bottom: 10px; }

        /* --- Visual Frames --- */
        .visual-frame {
            width: 100%; padding: 30px; background: rgba(0,0,0,0.4);
            border: 1px solid var(--border-color); border-radius: 8px;
            margin: 25px 0; text-align: center;
        }
        .visual-frame > * {
            text-align: center;
        }
        .diagram-grid {
            display: grid; grid-template-columns: repeat(3, 40px); gap: 5px; justify-content: center; margin: 10px 0;
        }
        .grid-cell { width: 40px; height: 40px; border: 1px solid var(--accent-color); opacity: 0.2; }
        .grid-cell.active { background: var(--accent-color); opacity: 1; box-shadow: 0 0 15px var(--accent-color); }
        .grid-cell.near { border-color: var(--sub-accent); background: rgba(35, 134, 54, 0.2); opacity: 1; }

        .transaction-flow {
            display: flex; align-items: center; justify-content: center; font-size: 0.75rem; font-family: 'Fira Code';
            gap: 10px; flex-wrap: wrap;
        }
        .flow-step { padding: 8px 15px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--card-bg); color: var(--text-color); text-align: center; }
        .flow-arrow { color: var(--accent-color); font-weight: bold; }

        /* --- Tables --- */
        .data-table {
            width: 100%; border-collapse: collapse; margin: 20px 0; font-size: 0.9rem;
            background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px; overflow: hidden;
        }
        .data-table th {
            background: rgba(88, 166, 255, 0.1); color: var(--accent-color);
            padding: 12px 15px; text-align: center; font-weight: 700; border-bottom: 2px solid var(--border-color);
            font-family: 'Fira Code', monospace;
        }
        .data-table td {
            padding: 10px 15px; border-bottom: 1px solid var(--border-color); color: var(--text-color);
            text-align: center;
        }
        .data-table tr:last-child td { border-bottom: none; }
        .data-table tr:hover { background: rgba(88, 166, 255, 0.05); }

        /* --- Architecture Diagrams --- */
        .arch-diagram {
            display: flex; flex-direction: column; gap: 15px; margin: 25px 0;
        }
        .arch-layer {
            padding: 15px 20px; border: 1px solid var(--border-color); border-radius: 6px;
            background: var(--card-bg); position: relative; text-align: center;
        }
        .arch-layer::before {
            content: ""; position: absolute; left: 0; top: 0; bottom: 0; width: 4px;
            background: var(--accent-color);
        }
        .arch-layer-title {
            color: var(--accent-color); font-weight: 700; margin-bottom: 8px;
            font-family: 'Fira Code', monospace; font-size: 0.9rem; text-align: center;
        }
        .arch-layer-items {
            display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; justify-content: center;
        }
        .arch-item {
            padding: 5px 12px; background: rgba(88, 166, 255, 0.1);
            border: 1px solid var(--accent-color); border-radius: 4px;
            font-size: 0.85rem; color: var(--text-color); text-align: center;
        }

        /* --- Coordinate Flow Diagram --- */
        .coord-flow {
            display: flex; gap: 15px; margin: 25px 0;
            align-items: stretch; overflow-x: auto; padding-bottom: 10px;
            scrollbar-width: thin; scrollbar-color: var(--accent-color) rgba(0, 0, 0, 0.2);
        }
        .coord-flow::-webkit-scrollbar {
            height: 8px;
        }
        .coord-flow::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2); border-radius: 4px;
        }
        .coord-flow::-webkit-scrollbar-thumb {
            background: var(--accent-color); border-radius: 4px;
        }
        .coord-flow::-webkit-scrollbar-thumb:hover {
            background: var(--sub-accent);
        }
        .coord-box {
            padding: 20px; border: 2px solid var(--accent-color); border-radius: 8px;
            background: rgba(88, 166, 255, 0.05); text-align: center; display: flex; flex-direction: column;
            justify-content: center; min-height: 120px; min-width: 200px; flex: 0 0 auto;
            white-space: normal;
        }
        .coord-box-title {
            color: var(--accent-color); font-weight: 700; margin-bottom: 12px;
            font-family: 'Fira Code', monospace; font-size: 0.95rem; border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
        }
        .coord-box-desc {
            color: var(--text-color); font-size: 0.85rem; line-height: 1.6;
        }
        .coord-box-formula {
            color: var(--sub-accent); font-size: 0.75rem; font-family: 'Fira Code', monospace;
            margin-top: 8px; padding: 6px; background: rgba(35, 134, 54, 0.1); border-radius: 4px;
        }
        .coord-arrow {
            color: var(--accent-color); font-size: 2rem; text-align: center; display: flex;
            align-items: center; justify-content: center;
        }
        .coord-bidirectional {
            text-align: center; color: var(--sub-accent); margin: 25px 0;
            font-family: 'Fira Code', monospace; font-size: 1rem; font-weight: 700;
            padding: 12px; background: rgba(35, 134, 54, 0.1); border-radius: 6px;
            border: 1px solid var(--sub-accent);
        }

        /* --- Advanced Code Block --- */
        pre {
            background: var(--code-bg); padding: 25px; border-radius: 10px; 
            font-family: 'Fira Code', monospace; font-size: 0.9rem; color: #d1d5da;
            overflow-x: auto; margin: 25px 0; border: 1px solid var(--border-color);
            line-height: 1.6; white-space: pre; 
        }
        .c-kw { color: var(--code-keyword); }
        .c-ty { color: var(--code-type); }
        .c-fn { color: var(--code-func); }
        .c-cm { color: var(--code-comment); }
        .c-st { color: var(--code-string); }

        footer { margin-top: 100px; padding: 60px 0; border-top: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: flex-end; }
        .highlight { color: #f0f6fc; font-weight: 700; }

        /* --- Tab System --- */
        .tab-container {
            display: flex; gap: 10px; margin-bottom: 40px; border-bottom: 2px solid var(--border-color);
        }
        .tab-button {
            background: none; border: none; color: #8b949e; padding: 15px 30px;
            font-family: 'Fira Code', monospace; font-size: 1rem; cursor: pointer;
            border-bottom: 3px solid transparent; transition: all 0.3s;
            position: relative; top: 2px;
        }
        .tab-button:hover {
            color: var(--accent-color);
        }
        .tab-button.active {
            color: var(--accent-color); border-bottom-color: var(--accent-color);
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        /* Video Container Responsive */
        @media (max-width: 768px) {
            .video-container {
                grid-template-columns: 1fr !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1 class="name-tag head">Minhyuk Lee</h1>
            <div class="status-line mono">Game Developer</div>
        </header>

        <section id="about">
            <h2 class="section-title">00. About me</h2>
            <div style="max-width: 800px; margin: 0 auto; padding: 20px 0;">
                <p style="line-height: 1.8; color: #c9d1d9; font-size: 1rem; margin-bottom: 20px;">
                    안녕하세요. 저는 게임 개발자로써, 꿈을 키우며 공부하고 있는 이민혁이라고 합니다. 
                    요즘엔, 렌더링, 머신러닝을 최근에 관심있게 공부하고 있으며 능력있는 개발자로써 Computer Science도 열정적으로 공부하고 있습니다. 잘 부탁드립니다.
                </p>
                <p style="line-height: 1.8; color: #c9d1d9; font-size: 1rem; margin-bottom: 30px;">
                    Hello, I'm Minhyuk Lee, a game developer pursuing my dreams through continuous learning. 
                    I'm currently focusing on rendering and machine learning with great interest, and as an aspiring developer, I'm also passionately studying Computer Science. 
                    Thank you for visiting my portfolio!
                </p>
                <div class="mono" style="font-size: 0.9rem; line-height: 1.8;">
                    <span class="highlight">SCHOOL:</span> 동명대학교<br>
                    <span class="highlight">CONTACT:</span> <a href="mailto:seif4688@gmail.com">seif4688@gmail.com</a><br>
                    <span class="highlight">GITHUB:</span> <a href="https://github.com/InfiSword" target="_blank">InfiSword</a><br>
                    <span class="highlight">BLOG 1:</span> <a href="https://minkg3532.tistory.com/" target="_blank">티스토리</a><br>
                    <span class="highlight">BLOG 2:</span> <a href="https://blog.naver.com/minkg3532" target="_blank">네이버 블로그</a>
                </div>
            </div>
        </section>

        <section id="skills">
            <h2 class="section-title">01. Tech Stack</h2>
            <div class="skill-container">
                <div class="skill-item">
                    <span class="skill-label mono">Languages</span>
                    <span class="mono">C++, C#, HLSL, Python</span>
                </div>
                <div class="skill-item">
                    <span class="skill-label mono">Engine/Graphics</span>
                    <span class="mono">Unity, Unreal, DirectX 11, Computer Graphics</span>
                </div>
                <div class="skill-item">
                    <span class="skill-label mono">Specialized</span>
                    <span class="mono">ML-Agents (Machine Learning)</span>
                </div>
            </div>
        </section>

        <section id="projects">
            <h2 class="section-title">02. Game Project</h2>
            <article class="project-card" id="file-tower-defense-card" style="cursor: pointer;">
                <div class="project-info">
                    <span class="project-tag mono">Systems Engineering</span>
                    <h3 class="project-name">File Tower Defense</h3>
                    <p style="color: #8b949e; margin-bottom: 25px;">
                        유니티의 좌표계 특성을 분석하여 <span class="highlight">RectTransform(UI)에서 Transform(GameObject) 기반</span>으로 아키텍처를 전면 재설계. 
                        <span class="highlight">공간 분할 최적화</span>와 <span class="highlight">트랜잭션 기반 배치 시스템</span>을 구축하여 성능 최적화와 확장성 있는 그리드 관리 시스템을 완성. 
                        <span class="highlight">중앙 집중식 마우스 입력 관리(InputManager)</span>와 <span class="highlight">이벤트 기반 상호작용 시스템(InteractionHandler)</span>을 통해 
                        수많은 유닛의 개별 이벤트 수신을 제거하고 통합 관리하여 성능을 최적화.
                    </p>
                    <div class="mono" style="font-size: 0.9rem; color: var(--accent-color);">>> VIEW_TECHNICAL_REPORT</div>
                </div>
            </article>
            <article class="project-card" id="ml-agents-card" style="cursor: pointer;" onclick="openMLAgentsModal(event)">
                <div class="project-info" onclick="event.stopPropagation()">
                    <span class="project-tag mono">ML-Agents & Reinforcement Learning</span>
                    <h3 class="project-name">Autonomous Racing Agent</h3>
                    <p style="color: #8b949e; margin-bottom: 25px;">
                        Unity ML-Agents를 활용한 <span class="highlight">자율 주행 경주차 에이전트</span> 학습 시스템 구축. 
                        <span class="highlight">체크포인트 기반 네비게이션 시스템</span>과 <span class="highlight">목표 지향 보상 설계</span>를 통해 정해진 트랙을 안정적으로 주행하도록 학습. 
                        <span class="highlight">레이캐스트 기반 환경 감지</span>(전방/후방 벽 감지, 도로 감지)와 <span class="highlight">다중 트랙 학습 지원</span>으로 
                        일반화 성능을 향상시키고, <span class="highlight">스플라인 기반 체크포인트 자동 생성 시스템</span>을 설계하여 다양한 트랙에 빠르게 적용 가능.
                    </p>
                    <div class="mono" style="font-size: 0.9rem; color: var(--accent-color);">>> VIEW_TECHNICAL_REPORT</div>
                </div>
            </article>
            <article class="project-card" id="wfk-card" style="cursor: pointer;" onclick="openWFKModal(event)">
                <div class="project-info" onclick="event.stopPropagation()">
                    <span class="project-tag mono">Data Management & Parsing</span>
                    <h3 class="project-name">WorldFirstKill</h3>
                    <p style="color: #8b949e; margin-bottom: 25px;">
                        <span class="highlight">리플렉션 기반 CSV 파싱 시스템</span>과 <span class="highlight">서버 CSV 다운로드 및 버전 관리 시스템</span>을 설계하여 
                        게임 데이터를 효율적으로 관리. <span class="highlight">JSON 기반 저장/불러오기 시스템</span>과 <span class="highlight">Seed/Token 시스템</span>을 구현하여 
                        게임 상태를 안전하게 저장하고 복원. <span class="highlight">비동기 로딩 시스템</span>을 통해 
                        UI 블로킹 없는 부드러운 게임 경험 제공. <span class="highlight">Factory Pattern</span>을 활용한 데이터 기반 객체 생성 시스템으로 
                        확장 가능한 데이터 아키텍처 구축.
                    </p>
                    <div class="mono" style="font-size: 0.9rem; color: var(--accent-color);">>> VIEW_TECHNICAL_REPORT</div>
                </div>
            </article>
            <article class="project-card" id="slime-card" style="cursor: pointer;" onclick="openSlimeModal(event)">
                <div class="project-info" onclick="event.stopPropagation()">
                    <span class="project-tag mono">State Machine & Game Logic</span>
                    <h3 class="project-name">Slime Project</h3>
                    <p style="color: #8b949e; margin-bottom: 25px;">
                        하드코어 액션 퍼즐 플랫포머 게임에서 <span class="highlight">FiniteStateMachine 기반 상태 관리 시스템</span>을 설계하여 
                        모든 몬스터와 플레이어의 행동을 체계적으로 관리. <span class="highlight">플레이어 슬라임 시스템</span>(움직임, 공격, 대시, 변신)과 
                        <span class="highlight">변신 능력 시스템</span>을 구현하여 각 변신 형태마다 고유한 능력을 제공. 
                        <span class="highlight">보스 몬스터 AI</span>의 델리게이트 기반 스킬 시스템과 HP 기반 스킬 업그레이드를 설계하고, 
                        <span class="highlight">일반 몬스터 AI</span>의 상태머신 기반 행동 패턴을 구현하여 확장 가능한 AI 아키텍처를 구축.
                    </p>
                    <div class="mono" style="font-size: 0.9rem; color: var(--accent-color);">>> VIEW_TECHNICAL_REPORT</div>
                </div>
            </article>
        </section>

        <footer>

            <div class="mono" style="font-size: 0.9rem; padding: 20px; border: 1px solid var(--border-color); border-radius: 8px; background: rgba(0, 0, 0, 0.2); margin-bottom: 20px;">
                <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 15px; font-size: 1.1rem;">Awards & Experience</div>
                
                <div style="margin-bottom: 20px;">
                    <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 10px; font-size: 0.95rem;">Awards (수상 경력)</div>
                    <div style="line-height: 1.8; padding-left: 10px;">
                        <div>• <span class="highlight">2025</span> 지스타 인디어워즈 <a href="https://www.youtube.com/watch?v=kxJznVTVCfk&t=19s" target="_blank" style="color: var(--accent-color);">Best Experimental Game</a> (파일타워 디펜스)</div>
                        <div>• <span class="highlight">2025</span> 제3회 <a href="https://www.tu.ac.kr/game/sub05_01.do?mode=view&articleNo=131034&article.offset=0&articleLimit=10" target="_blank" style="color: var(--accent-color);">TU Game Challenge</a> 우수상 (파일타워디펜스)</div>
                        <div>• <span class="highlight">2025</span> 창업아이디어 경진대회 우수상</div>
                        <div>• <span class="highlight">2025</span> 부산지역인재 장학금 IT분야 수여</div>
                        <div>• <span class="highlight">2025</span> 대동장학재단 장학금 수여</div>
                        <div>• <span class="highlight">2021</span> TU-SEED 리빙랩 경진대회 입상</div>
                    </div>
                </div>

                <div style="margin-bottom: 20px;">
                    <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 10px; font-size: 0.95rem;">Certifications (자격증)</div>
                    <div style="line-height: 1.8; padding-left: 10px;">
                        <div>• <span class="highlight">정보처리기능사</span> (Qnet, 2023.04.26)</div>
                        <div>• <span class="highlight">프롬프트 디자이너</span> (AbilityLAB, 2024.09.23)</div>
                    </div>
                </div>

                <div style="margin-bottom: 20px;">
                    <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 10px; font-size: 0.95rem;">Media & Publications (언급 및 소개)</div>
                    <div style="line-height: 1.8; padding-left: 10px;">
                        <div>• <span class="highlight">2025</span> <a href="https://www.gamemeca.com/view.php?gid=1768224" target="_blank" style="color: var(--accent-color);">게임메카</a> 2025년 기대되는 인디작품 소개 (파일타워 디펜스)</div>
                        <div>• <span class="highlight">2025</span> <a href="https://store.onstove.com/ko/games/103315" target="_blank" style="color: var(--accent-color);">스토브 인디게임</a> 데모판 소개</div>
                        <div>• <span class="highlight">2025</span> <a href="https://www.tu.ac.kr/gart/sub05_05.do?mode=view&articleNo=143632&title=RISE+ALL+FESTA+%EC%9E%91%ED%92%88+%EC%B6%9C%ED%92%88+%EB%B0%8F+%EC%A0%84%EC%8B%9C" target="_blank" style="color: var(--accent-color);">RISE ALL FESTA</a> 작품 전시 및 굿즈 판매</div>
                    </div>
                </div>

                <div>
                    <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 10px; font-size: 0.95rem;">Experience (경험)</div>
                    <div style="line-height: 1.8; padding-left: 10px;">
                        <div>• <span class="highlight">2026</span> <a href="https://www.tu.ac.kr/game/sub05_01.do?mode=view&articleNo=144072&article.offset=0&articleLimit=10" target="_blank" style="color: var(--accent-color);">Mach Game Jam</a> 참여</div>
                        <div>• <span class="highlight">2025</span> 서울 코믹 월드 인디 부스 참여 (파일타워디펜스)</div>
                        <div>• <span class="highlight">2025</span> 지스타 학교 부스 전시 참여 + 인디쇼케이스 부스 참여</div>
                        <div>• <span class="highlight">2024</span> 지스타 학교 부스 전시 참여</div>
                        <div>• <span class="highlight">2022~2023</span> 대한민국 육군 병장 만기전역</div>
                    </div>
                </div>

                <div style="margin-top: 20px;">
                    <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 10px; font-size: 0.95rem;">Works (제작 작품)</div>
                    <div style="line-height: 1.8; padding-left: 10px;">
                        <div>• <a href="https://verse8.io/c6C4f9v" target="_blank" style="color: var(--accent-color);">Verse8 제작 작품</a></div>
                    </div>
                </div>
            </div>

            <div class="mono" style="font-size: 0.8rem; opacity: 0.5;">
                © 2026 MINHYUK LEE. ALL RIGHTS RESERVED.
            </div>
        </footer>
    </div>

    <!-- MODAL -->
    <div id="modal-overlay" class="modal-overlay" onclick="closeModal('fileTowerDefense')">
        <div class="modal-container" onclick="event.stopPropagation()">
            <div class="modal-body">
                <div class="modal-header-nav">
                    <div class="mono" style="color: var(--accent-color);">PROJECT REPORT // FILE_TOWER_DEFENSE</div>
                    <button onclick="closeModal()" style="background: none; border: 1px solid var(--accent-color); color: var(--accent-color); padding: 8px 20px; border-radius: 6px; cursor: pointer; font-family: 'Fira Code'; font-size: 0.8rem;">[X] DISCONNECT</button>
                </div>
                
                <div class="tab-container">
                    <button class="tab-button active" onclick="switchTab('refactoring')">리팩토링 및 개선</button>
                    <button class="tab-button" onclick="switchTab('existing')">입력 및 상호작용 시스템</button>
                </div>
                
                <div id="refactoring-tab" class="tab-content active">
                <h1 style="font-size: 2.5rem; margin-bottom: 30px; color: #f0f6fc;">시스템 리팩토링 및 개선</h1>


                <h2>1. UI(RectTransform)에서 GameObject(Transform)기반으로의 전환</h2>
                <p>초기 단계에서는 윈도우 바탕화면의 느낌을 구현하고자 파일 유닛을 UI 시스템으로 구축했습니다. 하지만 프로젝트 규모가 커짐에 따라 다음과 같은 <span class="highlight">결정적인 설계적 한계</span>를 마주했습니다.</p>
                
                <ul>
                    <li><span class="highlight">좌표계 종속성:</span> <code>RectTransform</code>은 캔버스의 앵커와 피벗 설정에 따라 월드 좌표값이 상대적으로 변합니다. 이로 인해 유닛의 절대적인 위치를 파악하는 로직이 매우 복잡해졌습니다.</li>
                    <li><span class="highlight">연산 비용의 증가:</span> 월드 좌표 기반의 바이러스(적)가 UI 기반의 파일 유닛 간의 거리 계산 및 물리적 충돌 판정을 수행할 때, <code>Camera.WorldToScreenPoint</code>, <code>Camera.ScreenToWorldPoint</code> 등의 변환 함수를 매 프레임 호출해야 하는 오버헤드가 발생했습니다.</li>
                    <li><span class="highlight">계층 구조의 복잡성:</span> 서로 다른 부모 객체(UI Hierarchy) 간의 위치 변환 로직은 코드의 가독성을 해치고 구조적인 복잡도를 증대시켰습니다.</li>
                </ul>

<div class="visual-frame">
                    <div style="display: flex; justify-content: space-around; align-items: center;">
                        <div class="mono" style="font-size: 0.7rem; border: 1px solid #ff7b72; padding: 10px;">
                            RectTransform (UI)<br>
                            - Anchor Dependent<br>
                            - Pivot Relative<br>
                            - WorldToScreen Required
                        </div>
                        <div class="flow-arrow">>>></div>
                        <div class="mono" style="font-size: 0.7rem; border: 1px solid var(--sub-accent); padding: 10px;">
                            Transform (World)<br>
                            - Absolute Position<br>
                            - Physics 2D Optimized<br>
                            - Unified Coordinate Space
                        </div>
                    </div>
                </div>

                <p>이를 해결하기 위해 모든 유닛을 <span class="highlight">GameObject(Transform) 기반</span>으로 전면 교체하여 월드 좌표계로 통일하였으며, 이를 통해 성능 최적화와 확장성 있는 로직 설계가 가능해졌습니다.</p>

                <h3>1.1 기술적 특징</h3>
                <ul>
                    <li><span class="highlight">좌표계 통일:</span> 월드 좌표계로 통일하여 절대 위치 계산 단순화</li>
                    <li><span class="highlight">성능 최적화:</span> 좌표 변환 오버헤드 제거로 프레임당 연산 비용 감소</li>
                    <li><span class="highlight">물리 시스템 통합:</span> Physics2D와 직접 호환되어 충돌 판정 효율성 향상</li>
                    <li><span class="highlight">확장성:</span> 계층 구조 단순화로 새로운 기능 추가 용이</li>
                </ul>

                <h2>2. FileGrid: 데이터 중심의 개별 셀 매니저</h2>
                <p>유닛을 <code>GameObject</code> 기반으로 전환함에 따라, 윈도우 바탕화면의 아이콘 정렬 시스템을 모방하여 유닛 배치 시스템을 구축했습니다.</p>
                <p><code>FileGrid</code>는 타워(파일)를 설치할 수 있는 최소 단위인 'Slot' 역할을 수행하며, 해당 셀의 점유 상태와 인접 유닛 간의 시너지, 버프를 관리합니다.</p>

                <div class="visual-frame">
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin: 20px 0; align-items: stretch;">
                        <div style="padding: 18px; border: 2px solid var(--accent-color); border-radius: 8px; background: rgba(88, 166, 255, 0.05); text-align: center; display: flex; flex-direction: column; justify-content: flex-start;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">State</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.8; flex-grow: 1;">
                                <div>• GridX, GridY</div>
                                <div>• fileUnit</div>
                                <div>• obstacleObject</div>
                            </div>
                        </div>
                        <div style="padding: 18px; border: 2px solid var(--sub-accent); border-radius: 8px; background: rgba(35, 134, 54, 0.05); text-align: center; display: flex; flex-direction: column; justify-content: flex-start;">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">Buff System</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.8; flex-grow: 1;">
                                <div>• HashSet&lt;File_Base&gt;</div>
                                <div>• O(1) Lookup</div>
                                <div>• Auto Sync</div>
                            </div>
                        </div>
                        <div style="padding: 18px; border: 2px solid var(--border-color); border-radius: 8px; background: rgba(0,0,0,0.2); text-align: center; display: flex; flex-direction: column; justify-content: flex-start;">
                            <div style="color: var(--text-color); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">Visuals</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.8; flex-grow: 1;">
                                <div>• Color State</div>
                                <div>• Hover Effect</div>
                                <div>• Selection</div>
                            </div>
                        </div>
                    </div>
                </div>

<pre><code><span class="c-kw">public class</span> <span class="c-ty">FileGrid</span> : <span class="c-ty">MonoBehaviour</span>
{
    [<span class="c-ty">Header</span>(<span class="c-st">"State"</span>)]
    <span class="c-kw">private</span> <span class="c-ty">File_Base</span> fileUnit; <span class="c-cm">// 현재 그리드를 점유 중인 파일 유닛</span>
    
    <span class="c-cm">// 2차원 배열의 X, Y 위치값</span>
    <span class="c-kw">public int</span> GridX { <span class="c-kw">get</span>; <span class="c-kw">private set</span>; }
    <span class="c-kw">public int</span> GridY { <span class="c-kw">get</span>; <span class="c-kw">private set</span>; }

    [<span class="c-ty">Header</span>(<span class="c-st">"Visuals"</span>)]
    <span class="c-kw">private</span> <span class="c-ty">Color</span> normalColor = <span class="c-kw">new</span> <span class="c-ty">Color</span>(1f, 1f, 1f, 0f);

    <span class="c-cm">// HashSet을 활용한 버프 소스 관리 (중복 방지 및 O(1) 조회 성능 확보)</span>
    <span class="c-kw">private readonly</span> <span class="c-ty">HashSet</span>&lt;<span class="c-ty">File_Base</span>&gt; activeBuffSources = <span class="c-kw">new</span> <span class="c-ty">HashSet</span>&lt;<span class="c-ty">File_Base</span>&gt;(); 
    
    <span class="c-kw">public</span> <span class="c-ty">GameObject</span> obstacleObject { <span class="c-kw">get</span>; <span class="c-kw">private set</span>; }

    <span class="c-cm">// ... 각종 초기화, 점유 파일 세팅/제거, 동적 버프 갱신 로직</span>
}</code></pre>
      
  <p>각 그리드 셀은 단순한 위치 정보가 아닌, <span class="highlight">HashSet 기반의 버프 관리</span>를 통해 중복 버프를 방지하고 상태 변화를 실시간으로 동기화하는 지능형 컨테이너입니다.</p>

                <h3>2.1 기술적 특징</h3>
                <ul>
                    <li><span class="highlight">상태 관리:</span> GridX, GridY, fileUnit, obstacleObject를 통한 셀 상태 추적</li>
                    <li><span class="highlight">HashSet 기반 버프 관리:</span> O(1) 조회 성능과 중복 방지</li>
                    <li><span class="highlight">시각적 피드백:</span> Color State, Hover Effect, Selection을 통한 사용자 경험 향상</li>
                    <li><span class="highlight">자동 동기화:</span> 버프 소스 변경 시 자동으로 상태 업데이트</li>
                </ul>

                <h3>2.2 이벤트 기반 자동 버프 시스템 (Observer Pattern)</h3>
                <p>유닛 배치 시 이미 그리드에 활성화된 버프 소스(Aura)를 즉각 적용받도록 설계되었습니다. <code>HashSet</code>을 사용하여 중복을 원천 차단합니다.</p>

                <div class="visual-frame">
                    <div class="arch-diagram">
                        <div class="arch-layer">
                            <div class="arch-layer-title">Buff Source (File_Base)</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">AddBuffSource()</span>
                                <span class="arch-item">RemoveBuffSource()</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓ Notify</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">FileGrid (Observer)</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">HashSet&lt;File_Base&gt;</span>
                                <span class="arch-item">O(1) Lookup</span>
                                <span class="arch-item">Auto Apply Buff</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓ Apply</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">FileUnit (Target)</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">ApplyBuffFromSource()</span>
                                <span class="arch-item">Real-time Sync</span>
                            </div>
                        </div>
                    </div>
                </div>

<pre><code><span class="c-cm">// FileGrid.cs: 버프 소스 추가 시 즉시 반응 로직</span>
<span class="c-kw">private readonly</span> <span class="c-ty">HashSet</span>&lt;<span class="c-ty">File_Base</span>&gt; _activeBuffSources = <span class="c-kw">new</span> <span class="c-ty">HashSet</span>&lt;<span class="c-ty">File_Base</span>&gt;(); 

<span class="c-kw">public void</span> <span class="c-fn">AddBuffSource</span>(<span class="c-ty">File_Base</span> source)
{
    <span class="c-kw">if</span> (source == <span class="c-kw">null</span>) <span class="c-kw">return</span>;

    <span class="c-cm">// HashSet을 통한 O(1) 중복 체크 및 빠른 조회</span>
    <span class="c-kw">if</span> (!_activeBuffSources.<span class="c-fn">Contains</span>(source)) {
        _activeBuffSources.<span class="c-fn">Add</span>(source);
    }

    <span class="c-cm">// 파일 배치 시 활성화된 버프 소스들을 즉시 적용</span>
    <span class="c-kw">if</span> (fileUnit != <span class="c-kw">null</span>) {
        <span class="c-fn">ApplyBuffFromSource</span>(fileUnit, source, <span class="c-kw">true</span>);
    }
}</code></pre>

                <h4>2.2.1 기술적 특징</h4>
                <ul>
                    <li><span class="highlight">Observer Pattern:</span> 버프 소스와 그리드 간의 느슨한 결합으로 확장성 확보</li>
                    <li><span class="highlight">O(1) 조회:</span> HashSet을 통한 빠른 버프 소스 조회</li>
                    <li><span class="highlight">즉시 적용:</span> 유닛 배치 시 활성화된 버프를 즉시 적용</li>
                    <li><span class="highlight">중복 방지:</span> HashSet을 통한 자동 중복 제거</li>
                </ul>

                <h2>3. GameObjectGridLayout: 커스텀 레이아웃 엔진</h2>
                <p>화면 해상도에 맞춰 그리드의 간격과 셀 크기를 동적으로 계산하고, 전체 시스템의 시작 월드 좌표를 제공하는 핵심 컴포넌트입니다.</p>

                <div class="visual-frame">
                    <div class="transaction-flow mono" style="margin-bottom: 20px;">
                        <div class="flow-step">Camera Resolution</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-step">Calculate Available Space</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-step">Compute Cell Size</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-step">Set Start Position</div>
                    </div>
                    <div style="padding: 18px; background: rgba(88, 166, 255, 0.05); border-radius: 6px; border: 1px solid var(--border-color); text-align: center;">
                        <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">계산 공식:</div>
                        <div style="color: var(--text-color); font-size: 0.9rem; font-family: 'Fira Code'; line-height: 1.8;">
                            <div style="margin-bottom: 8px;">cellSize = (screenSize - padding×2 - spacing×(n-1)) / n</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">n: 그리드 개수 (columns/rows)</div>
                        </div>
                    </div>
                </div>

<pre><code><span class="c-kw">public class</span> <span class="c-ty">GameObjectGridLayout</span> : <span class="c-ty">MonoBehaviour</span>
{
    [<span class="c-ty">Header</span>(<span class="c-st">"Grid Settings"</span>)]
    <span class="c-kw">[SerializeField] private int</span> columns = <span class="string">13</span>; <span class="c-cm">// X축 그리드 수</span>
    <span class="c-kw">[SerializeField] private int</span> rows = <span class="string">7</span>;     <span class="c-cm">// Y축 그리드 수</span>

    <span class="c-kw">[SerializeField] private Vector2</span> cellSize = <span class="type">Vector2</span>.one;
    <span class="c-kw">[SerializeField] private Vector2</span> spacing = <span class="type">Vector2</span>.zero;
    <span class="c-kw">[SerializeField] private Vector2</span> padding = <span class="type">Vector2</span>.zero;

    [<span class="c-ty">Header</span>(<span class="c-st">"Layout Settings"</span>)]
    <span class="c-kw">[SerializeField] private bool</span> fitToScreen;

    <span class="c-kw">public int</span> Columns => columns;
    <span class="c-kw">public int</span> Rows => rows;
    <span class="c-kw">public Vector2</span> CellSize => cellSize;
    <span class="c-kw">public Vector2</span> Spacing => spacing;
    <span class="c-kw">public bool</span> GetFitToScreen => fitToScreen;
    <span class="c-kw">public Vector2</span> StartPos { <span class="c-kw">get</span>; <span class="c-kw">private set</span>; }

    <span class="c-cm">// ... </span>

    <span class="c-cm">// 카메라 해상도에 맞춰 그리드 데이터 동적 계산</span>
    <span class="c-kw">public void</span> <span class="c-fn">FitToScreen</span>() {
        <span class="c-ty">Camera</span> cam = <span class="c-ty">Camera</span>.main;
        <span class="c-kw">float</span> height = cam.orthographicSize * <span class="string">2f</span>;
        <span class="c-kw">float</span> width = height * cam.aspect;

        <span class="c-cm">// 여백과 간격을 제외한 실제 가용 셀 크기 역산</span>
        cellSize.x = (width - (padding.x * <span class="string">2</span>) - (spacing.x * (columns - <span class="string">1</span>))) / columns;
        cellSize.y = (height - (padding.y * <span class="string">2</span>) - (spacing.y * (rows - <span class="string">1</span>))) / rows;

        <span class="c-cm">// 좌상단 기준 월드 시작 좌표 설정</span>
        StartPos = <span class="c-kw">new</span> <span class="c-ty">Vector2</span>(-(width / <span class="string">2</span>) + padding.x + (cellSize.x / <span class="string">2</span>), 
                                (height / <span class="string">2</span>) - padding.y - (cellSize.y / <span class="string">2</span>));
    }
}</code></pre>

                <h3>3.1 기술적 특징</h3>
                <ul>
                    <li><span class="highlight">동적 계산:</span> 화면 해상도에 맞춰 그리드 크기 자동 조정</li>
                    <li><span class="highlight">유연한 설정:</span> columns, rows, spacing, padding을 통한 커스터마이징</li>
                    <li><span class="highlight">시작 위치 제공:</span> StartPos를 통한 그리드 배치 기준점 제공</li>
                    <li><span class="highlight">수학적 정확성:</span> 정확한 셀 크기 계산으로 일관된 레이아웃 보장</li>
                </ul>

                <h2>4. FileGridManager: 그리드 관련 매니저</h2>
                <p>전체 그리드 시스템을 총괄하며, 좌표 변환, 조건부 탐색, 유닛 배치 트랜잭션을 총괄합니다.</p>

                <h3>4.1 공간 분할 최적화: 3x3 국소 영역 탐색 (Spatial Partitioning)</h3>
                <p>전체 그리드(91개)를 순회하는 대신, 중심 그리드 기준 3x3 영역만 검사하여 탐색 비용을 <strong>O(n)에서 O(1)</strong>로 단축했습니다. (약 10배 이상 성능 향상)</p>
                <div class="visual-frame">
                    <div class="diagram-grid">
                        <div class="grid-cell near"></div><div class="grid-cell near"></div><div class="grid-cell near"></div>
                        <div class="grid-cell near"></div><div class="grid-cell active"></div><div class="grid-cell near"></div>
                        <div class="grid-cell near"></div><div class="grid-cell near"></div><div class="grid-cell near"></div>
                    </div>
                </div>

<pre><code><span class="c-cm">// FileGridManager.cs: 공간 분할 기반 국소 탐색 최적화</span>
<span class="c-kw">private</span> <span class="c-ty">FileGrid</span> <span class="c-fn">FindClosestGridInRange</span>(<span class="c-ty">Vector2</span> worldPos, <span class="c-kw">int</span> centerX, <span class="c-kw">int</span> centerY)
{
    <span class="c-kw">float</span> minDistSqr = <span class="c-kw">float</span>.MaxValue;
    <span class="c-ty">FileGrid</span> closestGrid = <span class="c-kw">null</span>;

    <span class="c-kw">for</span> (<span class="c-kw">int</span> dx = -<span class="string">1</span>; dx <= <span class="string">1</span>; dx++) {
        <span class="c-kw">for</span> (<span class="c-kw">int</span> dy = -<span class="string">1</span>; dy <= <span class="string">1</span>; dy++) {
            <span class="c-kw">int</span> x = centerX + dx; <span class="c-kw">int</span> y = centerY + dy;
            <span class="c-kw">if</span> (<span class="c-fn">IsValidGridIndex</span>(x, y)) {
                <span class="c-fn">SearchClosestBetter</span>(gridArray[x, y], worldPos, <span class="c-kw">ref</span> minDistSqr, <span class="c-kw">ref</span> closestGrid);
            }
        }
    }
    <span class="c-kw">return</span> closestGrid;
}

<span class="c-cm">// 제곱 거리(sqrMagnitude) 사용으로 sqrt 연산 제거 최적화</span>
<span class="c-kw">private void</span> <span class="c-fn">SearchClosestBetter</span>(<span class="c-ty">FileGrid</span> candidate, <span class="c-ty">Vector2</span> worldPos, <span class="c-kw">ref float</span> bestDistSqr, <span class="c-kw">ref FileGrid</span> bestGrid)
{
    <span class="c-kw">if</span> (candidate == <span class="c-kw">null</span>) <span class="c-kw">return</span>;
    <span class="c-kw">float</span> distSqr = ((<span class="c-ty">Vector2</span>)candidate.transform.position - worldPos).sqrMagnitude;
    <span class="c-kw">if</span> (distSqr < bestDistSqr) {
        bestDistSqr = distSqr;
        bestGrid = candidate;
    }
}</code></pre>

                <h3>[트랜잭션 보장 패턴] 원자적 배치 로직 (Transactional Pattern)</h3>
                <p>유닛 배치 시 데이터 불일치를 방지하고 실패 시 이전 상태를 유지하기 위해 <strong>원자적(Atomic) 배치 로직</strong>을 설계했습니다.</p>

<pre><code><span class="c-kw">public bool</span> <span class="c-fn">TrySetUnitAtGrid</span>(<span class="c-ty">File_Base</span> unit, <span class="c-ty">FileGrid</span> targetGrid)
{
    <span class="c-cm">// 1. 유효성 검사 (Pre-validation)</span>
    <span class="c-kw">if</span> (unit == <span class="c-kw">null</span> || targetGrid == <span class="c-kw">null</span> || targetGrid.obstacleObject != <span class="c-kw">null</span>) <span class="c-kw">return false</span>;

    <span class="c-cm">// 2. 기존 그리드에서 안전하게 제거 (Rollback 준비)</span>
    <span class="c-ty">FileGrid</span> currentGrid = unit.CurrentGrid;
    <span class="c-kw">if</span> (currentGrid != <span class="c-kw">null</span> && currentGrid != targetGrid) {
        currentGrid.<span class="c-fn">RemoveFileUnit</span>(); 
    }

    <span class="c-cm">// 3. Commit: 상태 변경 및 물리/논리 계층 구조 설정</span>
    unit.FileState = <span class="c-ty">FileStatus</span>.normal;
    unit.transform.position = targetGrid.transform.position;
    unit.transform.<span class="c-fn">SetParent</span>(targetGrid.transform);
    
    <span class="c-cm">// 4. Notify: 새 그리드 등록 및 버프 자동 적용</span>
    targetGrid.<span class="c-fn">SetFileUnit</span>(unit); 
    <span class="c-kw">return true</span>;
}</code></pre>
                
                <h4>4.2.1 기술적 특징</h4>
                <ul>
                    <li><span class="highlight">원자적 연산:</span> 모든 상태 변경이 성공하거나 모두 롤백되는 트랜잭션 보장</li>
                    <li><span class="highlight">사전 검증:</span> Pre-validation을 통한 실패 가능성 사전 차단</li>
                    <li><span class="highlight">롤백 지원:</span> 실패 시 이전 상태로 안전하게 복원</li>
                    <li><span class="highlight">데이터 일관성:</span> 물리/논리 계층 구조의 동기화 보장</li>
                </ul>
                
                <h3>4.3 동적 좌표 변환 시스템: 양방향 좌표 변환 (Dynamic Coordinate Transformation)</h3>
                <p>월드 좌표와 그리드 인덱스 간의 <span class="highlight">양방향 변환</span>을 지원하여, 마우스 위치나 유닛의 월드 좌표를 그리드 인덱스로 변환하거나, 그리드 인덱스를 월드 좌표로 변환할 수 있습니다.</p>
                <p>Unity의 Transform 계층 구조를 활용하여 부모 객체의 변환을 자동으로 적용하며, 그리드 레이아웃의 셀 크기, 간격, 패딩을 동적으로 계산합니다.</p>

                <div class="visual-frame">
                    <div style="margin-bottom: 30px;">
                        <div style="text-align: center; color: var(--accent-color); font-weight: 700; margin-bottom: 15px; font-family: 'Fira Code'; font-size: 1rem;">
                            월드 좌표 → 그리드 인덱스 변환
                        </div>
                        <div class="coord-flow">
                            <div class="coord-box">
                                <div class="coord-box-title">World Position</div>
                                <div class="coord-box-desc">
                                    <strong>입력:</strong> Vector2 worldPos<br/>
                                    <span style="color: #8b949e;">마우스 위치 또는<br/>유닛의 월드 좌표</span>
                                </div>
                            </div>
                            <div class="coord-arrow">→</div>
                            <div class="coord-box">
                                <div class="coord-box-title">Local Position</div>
                                <div class="coord-box-desc">
                                    <strong>변환:</strong> InverseTransformPoint()<br/>
                                    <span style="color: #8b949e;">부모 Transform의<br/>로컬 좌표계로 변환</span>
                                </div>
                                <div class="coord-box-formula">localPos = transform.InverseTransformPoint(worldPos)</div>
                            </div>
                            <div class="coord-arrow">→</div>
                            <div class="coord-box">
                                <div class="coord-box-title">Grid Index</div>
                                <div class="coord-box-desc">
                                    <strong>출력:</strong> (x, y)<br/>
                                    <span style="color: #8b949e;">그리드 배열 인덱스<br/>(반올림 적용)</span>
                                </div>
                                <div class="coord-box-formula">x = Round((localPos.x - startPos.x) / cellWidth)</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="coord-bidirectional">↕ 양방향 변환 (Bidirectional)</div>
                    
                    <div>
                        <div style="text-align: center; color: var(--accent-color); font-weight: 700; margin-bottom: 15px; font-family: 'Fira Code'; font-size: 1rem;">
                            그리드 인덱스 → 월드 좌표 변환
                        </div>
                        <div class="coord-flow">
                            <div class="coord-box">
                                <div class="coord-box-title">Grid Index</div>
                                <div class="coord-box-desc">
                                    <strong>입력:</strong> (x, y)<br/>
                                    <span style="color: #8b949e;">그리드 배열의<br/>인덱스 좌표</span>
                                </div>
                            </div>
                            <div class="coord-arrow">→</div>
                            <div class="coord-box">
                                <div class="coord-box-title">Local Position</div>
                                <div class="coord-box-desc">
                                    <strong>계산:</strong> startPos + offset<br/>
                                    <span style="color: #8b949e;">시작 위치 + (셀 크기 × 인덱스)<br/>+ 간격(spacing) 적용</span>
                                </div>
                                <div class="coord-box-formula">localPos = startPos + x × (cellSize + spacing)</div>
                            </div>
                            <div class="coord-arrow">→</div>
                            <div class="coord-box">
                                <div class="coord-box-title">World Position</div>
                                <div class="coord-box-desc">
                                    <strong>출력:</strong> Vector2<br/>
                                    <span style="color: #8b949e;">월드 좌표계의<br/>절대 위치</span>
                                </div>
                                <div class="coord-box-formula">worldPos = transform.TransformPoint(localPos)</div>
                            </div>
                        </div>
                    </div>
                </div>

<pre><code><span class="c-cm">// 월드 좌표 → 그리드 인덱스</span>
<span class="c-kw">private bool</span> <span class="c-fn">WorldToGridIndex</span>(<span class="c-ty">Vector2</span> worldPos, <span class="c-kw">out int</span> x, <span class="c-kw">out int</span> y)
{
    x = <span class="string">0</span>;
    y = <span class="string">0</span>;

    <span class="c-kw">if</span> (gridLayout == <span class="c-kw">null</span>) <span class="c-kw">return false</span>;

    <span class="c-cm">// 1. 월드 → 로컬 변환</span>
    <span class="c-ty">Vector2</span> localPos = transform.<span class="c-fn">InverseTransformPoint</span>(worldPos);

    <span class="c-cm">// 2. 그리드 시작 위치 계산 (중앙 기준)</span>
    <span class="c-ty">Vector2</span> startPos = <span class="c-kw">new</span> <span class="c-ty">Vector2</span>(
        -gridLayout.CellSize.x * (GridWidth - <span class="string">1</span>) * <span class="string">0.5f</span>,
        -gridLayout.CellSize.y * (GridHeight - <span class="string">1</span>) * <span class="string">0.5f</span>
    );
    startPos += gridLayout.Padding;

    <span class="c-cm">// 3. 인덱스 계산</span>
    <span class="c-kw">float</span> xFloat = (localPos.x - startPos.x) / (gridLayout.CellSize.x + gridLayout.Spacing.x);
    <span class="c-kw">float</span> yFloat = (localPos.y - startPos.y) / (gridLayout.CellSize.y + gridLayout.Spacing.y);

    x = <span class="c-ty">Mathf</span>.<span class="c-fn">RoundToInt</span>(xFloat);
    y = <span class="c-ty">Mathf</span>.<span class="c-fn">RoundToInt</span>(yFloat);

    <span class="c-kw">return true</span>;
}

<span class="c-cm">// 그리드 인덱스 → 월드 좌표</span>
<span class="c-kw">public</span> <span class="c-ty">Vector2</span> <span class="c-fn">GetGridWorldPosition</span>(<span class="c-kw">int</span> x, <span class="c-kw">int</span> y)
{
    <span class="c-kw">if</span> (gridLayout == <span class="c-kw">null</span>) <span class="c-kw">return</span> <span class="c-ty">Vector2</span>.zero;

    <span class="c-cm">// 1. 로컬 위치 계산</span>
    <span class="c-ty">Vector2</span> startPos = <span class="c-kw">new</span> <span class="c-ty">Vector2</span>(
        -gridLayout.CellSize.x * (GridWidth - <span class="string">1</span>) * <span class="string">0.5f</span>,
        -gridLayout.CellSize.y * (GridHeight - <span class="string">1</span>) * <span class="string">0.5f</span>
    );
    startPos += gridLayout.Padding;

    <span class="c-ty">Vector2</span> localPos = <span class="c-kw">new</span> <span class="c-ty">Vector2</span>(
        startPos.x + x * (gridLayout.CellSize.x + gridLayout.Spacing.x),
        startPos.y + y * (gridLayout.CellSize.y + gridLayout.Spacing.y)
    );

    <span class="c-cm">// 2. 로컬 → 월드 변환</span>
    <span class="c-kw">return</span> transform.<span class="c-fn">TransformPoint</span>(localPos);
}</code></pre>

                <h4>4.3.1 기술적 특징</h4>
                <ul>
                    <li><span class="highlight">양방향 변환:</span> 월드 ↔ 그리드 인덱스 완전 호환</li>
                    <li><span class="highlight">동적 계산:</span> 런타임에 그리드 크기 변경 대응</li>
                    <li><span class="highlight">정밀도:</span> 반올림으로 정확한 인덱스 매핑</li>
                    <li><span class="highlight">Transform 계층 지원:</span> 부모 Transform 변환 자동 적용</li>
                </ul>

                <h3>4.4 플래그 기반 확장 가능한 검색 시스템: 확장 가능한 필터링 (Flag-Based Extensible Search)</h3>
                <p>그리드 검색 시 점유 상태, 장애물 존재 여부 등 다양한 조건을 <span class="highlight">플래그 조합</span>으로 필터링할 수 있는 확장 가능한 검색 시스템입니다.</p>
                <p>enum 기반의 플래그 시스템을 통해 새로운 검색 조건을 쉽게 추가할 수 있으며, 여러 플래그를 동시에 사용하여 복합 조건 검색이 가능합니다.</p>

                <div class="visual-frame">
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>플래그</th>
                                <th>설명</th>
                                <th>사용 예시</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>Occupied</code></td>
                                <td>점유된 그리드만 검색</td>
                                <td>유닛이 설치된 위치 찾기</td>
                            </tr>
                            <tr>
                                <td><code>NotOccupied</code></td>
                                <td>비어있는 그리드만 검색</td>
                                <td>새 유닛 배치 가능 위치</td>
                            </tr>
                            <tr>
                                <td><code>Obstacle</code></td>
                                <td>장애물이 있는 그리드만</td>
                                <td>장애물 위치 확인</td>
                            </tr>
                            <tr>
                                <td><code>NotObstacle</code></td>
                                <td>장애물이 없는 그리드만</td>
                                <td>배치 가능한 안전한 위치</td>
                            </tr>
                            <tr>
                                <td><code>None</code></td>
                                <td>필터 없음</td>
                                <td>모든 그리드 검색</td>
                            </tr>
                        </tbody>
                    </table>
                    <div style="margin-top: 20px; padding: 15px; background: rgba(88, 166, 255, 0.05); border-radius: 6px; border: 1px solid var(--border-color); text-align: center;">
                        <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px; font-family: 'Fira Code'; font-size: 0.95rem;">조합 예시:</div>
                        <div style="color: var(--text-color); font-size: 0.9rem; font-family: 'Fira Code'; line-height: 1.6;">
                            <code style="color: var(--code-func);">FindFlagGridWorld</code>(pos, <code style="color: var(--code-type);">NotOccupied</code>, <code style="color: var(--code-type);">NotObstacle</code>)<br/>
                            <span style="color: #8b949e; font-size: 0.85rem;">→ 비어있고 장애물이 없는 가장 가까운 그리드 검색</span>
                        </div>
                    </div>
                </div>

<pre><code><span class="c-kw">public enum</span> <span class="c-ty">SearchGridFlag</span>
{
    Occupied,       <span class="c-cm">// 점유</span>
    NotOccupied,    <span class="c-cm">// 비점유</span>
    Obstacle,       <span class="c-cm">// 장애물이 존재하는 그리드만</span>
    NotObstacle,    <span class="c-cm">// 장애물이 존재하지 않는 그리드만</span>
    None,
}

<span class="c-kw">public</span> <span class="c-ty">FileGrid</span> <span class="c-fn">FindFlagGridWorld</span>(<span class="c-ty">Vector2</span> worldPos, <span class="c-kw">params</span> <span class="c-ty">SearchGridFlag</span>[] flags)
{
    <span class="c-kw">float</span> bestDistSqr = <span class="c-kw">float</span>.MaxValue;
    <span class="c-ty">FileGrid</span> bestGrid = <span class="c-kw">null</span>;

    <span class="c-kw">foreach</span> (<span class="c-ty">FileGrid</span> grid <span class="c-kw">in</span> gridArray)
    {
        <span class="c-kw">if</span> (grid == <span class="c-kw">null</span>) <span class="c-kw">continue</span>;

        <span class="c-cm">// 플래그 조건 체크</span>
        <span class="c-kw">if</span> (!<span class="c-fn">CheckGridMatchesFlags</span>(grid, flags))
            <span class="c-kw">continue</span>;

        <span class="c-fn">SearchClosestBetter</span>(grid, worldPos, <span class="c-kw">ref</span> bestDistSqr, <span class="c-kw">ref</span> bestGrid);
    }

    <span class="c-kw">return</span> bestGrid;
}</code></pre>

                <h4>4.4.1 기술적 특징</h4>
                <ul>
                    <li><span class="highlight">확장성:</span> 새로운 플래그 추가 용이</li>
                    <li><span class="highlight">조합 가능:</span> 여러 플래그 동시 사용</li>
                    <li><span class="highlight">가변 인자:</span> params 키워드로 유연한 호출</li>
                    <li><span class="highlight">AND 조건:</span> 모든 플래그 조건 만족 필요</li>
                </ul>

                <h2>전체 시스템 기술적 특징</h2>
                <p>FileTowerDefense 프로젝트의 리팩토링을 통해 달성한 핵심 기술적 특징입니다.</p>
                <ul>
                    <li><span class="highlight">좌표계 통일:</span> UI에서 GameObject로 전환하여 월드 좌표계 기반 통합 시스템 구축</li>
                    <li><span class="highlight">성능 최적화:</span> 공간 분할 알고리즘으로 O(n)에서 O(1) 탐색 비용 단축</li>
                    <li><span class="highlight">데이터 일관성:</span> 트랜잭션 패턴을 통한 원자적 배치 로직 보장</li>
                    <li><span class="highlight">확장성:</span> 플래그 기반 검색 시스템과 Observer Pattern을 통한 유연한 아키텍처</li>
                    <li><span class="highlight">동적 레이아웃:</span> 화면 해상도에 맞춰 자동으로 조정되는 그리드 시스템</li>
                    <li><span class="highlight">양방향 좌표 변환:</span> 월드 좌표와 그리드 인덱스 간 완전한 호환성</li>
                    <li><span class="highlight">이벤트 기반 버프 시스템:</span> HashSet을 활용한 O(1) 버프 관리 및 자동 동기화</li>
                </ul>
                </div>

                <div id="existing-tab" class="tab-content">
                <h1 style="font-size: 2.5rem; margin-bottom: 30px; color: #f0f6fc;">입력 및 상호작용 시스템</h1>

                <h2>1. Mouse Event: 중앙 집중식 마우스 입력 관리</h2>
                <p>수많은 유닛이 개별 이벤트를 수신하지 않고, <code>InputManager</code>가 모든 마우스 입력을 통합 관리하여 <code>IInteractable</code> 인터페이스를 구현한 객체에 전달합니다.</p>

                <div class="visual-frame">
                    <div class="arch-diagram">
                        <div class="arch-layer">
                            <div class="arch-layer-title">Input Layer</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">Mouse Input</span>
                                <span class="arch-item">Screen Position</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">InputManager (Central Hub)</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">ScreenToWorldPoint()</span>
                                <span class="arch-item">Physics2D.Raycast()</span>
                                <span class="arch-item">GetInteractableUnderMouse()</span>
                                <span class="arch-item">IsOverUI() 우선순위 판정</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓ Dispatch</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">InteractionHandler</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">HandlePointerEnter/Exit</span>
                                <span class="arch-item">HandlePointerDown/Up</span>
                                <span class="arch-item">HandleDrag</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">IInteractable Objects</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">File_Base (Units)</span>
                                <span class="arch-item">Virus (Enemies)</span>
                                <span class="arch-item">UI Elements</span>
                            </div>
                        </div>
                    </div>
                    <p style="margin-top: 20px; padding: 12px; background: rgba(88, 166, 255, 0.05); border-radius: 6px; border: 1px solid var(--border-color); color: #8b949e; font-size: 0.9rem; line-height: 1.6; text-align: center;">
                        <strong style="color: var(--accent-color);">장점:</strong> 개별 객체가 이벤트를 수신하지 않아 성능 최적화 및 중앙 집중식 관리 가능
                    </p>
                </div>

                <h3>핵심 처리 플로우</h3>
                <p>InputManager는 매 프레임 사용자 입력을 감지해서, 다음 순서로 입력을 처리합니다:</p>

                <div class="visual-frame">
                    <div class="transaction-flow mono" style="margin-bottom: 20px;">
                        <div class="flow-step">HandleHover()<br/>객체 탐지</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-step">HandleMouseInput()<br/>클릭/드래그</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-step">InteractionHandler<br/>이벤트 전달</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-step">IInteractable<br/>객체 처리</div>
                    </div>
                </div>

                <h4>1. 객체 탐지 (GetInteractableUnderMouse)</h4>
                <p>Physics2D.Raycast를 사용하여 마우스 위치의 상호작용 가능한 객체를 탐지합니다. <span class="highlight">레이어 우선순위</span>를 적용하여 Unit 레이어를 먼저 검사하고, 없을 경우 바이러스 등 다른 상호작용 객체를 검사합니다.</p>

                <h4>2. 레이어 우선순위 처리 (IsOverUI)</h4>
                <p>UI와 게임 오브젝트가 겹칠 때, <span class="highlight">SortingLayer와 SortingOrder</span>를 비교하여 정확한 우선순위를 판정합니다. UI Raycast와 GameObject Raycast 결과를 비교하여 UI가 위에 있으면 게임 오브젝트 이벤트를 무시합니다.</p>

                <h4>3. 상태 머신 기반 드래그 처리</h4>
                <p>InputState (None → Pressing → DraggingObject/DraggingBox → None) 기반으로 드래그를 관리합니다. <span class="highlight">dragThreshold</span>를 기반으로 드래그 시작을 판정하며, 객체 드래그와 박스 선택 드래그를 자동으로 구분합니다.</p>

                <div class="visual-frame">
                    <div class="transaction-flow mono" style="margin-bottom: 20px;">
                        <div class="flow-step">None</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-step">Pressing<br/>(거리 &lt; threshold)</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-step">DraggingObject<br/>DraggingBox<br/>(거리 &gt; threshold)</div>
                        <div class="flow-arrow">→</div>
                        <div class="flow-step">None</div>
                    </div>
                </div>

                <h4>4. 더블클릭 감지</h4>
                <p>0.3초 threshold를 사용하여 같은 객체에 대한 연속 클릭을 더블클릭으로 감지합니다.</p>

                <h4>5. 박스 선택 및 바이러스 특수 처리</h4>
                <p>빈 공간에서 드래그 시 <span class="highlight">Physics2D.OverlapAreaAll</span>을 사용하여 영역 내 모든 객체를 선택합니다. 바이러스 드래그는 <code>HasActiveViruses</code> 플래그로 일반 드래그와 구분하여 처리합니다.</p>

                <h3>1.1 기술적 특징</h3>
                <ul>
                    <li><span class="highlight">중앙 집중식 관리:</span> 모든 마우스 입력을 InputManager에서 통합 처리하여 일관된 동작 보장</li>
                    <li><span class="highlight">레이어 우선순위:</span> SortingLayer/SortingOrder 기반 정교한 우선순위 판정으로 UI와 게임 오브젝트 충돌 해결</li>
                    <li><span class="highlight">상태 머신:</span> InputState 기반 명확한 드래그 상태 관리로 복잡한 입력 시나리오 처리</li>
                    <li><span class="highlight">성능 최적화:</span> 개별 객체가 이벤트를 수신하지 않아 오버헤드 감소 및 메모리 효율성 향상</li>
                    <li><span class="highlight">Physics2D 활용:</span> Raycast와 OverlapAreaAll을 통한 효율적인 객체 탐지</li>
                    <li><span class="highlight">더블클릭 감지:</span> 시간 기반 threshold를 통한 정확한 더블클릭 인식</li>
                    <li><span class="highlight">박스 선택:</span> 영역 기반 다중 객체 선택으로 사용자 편의성 향상</li>
                </ul>

                <h2>2. InteractionHandler: 이벤트 기반 상호작용 관리 시스템</h2>
                <p><code>InteractionHandler</code>는 <span class="highlight">이벤트 기반 아키텍처</span>를 통해 InputManager와 IInteractable 객체 간의 상호작용을 중재합니다. 각 객체가 개별적으로 이벤트를 수신하지 않고, InteractionHandler가 모든 상호작용을 통합 관리하여 성능을 최적화하고 일관된 동작을 보장합니다.</p>

                <div class="visual-frame">
                    <div class="arch-diagram">
                        <div class="arch-layer">
                            <div class="arch-layer-title">InputManager</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">GetInteractableUnderMouse()</span>
                                <span class="arch-item">HandleLeftMouseDown()</span>
                                <span class="arch-item">HandleDrag()</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">InteractionHandler (Mediator)</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">HandlePointerDown/Up</span>
                                <span class="arch-item">HandleBeginDrag/EndDrag</span>
                                <span class="arch-item">HandleDoubleClick</span>
                                <span class="arch-item">SelectionData 관리</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">IInteractable Objects</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">OnClick()</span>
                                <span class="arch-item">OnDrag()</span>
                                <span class="arch-item">OnHoverEnter/Exit</span>
                            </div>
                        </div>
                    </div>
                </div>

                <h3>IInteractable 인터페이스: 확장 가능한 상호작용 계약</h3>
                <p>모든 상호작용 가능한 객체는 <code>IInteractable</code> 인터페이스를 구현하여 일관된 상호작용 패턴을 제공합니다.</p>

<pre><code><span class="c-cm">// IInteractable.cs: 상호작용 가능한 객체를 위한 인터페이스</span>
<span class="c-kw">public interface</span> <span class="c-ty">IInteractable</span>
{
    <span class="c-ty">GameObject</span> targetObj { <span class="c-kw">get</span>; }
    <span class="c-ty">Transform</span> transform { <span class="c-kw">get</span>; }
    <span class="c-ty">Sprite</span> TooltipImg { <span class="c-kw">get</span>; }
    <span class="c-ty">string</span> ToolTipDes { <span class="c-kw">get</span>; }
    
    <span class="c-cm">// 선택 상태 관리</span>
    <span class="c-kw">bool</span> IsSelectable { <span class="c-kw">get</span>; }
    <span class="c-kw">bool</span> IsDraggable { <span class="c-kw">get</span>; }
    <span class="c-kw">bool</span> IsTooltipEnabled { <span class="c-kw">get</span>; }
    
    <span class="c-cm">// 이벤트 메서드</span>
    <span class="c-kw">void</span> <span class="c-fn">OnHoverEnter</span>();     <span class="c-cm">// 마우스가 객체 위로 올라올 때</span>
    <span class="c-kw">void</span> <span class="c-fn">OnHoverExit</span>();      <span class="c-cm">// 마우스가 객체에서 벗어날 때</span>
    <span class="c-kw">void</span> <span class="c-fn">OnClickEnter</span>();     <span class="c-cm">// 마우스 버튼을 누를 때</span>
    <span class="c-kw">void</span> <span class="c-fn">OnClickExit</span>();      <span class="c-cm">// 마우스 버튼을 뗄 때</span>
    <span class="c-kw">void</span> <span class="c-fn">OnBeginDrag</span>();       <span class="c-cm">// 드래그 시작</span>
    <span class="c-kw">void</span> <span class="c-fn">OnDrag</span>(<span class="c-ty">Vector2</span> mouseDelta); <span class="c-cm">// 드래그 중</span>
    <span class="c-kw">void</span> <span class="c-fn">OnEndDrag</span>();         <span class="c-cm">// 드래그 종료</span>
    <span class="c-kw">void</span> <span class="c-fn">OnClick</span>();            <span class="c-cm">// 클릭 처리</span>
    <span class="c-kw">void</span> <span class="c-fn">OnDoubleClick</span>();    <span class="c-cm">// 더블클릭 처리</span>
    <span class="c-kw">void</span> <span class="c-fn">OnRightClick</span>();     <span class="c-cm">// 우클릭 처리</span>
    <span class="c-kw">void</span> <span class="c-fn">OnSelectSingle</span>();   <span class="c-cm">// 단일 선택</span>
    <span class="c-kw">void</span> <span class="c-fn">OnSelected</span>(<span class="c-kw">bool</span> isSelected); <span class="c-cm">// 선택 상태 표시</span>
}</code></pre>

                <h3>2.1 IInteractable 인터페이스 기술적 특징</h3>
                <ul>
                    <li><span class="highlight">인터페이스 기반 설계:</span> 다양한 객체 타입(File_Base, Virus, UI)이 동일한 인터페이스로 처리</li>
                    <li><span class="highlight">확장성:</span> 새로운 상호작용 가능한 객체 추가 시 인터페이스만 구현하면 자동 통합</li>
                    <li><span class="highlight">관심사 분리:</span> 각 객체는 자신의 상호작용 로직만 구현, InteractionHandler가 흐름 제어</li>
                    <li><span class="highlight">일관된 API:</span> 모든 상호작용 가능한 객체가 동일한 메서드 시그니처 제공</li>
                    <li><span class="highlight">선택적 기능:</span> IsSelectable, IsDraggable, IsTooltipEnabled를 통한 유연한 기능 제어</li>
                </ul>

                <h3>2.2 InteractionHandler의 핵심 기능</h3>
                <p>InteractionHandler는 선택 상태 관리, 드래그 처리, ToolTip 관리, 바이러스 특수 처리 등을 담당합니다. 단일 클래스에서 모든 상호작용을 관리합니다.</p>

                <h4>2.2.1 기술적 특징</h4>
                <ul>
                    <li><span class="highlight">Mediator 패턴:</span> InputManager와 IInteractable 객체 간의 직접적인 의존성 제거로 느슨한 결합 달성</li>
                    <li><span class="highlight">이벤트 기반 아키텍처:</span> 각 객체가 개별적으로 이벤트를 수신하지 않고 중앙에서 통합 관리</li>
                    <li><span class="highlight">단일 책임 원칙:</span> 모든 상호작용 로직을 단일 클래스에서 관리하여 유지보수성 향상</li>
                    <li><span class="highlight">명확한 메서드 네이밍:</span> OnClickEnterHandler, OnBeginDragHandler 등 직관적인 메서드명</li>
                </ul>

                <div class="visual-frame">
                    <div class="arch-diagram">
                        <div class="arch-layer">
                            <div class="arch-layer-title">포인터 다운 처리</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">OnClickEnter() 호출</span>
                                <span class="arch-item">선택 상태 관리</span>
                                <span class="arch-item">단일/멀티 선택 처리</span>
                                <span class="arch-item">OnClick() 호출</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">드래그 시작 처리</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">선택된 객체만 드래그 대상</span>
                                <span class="arch-item">원본 위치 저장</span>
                                <span class="arch-item">OnBeginDrag() 호출</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">드래그 중 처리</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">각 객체의 OnDrag() 호출</span>
                                <span class="arch-item">위치 이동 처리</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">드래그 종료 처리</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">OnEndDrag() 호출</span>
                                <span class="arch-item">드래그 상태 초기화</span>
                                <span class="arch-item">선택 해제</span>
                            </div>
                        </div>
                    </div>
                </div>

                <h3>2.3 선택 상태 관리 시스템</h3>
                <p>InteractionHandler는 <span class="highlight">Dictionary를 사용한 원본 위치 저장</span>과 <span class="highlight">List 기반 선택 관리</span>를 통해 효율적인 상태 관리를 제공합니다.</p>

                <h4>2.3.1 기술적 특징</h4>
                <ul>
                    <li><span class="highlight">선택 상태 캡슐화:</span> SelectedObjects, DragObjects, OriginalPositions를 통해 선택 상태를 중앙에서 관리</li>
                    <li><span class="highlight">원본 위치 복원:</span> Dictionary를 사용하여 드래그 실패 시 원래 위치로 복원 가능</li>
                    <li><span class="highlight">멀티 선택 지원:</span> Ctrl 키를 통한 토글 방식 멀티 선택으로 사용자 편의성 향상</li>
                    <li><span class="highlight">효율적인 데이터 구조:</span> List와 Dictionary를 조합하여 O(1) 조회 및 순회 성능 확보</li>
                </ul>

                <div class="visual-frame">
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin: 20px 0; align-items: stretch;">
                        <div style="padding: 18px; border: 2px solid var(--accent-color); border-radius: 8px; background: rgba(88, 166, 255, 0.05); text-align: center; display: flex; flex-direction: column; justify-content: flex-start;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">선택 관리</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.8; flex-grow: 1;">
                                <div>• SelectedObjects</div>
                                <div>• 멀티 선택 지원</div>
                                <div>• 단일/다중 선택</div>
                                <div>• Ctrl 키 토글</div>
                            </div>
                        </div>
                        <div style="padding: 18px; border: 2px solid var(--sub-accent); border-radius: 8px; background: rgba(35, 134, 54, 0.05); text-align: center; display: flex; flex-direction: column; justify-content: flex-start;">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">드래그 관리</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.8; flex-grow: 1;">
                                <div>• DragObjects</div>
                                <div>• 원래 위치 저장</div>
                                <div>• 복원 기능</div>
                                <div>• 드래그 상태 추적</div>
                            </div>
                        </div>
                        <div style="padding: 18px; border: 2px solid var(--border-color); border-radius: 8px; background: rgba(0,0,0,0.2); text-align: center; display: flex; flex-direction: column; justify-content: flex-start;">
                            <div style="color: var(--text-color); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">상태 관리</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.8; flex-grow: 1;">
                                <div>• OriginalPositions</div>
                                <div>• 선택 해제</div>
                                <div>• 상태 초기화</div>
                                <div>• 바이러스 처리</div>
                            </div>
                        </div>
                    </div>
                </div>

                <h2>전체 시스템 기술적 특징</h2>
                <p>입력 및 상호작용 시스템의 핵심 기술적 특징입니다.</p>
                <ul>
                    <li><span class="highlight">중앙 집중식 입력 관리:</span> InputManager가 모든 마우스 입력을 통합 처리하여 성능 최적화 및 일관된 동작 보장</li>
                    <li><span class="highlight">Mediator 패턴:</span> InteractionHandler를 통한 InputManager와 IInteractable 객체 간의 느슨한 결합</li>
                    <li><span class="highlight">인터페이스 기반 설계:</span> IInteractable 인터페이스를 통한 확장 가능한 상호작용 시스템</li>
                    <li><span class="highlight">레이어 우선순위:</span> SortingLayer/SortingOrder 기반 정교한 UI와 게임 오브젝트 우선순위 판정</li>
                    <li><span class="highlight">상태 머신:</span> InputState 기반 명확한 드래그 상태 관리로 복잡한 입력 시나리오 처리</li>
                    <li><span class="highlight">선택 상태 관리:</span> Dictionary와 List를 활용한 효율적인 멀티 선택 및 원본 위치 복원</li>
                    <li><span class="highlight">박스 선택:</span> Physics2D.OverlapAreaAll을 통한 영역 기반 다중 객체 선택</li>
                    <li><span class="highlight">ToolTip 통합:</span> StageMain_UI와 연동한 지연 표시 ToolTip 시스템</li>
                    <li><span class="highlight">바이러스 특수 처리:</span> HasActiveViruses 플래그를 통한 일반 드래그와의 구분 처리</li>
                </ul>

                <div style="height: 100px;"></div>
            </div>
        </div>
    </div>

    <!-- ML-Agents Racing Modal -->
    <div id="modal-overlay-racing" class="modal-overlay" onclick="closeModal('racing')">
        <div class="modal-container" onclick="event.stopPropagation()">
            <div class="modal-body">
                <div class="modal-header-nav">
                    <div class="mono" style="color: var(--accent-color);">PROJECT REPORT // AUTONOMOUS_RACING_AGENT</div>
                    <button onclick="closeModal('racing')" style="background: none; border: 1px solid var(--accent-color); color: var(--accent-color); padding: 8px 20px; border-radius: 6px; cursor: pointer; font-family: 'Fira Code'; font-size: 0.8rem;">[X] DISCONNECT</button>
                </div>
                
                <h1 style="font-size: 2.5rem; margin-bottom: 30px; color: #f0f6fc;">ML-Agents 자율 주행 경주차 학습 시스템</h1>

                <div class="visual-frame" style="margin: 30px 0;">
                    <img src="Gifs/제목 없는 비디오 - Clipchamp로 제작.gif" alt="ML-Agents 학습 시각화" style="width: 100%; border-radius: 8px; border: 2px solid var(--border-color);">
                </div>

                <h2>1. 프로젝트 개요</h2>
                <p>Unity ML-Agents를 활용하여 정해진 트랙을 안정적으로 주행하는 자율 주행 경주차 에이전트를 학습시킨 프로젝트입니다. <span class="highlight">체크포인트 기반 네비게이션 시스템</span>과 <span class="highlight">목표 지향 보상 설계</span>를 통해 에이전트가 트랙을 순차적으로 주행하도록 설계했습니다.</p>

                <div class="visual-frame" style="margin: 30px 0;">
                    <img src="images/mlagent_4.png" alt="ML-Agents 트랙 환경" style="width: 100%; border-radius: 8px; border: 2px solid var(--border-color);">
                    <p style="text-align: center; color: #8b949e; font-size: 0.9rem; margin-top: 10px;">구불구불한 도로와 바위 지형으로 구성된 학습 트랙 환경</p>
                </div>

                <div class="tab-container">
                    <button class="tab-button active" onclick="switchTabML('navigation')">체크포인트 및 보상 시스템</button>
                    <button class="tab-button" onclick="switchTabML('sensing')">환경 감지 및 행동 결정</button>
                    <button class="tab-button" onclick="switchTabML('training')">ML-Agents 학습 설정</button>
                </div>

                <div id="ml-navigation-tab" class="tab-content active">
                <h2>2. 체크포인트 기반 네비게이션 시스템</h2>
                <div style="background: linear-gradient(135deg, rgba(255, 193, 7, 0.1) 0%, rgba(255, 152, 0, 0.1) 100%); border-left: 4px solid #ff9800; padding: 15px 20px; margin: 20px 0; border-radius: 6px;">
                    <p style="margin: 0; color: #e0e0e0;"><strong style="color: #ff9800;">시행착오 및 문제 해결:</strong></p>
                    <p style="margin: 10px 0 0 0; color: #c9d1d9;">초기 설계에서는 차량 Agent들이 자율주행을 수행할 때 <span class="highlight">역주행 현상</span>이 빈번하게 발생했습니다. 목표 지점까지의 최단 경로를 찾는 과정에서 에이전트가 트랙을 거꾸로 주행하거나, 잘못된 방향으로 이동하는 문제가 있었습니다. 이를 해결하기 위해 <span class="highlight">목표 지점까지의 여러 체크포인트를 순차적으로 배치</span>하여 에이전트가 반드시 앞으로 주행하도록 강제하는 시스템을 설계했습니다.</p>
                </div>
                <p>에이전트가 트랙을 올바른 순서로 주행하도록 <span class="highlight">체크포인트 시스템</span>을 구현했습니다. 각 체크포인트를 순차적으로 통과해야 다음 목표로 진행할 수 있으며, 잘못된 순서로 통과 시 페널티를 받습니다.</p>

                <div class="visual-frame">
                    <div class="arch-diagram">
                        <div class="arch-layer">
                            <div class="arch-layer-title">SplineToCheckpointGenerator</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">스플라인에서 체크포인트 자동 생성</span>
                                <span class="arch-item">BoxCollider(Trigger) 설정</span>
                                <span class="arch-item">태그 자동 할당</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">SpawnPointManager</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">체크포인트 배열 관리</span>
                                <span class="arch-item">스폰 포인트 관리</span>
                                <span class="arch-item">Finish 포인트 관리</span>
                            </div>
                        </div>
                        <div style="text-align: center; color: var(--accent-color); font-size: 1.5rem; padding: 10px 0; font-weight: 700;">↓</div>
                        <div class="arch-layer">
                            <div class="arch-layer-title">SimcadeCarAgent_Auto</div>
                            <div class="arch-layer-items">
                                <span class="arch-item">체크포인트 통과 감지</span>
                                <span class="arch-item">목표 위치 계산</span>
                                <span class="arch-item">거리 기반 보상</span>
                            </div>
                        </div>
                    </div>
                </div>

                <h3>CheckPoint: 순차적 체크포인트 검증</h3>
                <p><code>CheckPoint</code>는 트리거를 통해 플레이어가 올바른 순서의 체크포인트를 통과했는지 검증합니다. 마지막 체크포인트 통과 시 랩을 증가시키고 체크포인트를 리셋합니다.</p>

<pre><code><span class="c-cm">// CheckPoint.cs: 체크포인트 트리거 처리</span>
<span class="c-kw">private void</span> <span class="c-fn">OnTriggerEnter</span>(<span class="c-ty">Collider</span> other)
{
    <span class="c-kw">if</span> (other.CompareTag(<span class="c-st">"Player"</span>)) {
        <span class="c-ty">CarProgress</span> progress = other.GetComponentInParent&lt;<span class="c-ty">CarProgress</span>&gt;();
        
        <span class="c-cm">// 올바른 순서의 체크포인트인지 확인</span>
        <span class="c-kw">if</span> (progress.currentCheckPoint + <span class="c-st">1</span> == checkPointIndex) {
            progress.currentCheckPoint = checkPointIndex;
        }
        <span class="c-cm">// 마지막 체크포인트 통과 시 랩 증가</span>
        <span class="c-kw">else if</span> (isLast) {
            progress.currentCheckPoint = <span class="c-st">0</span>;
            progress.currentLap++;
        }
    }
}</code></pre>

                <h3>SplineToCheckpointGenerator: 스플라인 기반 자동 생성</h3>
                <p>Unity Spline 시스템을 활용하여 트랙의 스플라인 곡선을 따라 체크포인트를 자동으로 생성합니다. 이를 통해 다양한 트랙에 빠르게 체크포인트 시스템을 적용할 수 있습니다.</p>

                <h3>SpawnPointManager: 다중 스폰 포인트 관리</h3>
                <p>학습 시 다양한 시작 위치에서 에피소드를 시작할 수 있도록 <span class="highlight">다중 스폰 포인트 시스템</span>을 구현했습니다. 스플라인 시작 지점을 기준으로 횡방향으로 여러 스폰 포인트를 자동 생성합니다.</p>

                <h2>3. 보상 설계 (Reward Engineering)</h2>
                <p>에이전트가 올바르게 트랙을 주행하도록 <span class="highlight">다층적 보상 시스템</span>을 설계했습니다.</p>

                <div class="visual-frame">
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin: 20px 0; align-items: stretch;">
                        <div style="padding: 18px; border: 2px solid var(--sub-accent); border-radius: 8px; background: rgba(35, 134, 54, 0.05); text-align: center;">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">목표 지향 보상</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.8;">
                                <div>• 체크포인트 통과: +1.0</div>
                                <div>• Finish 통과: +10.0</div>
                                <div>• 거리 감소 보상</div>
                                <div>• 잘못된 체크포인트: -0.5</div>
                            </div>
                        </div>
                        <div style="padding: 18px; border: 2px solid #ff7b72; border-radius: 8px; background: rgba(255, 123, 114, 0.05); text-align: center;">
                            <div style="color: #ff7b72; font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">안전성 페널티</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.8;">
                                <div>• 벽 충돌: -1.0</div>
                                <div>• 근접 페널티 (전방/후방)</div>
                                <div>• 미끄러짐 페널티</div>
                                <div>• 역주행 페널티: -0.2</div>
                            </div>
                        </div>
                    </div>
                </div>

                <h3>목표 지향 보상 (Goal-Oriented Rewards)</h3>
                <p>에이전트가 체크포인트를 순차적으로 통과하고 목표 지점에 도달하도록 설계된 보상 시스템입니다.</p>

<pre><code><span class="c-cm">// SimcadeCarAgent_Auto.cs: 목표 지향 보상 설정</span>
<span class="c-kw">[Header</span>(<span class="c-st">"Goal-Oriented Rewards (NEW)"</span>)<span class="c-kw">]</span>
<span class="c-kw">public float</span> distanceRewardFactor = <span class="c-st">0.1f</span>;        <span class="c-cm">// 다음 체크포인트에 가까워질 때 보상 계수</span>
<span class="c-kw">public float</span> checkpointReward = <span class="c-st">1.0f</span>;            <span class="c-cm">// 체크포인트 통과 시 보상</span>
<span class="c-kw">public float</span> wrongCheckpointPenalty = -<span class="c-st">0.5f</span>;    <span class="c-cm">// 잘못된 체크포인트 통과 시 페널티</span>
<span class="c-kw">public float</span> finishReward = <span class="c-st">10.0f</span>;              <span class="c-cm">// Finish 라인 통과 시 최종 보상</span>

<span class="c-cm">// 거리 기반 보상 계산</span>
<span class="c-kw">float</span> distanceReward = (lastDistanceToTarget - distanceToTarget) * distanceRewardFactor;
<span class="c-ty">AddReward</span>(distanceReward);  <span class="c-cm">// 목표에 가까워질수록 보상 증가</span></code></pre>

                <ul>
                    <li><span class="highlight">거리 기반 보상:</span> 다음 체크포인트에 가까워질수록 보상 (distanceRewardFactor: 0.1) - 매 프레임 계산</li>
                    <li><span class="highlight">체크포인트 통과:</span> 올바른 순서로 통과 시 <code style="color: var(--sub-accent);">+1.0</code>, 잘못된 순서 <code style="color: #ff7b72;">-0.5</code></li>
                    <li><span class="highlight">Finish 라인:</span> 모든 체크포인트 통과 후 Finish 통과 시 <code style="color: var(--sub-accent);">+10.0</code> (최대 보상)</li>
                    <li><span class="highlight">Finish 우회 방지:</span> 체크포인트를 다 통과하지 않고 Finish 도달 시 <code style="color: #ff7b72;">-2.5</code> (wrongCheckpointPenalty × 5)</li>
                </ul>

                <h3>생존 및 기본 보상 (Survival Rewards)</h3>
                <p>에이전트가 지속적으로 전진하고 시간 낭비를 방지하도록 설계된 보상 시스템입니다.</p>

<pre><code><span class="c-cm">// SimcadeCarAgent_Auto.cs: 생존 보상 설정</span>
<span class="c-kw">[Header</span>(<span class="c-st">"Reward Settings (Autonomous)"</span>)<span class="c-kw">]</span>
<span class="c-kw">public float</span> forwardSpeedReward = <span class="c-st">0.01f</span>;  <span class="c-cm">// 전진 속도 보상 계수</span>

<span class="c-kw">[Header</span>(<span class="c-st">"Reward Settings (Survival)"</span>)<span class="c-kw">]</span>
<span class="c-kw">public float</span> timePenalty = -<span class="c-st">0.001f</span>;  <span class="c-cm">// 시간 페널티 (매 프레임)</span>

<span class="c-cm">// 전진 속도 보상 계산</span>
<span class="c-kw">float</span> forwardSpeed = <span class="c-ty">Vector3</span>.<span class="c-fn">Dot</span>(rb.linearVelocity, transform.forward);
<span class="c-kw">if</span> (forwardSpeed > <span class="c-st">0.5f</span> && !isStuckInWall) {
    <span class="c-ty">AddReward</span>(forwardSpeedReward * (forwardSpeed / vehicleController.MaxSpeed));
}</code></pre>

                <ul>
                    <li><span class="highlight">시간 페널티:</span> 매 프레임마다 <code style="color: #ff7b72;">-0.001</code> (빠른 주행 유도)</li>
                    <li><span class="highlight">전진 속도 보상:</span> 전진 속도가 0.5 이상일 때, 최대 속도 대비 비율로 보상 (최대 <code style="color: var(--sub-accent);">+0.01</code>)</li>
                    <li><span class="highlight">정지 상태 감지:</span> 속도 0.5 미만일 때 정지 상태 체크 시작</li>
                </ul>

                <h3>안전성 및 복구 보상 (Safety & Recovery Rewards)</h3>
                <p>에이전트가 안전하게 주행하고 위험 상황을 회피하도록 설계된 페널티 및 복구 보상 시스템입니다.</p>

<pre><code><span class="c-cm">// SimcadeCarAgent_Auto.cs: 안전성 보상 설정</span>
<span class="c-kw">[Header</span>(<span class="c-st">"Safety Reward Settings"</span>)<span class="c-kw">]</span>
<span class="c-kw">public float</span> slipPenalty = -<span class="c-st">0.005f</span>;           <span class="c-cm">// 미끄러짐 페널티 계수</span>
<span class="c-kw">public float</span> slipThreshold = <span class="c-st">0.9f</span>;              <span class="c-cm">// 드리프트 허용 임계값</span>

<span class="c-kw">[Header</span>(<span class="c-st">"Proximity Penalty Settings (NEW)"</span>)<span class="c-kw">]</span>
<span class="c-kw">public float</span> proximityPenalty = -<span class="c-st">0.015f</span>;      <span class="c-cm">// 전방 벽 근접 페널티 계수</span>
<span class="c-kw">public float</span> rearProximityPenalty = -<span class="c-st">0.02f</span>;  <span class="c-cm">// 후방 벽 근접 페널티 계수</span>

<span class="c-kw">[Header</span>(<span class="c-st">"Wrong Way Driving Penalty (NEW)"</span>)<span class="c-kw">]</span>
<span class="c-kw">public float</span> wrongWayPenalty = -<span class="c-st">0.2f</span>;          <span class="c-cm">// 역주행 페널티 계수</span>
<span class="c-kw">public float</span> wrongWaySpeedThreshold = <span class="c-st">1.5f</span>;  <span class="c-cm">// 역주행 감지 최소 속도</span>
<span class="c-kw">public float</span> wrongWayDotThreshold = -<span class="c-st">0.866f</span>;  <span class="c-cm">// 역주행 감지 각도 (약 150도)</span>

<span class="c-kw">[Header</span>(<span class="c-st">"Recovery Reward Settings"</span>)<span class="c-kw">]</span>
<span class="c-kw">public float</span> wallCollisionPenalty = -<span class="c-st">1.0f</span>;      <span class="c-cm">// 벽 충돌 페널티</span>
<span class="c-kw">public float</span> stuckPenaltyPerSecond = -<span class="c-st">0.5f</span>;  <span class="c-cm">// 벽에 막힌 상태 초당 페널티</span>
<span class="c-kw">public float</span> reverseReward = <span class="c-st">0.01f</span>;            <span class="c-cm">// 벽에 막혔을 때 후진 보상</span></code></pre>

                <h4>근접 페널티 (Proximity Penalty)</h4>
                <ul>
                    <li><span class="highlight">전방 벽 감지:</span> 15m 이내 벽 감지 시 거리 기반 페널티 (최대 <code style="color: #ff7b72;">-0.015</code> per frame)</li>
                    <li><span class="highlight">후방 벽 감지:</span> 후진 중 5m 이내 벽 감지 시 거리 기반 페널티 (최대 <code style="color: #ff7b72;">-0.02</code> per frame)</li>
                    <li><span class="highlight">구현 상세:</span> 레이캐스트 기반 근접 페널티 계산 로직은 "환경 감지 및 행동 결정" 탭에서 확인 가능</li>
                </ul>

                <h4>역주행 감지 (Wrong Way Detection)</h4>
                <ul>
                    <li><span class="highlight">역주행 페널티:</span> 목표 방향과 반대 방향 주행 시 <code style="color: #ff7b72;">-0.2</code> per frame</li>
                    <li><span class="highlight">감지 조건:</span> 
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            <li>전진 속도 ≥ 1.5 (wrongWaySpeedThreshold)</li>
                            <li>목표 방향과 차량 방향의 Dot Product < -0.866 (약 150도 이상 차이)</li>
                        </ul>
                    </li>
                    <li><span class="highlight">후진 처리:</span> 벽에 막혔을 때 후진은 <code style="color: var(--sub-accent);">+0.01</code> 보상, 그 외 후진은 거리 증가 시 페널티</li>
                </ul>

                <h4>미끄러짐 및 안정성 (Slip & Stability)</h4>
                <ul>
                    <li><span class="highlight">미끄러짐 페널티:</span> 평균 슬립 계수 0.9 이상 시 <code style="color: #ff7b72;">-0.005 × avgSlipCoeff</code> (드리프트 차량 특성 고려)</li>
                    <li><span class="highlight">드리프트 허용:</span> 슬립 임계값을 0.9로 설정하여 드리프트 주행 허용</li>
                </ul>

                <h4>정지 및 뒤집힘 감지 (Stagnation & Flip Detection)</h4>
                <ul>
                    <li><span class="highlight">정지 상태:</span> 
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            <li>2초 이상 정지: <code style="color: #ff7b72;">-0.02 × (duration/2)</code> (지속 시간에 비례)</li>
                            <li>5초 이상 정지: <code style="color: #ff7b72;">-5.0</code> + 에피소드 종료</li>
                        </ul>
                    </li>
                    <li><span class="highlight">뒤집힘 감지:</span> 
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            <li>160도 이상 기울어지면 감지 시작</li>
                            <li>2초 이상 지속: <code style="color: #ff7b72;">-0.05</code> per frame</li>
                            <li>5초 이상 지속: <code style="color: #ff7b72;">-3.0</code> + 에피소드 종료</li>
                        </ul>
                    </li>
                </ul>

                <h4>충돌 및 복구 (Collision & Recovery)</h4>
                <ul>
                    <li><span class="highlight">벽 충돌:</span> 벽과 충돌 시 즉시 <code style="color: #ff7b72;">-1.0</code> 페널티</li>
                    <li><span class="highlight">벽에 막힘:</span> 
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            <li>1초 이상 막힘: <code style="color: #ff7b72;">-0.5</code> per second</li>
                            <li>10초 이상 막힘: <code style="color: #ff7b72;">-5.0</code> + 에피소드 종료</li>
                        </ul>
                    </li>
                    <li><span class="highlight">맵 밖 낙하:</span> FallZone 감지 시 <code style="color: #ff7b72;">-5.0</code> + 에피소드 종료</li>
                    <li><span class="highlight">속도 부족:</span> 속도 0.1 미만일 때 <code style="color: #ff7b72;">-0.001</code> per frame</li>
                </ul>

                <h2>전체 시스템 기술적 특징</h2>
                <p>체크포인트 및 보상 시스템의 핵심 기술적 특징입니다.</p>
                <ul>
                    <li><span class="highlight">체크포인트 기반 네비게이션:</span> 순차적 체크포인트 통과를 통한 정확한 트랙 주행</li>
                    <li><span class="highlight">목표 지향 보상 설계:</span> 거리 기반 보상과 체크포인트 보상을 통한 효과적인 학습</li>
                    <li><span class="highlight">안전성 보상:</span> 근접 페널티, 역주행 감지, 미끄러짐 감지로 안전한 주행 유도</li>
                    <li><span class="highlight">스플라인 기반 자동 생성:</span> 다양한 트랙에 빠르게 체크포인트 시스템 적용</li>
                </ul>
                </div>

                <div id="ml-sensing-tab" class="tab-content">
                <h2>3. 레이캐스트 기반 환경 감지</h2>
                <p>에이전트가 주변 환경을 정확히 인식할 수 있도록 <span class="highlight">다방향 레이캐스트 시스템</span>을 구현했습니다. 전방 9개, 후방 3개의 레이를 사용하여 도로와 벽을 감지하고, 이를 신경망의 관측 데이터로 변환합니다.</p>

                <div class="visual-frame" style="margin: 30px 0;">
                    <img src="images/mlagent_1.png" alt="레이캐스트 센서 시각화" style="width: 100%; border-radius: 8px; border: 2px solid var(--border-color);">
                    <p style="text-align: center; color: #8b949e; font-size: 0.9rem; margin-top: 10px;">차량의 레이캐스트 센서 시스템 시각화 (빨간색: 감지된 대상, 초록색: 일반 센서 범위, 체크포인트 및 경로 스플라인 표시)</p>
                </div>

                <div class="visual-frame">
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin: 20px 0; align-items: stretch;">
                        <div style="padding: 18px; border: 2px solid var(--accent-color); border-radius: 8px; background: rgba(88, 166, 255, 0.05); text-align: center;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">전방 감지</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.8;">
                                <div>• 레이 개수: 9개</div>
                                <div>• 각도 범위: 180도</div>
                                <div>• 감지 거리: 15m</div>
                                <div>• 도로/벽 감지</div>
                            </div>
                        </div>
                        <div style="padding: 18px; border: 2px solid var(--sub-accent); border-radius: 8px; background: rgba(35, 134, 54, 0.05); text-align: center;">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">후방 감지</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.8;">
                                <div>• 레이 개수: 3개</div>
                                <div>• 각도 범위: 60도</div>
                                <div>• 감지 거리: 5m</div>
                                <div>• 후진 시 활성화</div>
                            </div>
                        </div>
                        <div style="padding: 18px; border: 2px solid var(--border-color); border-radius: 8px; background: rgba(0,0,0,0.2); text-align: center;">
                            <div style="color: var(--text-color); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code'; font-size: 0.95rem; border-bottom: 1px solid var(--border-color); padding-bottom: 8px;">관측 데이터</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.8;">
                                <div>• 속도/각속도 (7)</div>
                                <div>• 레이캐스트 (21)</div>
                                <div>• 목표 방향/거리 (4)</div>
                                <div>• 총 36차원</div>
                            </div>
                        </div>
                    </div>
                </div>

                <h3>레이캐스트 설정 및 초기화</h3>
                <p>에이전트 초기화 시 전방과 후방 레이의 방향을 계산하여 저장합니다. <span class="highlight">전방 레이</span>는 180도 범위(-90도 ~ +90도)에 9개의 레이를 균등하게 배치하며, 각 레이는 <code>Quaternion.Euler</code>를 사용하여 회전된 방향 벡터로 계산됩니다. <span class="highlight">후방 레이</span>는 60도 범위(-30도 ~ +30도)에 3개의 레이를 배치하여 후진 시 벽 감지에 활용합니다. 도로 감지 레이는 전방 벽 감지 레이와 동일한 방향을 사용하여 효율성을 높였습니다.</p>
                <p>레이캐스트 설정은 다음과 같이 구성됩니다:</p>
                <ul>
                    <li><span class="highlight">도로 레이어:</span> 도로 감지용 레이어 마스크, 최대 감지 거리 50m</li>
                    <li><span class="highlight">벽 레이어:</span> 벽/장애물 감지용 레이어 마스크</li>
                    <li><span class="highlight">전방 벽 감지:</span> 최대 거리 15m (브레이크 성능 고려), 레이 개수 9개</li>
                    <li><span class="highlight">후방 벽 감지:</span> 최대 거리 5m, 레이 개수 3개</li>
                </ul>

                <h3>관측 데이터 수집 (CollectObservations)</h3>
                <p>매 프레임마다 레이캐스트를 수행하여 환경 정보를 수집하고, 정규화된 거리 값을 신경망의 관측 벡터에 추가합니다.</p>

<pre><code><span class="c-cm">// SimcadeCarAgent_Auto.cs: 관측 데이터 수집</span>
<span class="c-kw">public override void</span> <span class="c-fn">CollectObservations</span>(<span class="c-ty">VectorSensor</span> sensor)
{
    <span class="c-cm">// 기본 관측 데이터 (10차원)</span>
    sensor.<span class="c-fn">AddObservation</span>(transform.<span class="c-fn">InverseTransformDirection</span>(rb.linearVelocity));      <span class="c-cm">// 3: 선속도 (로컬 좌표)</span>
    sensor.<span class="c-fn">AddObservation</span>(transform.<span class="c-fn">InverseTransformDirection</span>(rb.angularVelocity));  <span class="c-cm">// 3: 각속도 (로컬 좌표)</span>
    <span class="c-kw">float</span> normalizedSpeed = rb.linearVelocity.magnitude / vehicleController.MaxSpeed;
    sensor.<span class="c-fn">AddObservation</span>(normalizedSpeed);  <span class="c-cm">// 1: 정규화된 속도</span>
    sensor.<span class="c-fn">AddObservation</span>(vehicleController.vehicleIsGrounded ? <span class="c-st">1f</span> : <span class="c-st">0f</span>);  <span class="c-cm">// 1: 지면 접촉 여부</span>
    sensor.<span class="c-fn">AddObservation</span>(lastSteeringInput);      <span class="c-cm">// 1: 이전 조향 입력</span>
    sensor.<span class="c-fn">AddObservation</span>(lastAccelerationInput);  <span class="c-cm">// 1: 이전 가속 입력</span>

    <span class="c-cm">// 상태 관측 (1차원)</span>
    sensor.<span class="c-fn">AddObservation</span>(isStuckInWall ? <span class="c-st">1f</span> : <span class="c-st">0f</span>);  <span class="c-cm">// 1: 벽에 막혔는지 여부</span>

    <span class="c-cm">// 레이캐스트 관측 (9 + 9 + 3 = 21차원)</span>
    <span class="c-fn">AddRaycastObservations</span>(sensor, roadRayDirections, roadLayer, roadRayDistance);        <span class="c-cm">// 9: 도로 감지</span>
    <span class="c-fn">AddRaycastObservations</span>(sensor, wallRayDirections, wallLayer, wallProximityDistance);      <span class="c-cm">// 9: 전방 벽 감지</span>
    <span class="c-fn">AddRaycastObservations</span>(sensor, rearWallRayDirections, wallLayer, rearWallProximityDistance);  <span class="c-cm">// 3: 후방 벽 감지</span>

    <span class="c-cm">// 목표 지향 관측 (4차원)</span>
    <span class="c-ty">Vector3</span> targetPosition = <span class="c-fn">GetTargetPosition</span>();  <span class="c-cm">// 다음 체크포인트 또는 Finish 위치</span>
    <span class="c-ty">Vector3</span> targetDirLocal = transform.<span class="c-fn">InverseTransformPoint</span>(targetPosition);
    sensor.<span class="c-fn">AddObservation</span>(targetDirLocal.normalized);  <span class="c-cm">// 3: 목표 방향 (로컬 좌표)</span>
    sensor.<span class="c-fn">AddObservation</span>(targetDirLocal.magnitude / roadRayDistance);  <span class="c-cm">// 1: 정규화된 목표 거리</span>

    <span class="c-cm">// 총 관측 차원: 10 + 1 + 21 + 4 = 36차원</span>
}</code></pre>

                <h3>레이캐스트 관측 헬퍼 함수</h3>
                <p>각 레이 방향에 대해 Physics.Raycast를 수행하고, 감지된 거리를 정규화하여 관측 벡터에 추가합니다.</p>

<pre><code><span class="c-cm">// SimcadeCarAgent_Auto.cs: 레이캐스트 관측 헬퍼 함수</span>
<span class="c-kw">private void</span> <span class="c-fn">AddRaycastObservations</span>(<span class="c-ty">VectorSensor</span> sensor, <span class="c-ty">Vector3</span>[] directions, <span class="c-ty">LayerMask</span> layer, <span class="c-kw">float</span> distance)
{
    <span class="c-kw">for</span> (<span class="c-kw">int</span> i = <span class="c-st">0</span>; i < directions.Length; i++) {
        <span class="c-cm">// 로컬 방향을 월드 방향으로 변환</span>
        <span class="c-ty">Vector3</span> worldRayDir = transform.<span class="c-fn">TransformDirection</span>(directions[i]);
        
        <span class="c-cm">// 레이캐스트 수행</span>
        <span class="c-kw">if</span> (<span class="c-ty">Physics</span>.<span class="c-fn">Raycast</span>(transform.position, worldRayDir, <span class="c-kw">out</span> <span class="c-ty">RaycastHit</span> hit, distance, layer)) {
            <span class="c-cm">// 감지된 경우: 거리를 정규화 (0.0 ~ 1.0, 가까울수록 작은 값)</span>
            sensor.<span class="c-fn">AddObservation</span>(hit.distance / distance);
        } <span class="c-kw">else</span> {
            <span class="c-cm">// 감지되지 않은 경우: 1.0 (최대 거리)</span>
            sensor.<span class="c-fn">AddObservation</span>(<span class="c-st">1f</span>);
        }
    }
}</code></pre>

                <h3>근접 페널티 계산 (Proximity Penalty)</h3>
                <p>벽에 가까워질수록 페널티를 부여하여 에이전트가 안전 거리를 유지하도록 유도합니다. 거리가 가까울수록 페널티가 급증하는 비선형 함수를 사용합니다.</p>

<pre><code><span class="c-cm">// SimcadeCarAgent_Auto.cs: 근접 페널티 계산</span>
<span class="c-kw">private void</span> <span class="c-fn">ApplyProximityPenalty</span>(<span class="c-ty">Vector3</span>[] directions, <span class="c-ty">LayerMask</span> layer, <span class="c-kw">float</span> distance, <span class="c-kw">float</span> penaltyCoefficient)
{
    <span class="c-kw">for</span> (<span class="c-kw">int</span> i = <span class="c-st">0</span>; i < directions.Length; i++) {
        <span class="c-ty">Vector3</span> worldRayDir = transform.<span class="c-fn">TransformDirection</span>(directions[i]);
        
        <span class="c-kw">if</span> (<span class="c-ty">Physics</span>.<span class="c-fn">Raycast</span>(transform.position, worldRayDir, <span class="c-kw">out</span> <span class="c-ty">RaycastHit</span> hit, distance, layer)) {
            <span class="c-cm">// 거리 기반 페널티 계산: 가까울수록 페널티 급증</span>
            <span class="c-cm">// penalty = penaltyCoefficient × (1 - distance/maxDistance)</span>
            <span class="c-cm">// 예: distance=0이면 penalty=penaltyCoefficient, distance=maxDistance이면 penalty=0</span>
            <span class="c-kw">float</span> penalty = penaltyCoefficient * (<span class="c-st">1f</span> - (hit.distance / distance));
            
            <span class="c-cm">// FixedUpdate 주기에 맞춰 스케일링</span>
            <span class="c-ty">AddReward</span>(penalty * <span class="c-ty">Time</span>.fixedDeltaTime);
        }
    }
}

<span class="c-cm">// CalculateRewards()에서 호출</span>
<span class="c-kw">private void</span> <span class="c-fn">CalculateRewards</span>()
{
    <span class="c-cm">// 전방 벽 근접 페널티 (항상 적용)</span>
    <span class="c-fn">ApplyProximityPenalty</span>(wallRayDirections, wallLayer, wallProximityDistance, proximityPenalty);
    <span class="c-cm">// proximityPenalty = -0.015f, wallProximityDistance = 15f</span>

    <span class="c-kw">float</span> forwardSpeed = <span class="c-ty">Vector3</span>.<span class="c-fn">Dot</span>(rb.linearVelocity, transform.forward);
    <span class="c-kw">if</span> (forwardSpeed < -<span class="c-st">0.1f</span>) {
        <span class="c-cm">// 후진 중일 때만 후방 벽 근접 페널티 적용</span>
        <span class="c-fn">ApplyProximityPenalty</span>(rearWallRayDirections, wallLayer, rearWallProximityDistance, rearProximityPenalty);
        <span class="c-cm">// rearProximityPenalty = -0.02f, rearWallProximityDistance = 5f</span>
    }
}</code></pre>

                <h3>기술적 특징</h3>
                <ul>
                    <li><span class="highlight">다방향 감지:</span> 전방 180도(9개 레이), 후방 60도(3개 레이)로 넓은 범위의 환경 인식</li>
                    <li><span class="highlight">레이어 분리:</span> 도로 레이어와 벽 레이어를 분리하여 각각 다른 용도로 활용 (도로: 50m, 벽: 15m/5m)</li>
                    <li><span class="highlight">정규화된 관측:</span> 모든 거리 값을 0.0~1.0 범위로 정규화하여 신경망 학습 안정성 향상</li>
                    <li><span class="highlight">비선형 페널티:</span> 거리 기반 비선형 페널티 함수로 가까울수록 급격한 페널티 증가</li>
                    <li><span class="highlight">조건부 후방 감지:</span> 후진 중일 때만 후방 레이캐스트 페널티 적용하여 효율성 향상</li>
                    <li><span class="highlight">전방 감지 거리 최적화:</span> 브레이크 성능을 고려하여 15m 거리에서 미리 감지하도록 설정</li>
                </ul>

                <h2>4. 연속적 행동 결정 및 입력 보정</h2>
                <p>수집된 관측 정보는 신경망을 통과하여 차량을 제어하기 위한 행동 값으로 변환됩니다.</p>

                <h3>연속적 제어 (Continuous Control)</h3>
                <p>본 프로젝트의 시스템은 불연속적인 이동이 아닌, 차량의 <span class="highlight">조향과 가속/감속을 정밀하게 제어하는 연속 행동 공간</span>을 사용합니다. ML-Agents의 <code>ContinuousActions</code>를 통해 -1.0부터 1.0까지의 연속적인 실수 값을 출력하여, 차량의 핸들 각도와 가속 페달을 부드럽게 제어할 수 있습니다.</p>

                <h3>입력 스무딩 (Input Smoothing)</h3>
                <p>강화학습 초기 단계에서 발생하는 무작위적이고 급격한 지터링을 방지하기 위해, 에이전트의 행동 결정 단계에서 <span class="highlight">입력 스무딩 알고리즘</span>을 적용하였습니다. 이를 통해 직전 프레임에서 차량에 적용된 최종 제어값과 현재 신경망이 출력한 목표값의 차이를 계산하고, 보정된 현재 프레임의 최종 제어값을 차량 컨트롤러에 전달함으로써, 실제 차량과 유사한 부드러운 주행 궤적과 물리적 관성을 구현하였습니다.</p>

                <div class="visual-frame" style="margin: 30px 0;">
                    <img src="images/mlagent_3.png" alt="입력 스무딩 알고리즘 시각화" style="width: 100%; border-radius: 8px; border: 2px solid var(--border-color);">
                    <p style="text-align: center; color: #8b949e; font-size: 0.9rem; margin-top: 10px;">입력 스무딩 알고리즘 시각화: AI의 원시 판단과 이전 상태를 비교하여 부드러운 최종 명령 생성</p>
                </div>

                <div style="background: rgba(88, 166, 255, 0.1); border-left: 4px solid var(--accent-color); padding: 15px 20px; margin: 20px 0; border-radius: 6px;">
                    <p style="margin: 0 0 10px 0; color: var(--accent-color); font-weight: 700;">변수 설명:</p>
                    <ul style="margin: 0; padding-left: 20px; color: #c9d1d9;">
                        <li><code style="color: var(--accent-color);">rawSteering</code>: 신경망이 현재 상황을 보고 판단하여 설정한 차량의 조향 변수 (원시 조향값)</li>
                        <li><code style="color: var(--accent-color);">lastSteeringInput</code>: 이전 프레임의 조향값 (마지막으로 차량에 적용된 최종 조향값)</li>
                        <li><code style="color: var(--accent-color);">steeringInput</code>: 입력 스무딩 알고리즘을 통한 산출 최종 조향값 (차량의 핸들 값으로 사용)</li>
                    </ul>
                </div>

<pre><code><span class="c-cm">// SimcadeCarAgent_Auto.cs: 연속적 행동 결정 및 입력 보정</span>
<span class="c-kw">[Header</span>(<span class="c-st">"Action Smoothing"</span>)<span class="c-kw">]</span>
<span class="c-kw">public float</span> maxSteeringChange = <span class="c-st">0.5f</span>;      <span class="c-cm">// 최대 조향 변화량 (프레임당)</span>
<span class="c-kw">public float</span> maxAccelerationChange = <span class="c-st">0.7f</span>;  <span class="c-cm">// 최대 가속 변화량 (프레임당)</span>

<span class="c-kw">private float</span> lastSteeringInput = <span class="c-st">0f</span>;      <span class="c-cm">// 이전 프레임의 최종 조향값</span>
<span class="c-kw">private float</span> lastAccelerationInput = <span class="c-st">0f</span>;  <span class="c-cm">// 이전 프레임의 최종 가속값</span>

<span class="c-kw">public override void</span> <span class="c-fn">OnActionReceived</span>(<span class="c-ty">ActionBuffers</span> actions)
{
    <span class="c-cm">// 1. 신경망으로부터 연속적 행동 값 수신 (Continuous Actions)</span>
    <span class="c-kw">float</span> rawSteering = <span class="c-ty">Mathf</span>.<span class="c-fn">Clamp</span>(actions.ContinuousActions[<span class="c-st">0</span>], -<span class="c-st">1f</span>, <span class="c-st">1f</span>);
    <span class="c-kw">float</span> rawAcceleration = <span class="c-ty">Mathf</span>.<span class="c-fn">Clamp</span>(actions.ContinuousActions[<span class="c-st">1</span>], -<span class="c-st">1f</span>, <span class="c-st">1f</span>);
    <span class="c-cm">// rawSteering: 신경망이 판단한 원시 조향값 (-1.0 ~ 1.0)</span>

    <span class="c-cm">// 2. 입력 스무딩: 이전 프레임 값과 비교하여 변화량 제한</span>
    <span class="c-cm">//    직전 프레임의 최종 제어값(lastSteeringInput)과 현재 신경망 출력값(rawSteering)의 차이를 계산</span>
    <span class="c-kw">float</span> steeringInput = <span class="c-ty">Mathf</span>.<span class="c-fn">Clamp</span>(rawSteering,
        lastSteeringInput - maxSteeringChange,      <span class="c-cm">// 최소값: 이전값 - 최대변화량</span>
        lastSteeringInput + maxSteeringChange);     <span class="c-cm">// 최대값: 이전값 + 최대변화량</span>
    <span class="c-cm">// steeringInput: 보정된 현재 프레임의 최종 조향값 (차량 핸들 값으로 사용)</span>
    
    <span class="c-kw">float</span> accelerationInput = <span class="c-ty">Mathf</span>.<span class="c-fn">Clamp</span>(rawAcceleration,
        lastAccelerationInput - maxAccelerationChange,
        lastAccelerationInput + maxAccelerationChange);

    <span class="c-cm">// 3. 현재 프레임의 최종 제어값을 다음 프레임을 위해 저장</span>
    lastSteeringInput = steeringInput;        <span class="c-cm">// 다음 프레임의 기준값으로 사용</span>
    lastAccelerationInput = accelerationInput;
    
    <span class="c-cm">// 4. 보정된 최종 제어값을 차량 컨트롤러에 전달</span>
    <span class="c-cm">//    부드러운 주행 궤적과 물리적 관성을 구현</span>
    vehicleController.<span class="c-fn">ProvideInputs</span>(accelerationInput, steeringInput, <span class="c-st">0f</span>);
}</code></pre>

                <p><strong>기술적 특징:</strong></p>
                <ul>
                    <li><span class="highlight">연속 행동 공간:</span> 불연속적인 이동이 아닌 조향과 가속/감속을 정밀하게 제어하는 연속 실수 값 사용</li>
                    <li><span class="highlight">변화량 제한:</span> 조향은 최대 ±0.5, 가속은 최대 ±0.7로 프레임당 변화량 제한하여 급격한 지터링 방지</li>
                    <li><span class="highlight">부드러운 제어:</span> 이전 프레임 값과 현재 신경망 출력값의 차이를 계산하여 보정된 최종 제어값 생성</li>
                    <li><span class="highlight">물리적 관성 구현:</span> 실제 차량과 유사한 부드러운 주행 궤적과 관성 효과 구현</li>
                </ul>

                <h2>전체 시스템 기술적 특징</h2>
                <p>환경 감지 및 행동 결정 시스템의 핵심 기술적 특징입니다.</p>
                <ul>
                    <li><span class="highlight">다방향 레이캐스트:</span> 전방 9개, 후방 3개 레이로 환경 정확히 인식</li>
                    <li><span class="highlight">정규화된 관측:</span> 모든 거리 값을 0.0~1.0 범위로 정규화하여 신경망 학습 안정성 향상</li>
                    <li><span class="highlight">비선형 페널티:</span> 거리 기반 비선형 페널티 함수로 가까울수록 급격한 페널티 증가</li>
                    <li><span class="highlight">연속 행동 공간:</span> 조향과 가속/감속을 정밀하게 제어하는 연속 실수 값 사용</li>
                    <li><span class="highlight">입력 스무딩:</span> 변화량 제한을 통한 부드러운 제어 및 급격한 지터링 방지</li>
                </ul>
                </div>

                <div id="ml-training-tab" class="tab-content">
                <h2>5. ML-Agents 학습 설정</h2>
                <p>Unity ML-Agents 라이브러리의 PPO(Proximal Policy Optimization) 알고리즘을 사용하여 에이전트를 학습시켰습니다. 하이퍼파라미터 튜닝과 보상 설계를 통해 안정적인 학습을 달성했습니다.</p>

                <div class="visual-frame">
                    <div class="data-table">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="border-bottom: 2px solid var(--border-color);">
                                    <th style="padding: 12px; text-align: left; color: var(--accent-color);">하이퍼파라미터</th>
                                    <th style="padding: 12px; text-align: center; color: var(--accent-color);">값</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 12px;">Trainer Type</td>
                                    <td style="padding: 12px; text-align: center;">PPO</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 12px;">Batch Size</td>
                                    <td style="padding: 12px; text-align: center;">1024</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 12px;">Buffer Size</td>
                                    <td style="padding: 12px; text-align: center;">10240</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 12px;">Learning Rate</td>
                                    <td style="padding: 12px; text-align: center;">0.0003</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 12px;">Hidden Units</td>
                                    <td style="padding: 12px; text-align: center;">256</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 12px;">Num Layers</td>
                                    <td style="padding: 12px; text-align: center;">2</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 12px;">Time Horizon</td>
                                    <td style="padding: 12px; text-align: center;">1000</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 12px;">Max Steps</td>
                                    <td style="padding: 12px; text-align: center;">10,000,000</td>
                                </tr>
                                <tr>
                                    <td style="padding: 12px;">Curiosity Signal</td>
                                    <td style="padding: 12px; text-align: center;">0.02 (활성화)</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <h2>6. 다중 트랙 학습 지원</h2>
                <p>에이전트의 일반화 성능을 향상시키기 위해 <span class="highlight">다중 트랙 학습 시스템</span>을 구현했습니다. 각 에피소드 시작 시 랜덤하게 트랙을 선택하여 학습하므로, 다양한 트랙 환경에 적응할 수 있습니다.</p>

<pre><code><span class="c-cm">// SimcadeCarAgent_Auto.cs: 다중 트랙 학습 지원</span>
<span class="c-kw">public override void</span> <span class="c-fn">OnEpisodeBegin</span>()
{
    <span class="c-cm">// 모든 트랙 중 랜덤 선택</span>
    <span class="c-kw">if</span> (allTracks == <span class="c-kw">null</span> || allTracks.Count == <span class="c-st">0</span>) {
        <span class="c-ty">Debug</span>.<span class="c-fn">LogError</span>(<span class="c-st">"학습할 트랙(AllTracks 리스트)가 설정되지 않았습니다!"</span>);
        <span class="c-kw">return</span>;
    }
    
    <span class="c-cm">// 랜덤 트랙 선택</span>
    currentTrackManager = allTracks[<span class="c-ty">Random</span>.<span class="c-fn">Range</span>(<span class="c-st">0</span>, allTracks.Count)];
    <span class="c-ty">Transform</span> spawnPoint = currentTrackManager.<span class="c-fn">GetSpawnPoint</span>();
    
    <span class="c-cm">// 선택된 트랙의 스폰 포인트로 이동</span>
    transform.position = spawnPoint.position;
    transform.rotation = spawnPoint.rotation;
    
    <span class="c-cm">// 상태 초기화</span>
    rb.linearVelocity = <span class="c-ty">Vector3</span>.zero;
    rb.angularVelocity = <span class="c-ty">Vector3</span>.zero;
    currentCheckpointIndex = <span class="c-st">0</span>;
    <span class="c-cm">// ... 기타 상태 초기화</span>
}</code></pre>

                <p><strong>기술적 특징:</strong></p>
                <ul>
                    <li><span class="highlight">랜덤 트랙 선택:</span> 각 에피소드마다 `allTracks` 리스트에서 랜덤하게 트랙 선택</li>
                    <li><span class="highlight">다양한 시작 위치:</span> 각 트랙의 `SpawnPointManager`에서 랜덤 스폰 포인트 선택</li>
                    <li><span class="highlight">일반화 성능 향상:</span> 다양한 트랙 환경에서 학습하여 단일 트랙에 과적합되지 않도록 방지</li>
                </ul>

                <h2>전체 시스템 기술적 특징</h2>
                <p>ML-Agents 학습 설정 및 최적화의 핵심 기술적 특징입니다.</p>
                <ul>
                    <li><span class="highlight">PPO 알고리즘:</span> Unity ML-Agents 라이브러리의 PPO 알고리즘을 활용한 안정적인 학습</li>
                    <li><span class="highlight">하이퍼파라미터 튜닝:</span> Batch Size, Learning Rate, Hidden Units 등 최적화된 학습 파라미터</li>
                    <li><span class="highlight">Curiosity Signal:</span> 탐험을 유도하는 호기심 신호로 다양한 행동 패턴 학습</li>
                    <li><span class="highlight">다중 트랙 학습:</span> 랜덤 트랙 선택으로 일반화 성능 향상</li>
                    <li><span class="highlight">대규모 학습:</span> 최대 10,000,000 스텝까지 학습하여 안정적인 정책 수렴</li>
                </ul>
                </div>

                <div style="height: 100px;"></div>
            </div>
        </div>
    </div>

    <!-- WorldFirstKill Modal -->
    <div id="modal-overlay-wfk" class="modal-overlay" onclick="closeModal('wfk')">
        <div class="modal-container" onclick="event.stopPropagation()">
            <div class="modal-body">
                <div class="modal-header-nav">
                    <div class="mono" style="color: var(--accent-color);">PROJECT REPORT // WORLDFIRSTKILL</div>
                    <button onclick="closeModal('wfk')" style="background: none; border: 1px solid var(--accent-color); color: var(--accent-color); padding: 8px 20px; border-radius: 6px; cursor: pointer; font-family: 'Fira Code'; font-size: 0.8rem;">[X] DISCONNECT</button>
                </div>
                
                <h1 style="font-size: 2.5rem; margin-bottom: 30px; color: #f0f6fc;">WorldFirstKill: 데이터 저장 및 파싱 시스템</h1>

                <div style="background: rgba(88, 166, 255, 0.1); border: 2px solid var(--accent-color); border-radius: 12px; padding: 30px; margin-bottom: 40px;">
                    <h3 style="color: var(--accent-color); margin-bottom: 20px; font-family: 'Fira Code', monospace; font-size: 1.2rem;">시스템 개요</h3>
                    <p style="color: var(--text-color); line-height: 1.8; margin-bottom: 25px;">
                        WorldFirstKill은 <span class="highlight">서버 기반 게임 데이터 관리</span>와 <span class="highlight">완전한 게임 상태 복원</span>을 위한 통합 시스템입니다.
                        구글 스프레드시트에서 CSV 파일을 다운로드하고, 리플렉션 기반 파싱을 통해 게임 데이터를 자동으로 로드합니다.
                        Seed/Token 시스템을 통해 랜덤 시드 상태를 완전히 복원하여, 세이브/로드 시에도 동일한 게임 결과를 보장합니다.
                    </p>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 20px; margin-top: 25px;">
                        <div style="background: rgba(88, 166, 255, 0.05); border: 1px solid var(--accent-color); border-radius: 8px; padding: 20px; text-align: center;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 10px; font-family: 'Fira Code', monospace; font-size: 0.95rem;">데이터 수집</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.6;">서버에서 CSV 다운로드<br>버전 관리로 효율적 업데이트</div>
                        </div>
                        <div style="background: rgba(88, 166, 255, 0.05); border: 1px solid var(--accent-color); border-radius: 8px; padding: 20px; text-align: center;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 10px; font-family: 'Fira Code', monospace; font-size: 0.95rem;">데이터 처리</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.6;">리플렉션 기반 자동 파싱<br>타입 안전성 보장</div>
                        </div>
                        <div style="background: rgba(88, 166, 255, 0.05); border: 1px solid var(--accent-color); border-radius: 8px; padding: 20px; text-align: center;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 10px; font-family: 'Fira Code', monospace; font-size: 0.95rem;">게임 생성</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.6;">Factory Pattern으로 객체 생성<br>데이터 기반 게임 엔티티</div>
                        </div>
                        <div style="background: rgba(88, 166, 255, 0.05); border: 1px solid var(--accent-color); border-radius: 8px; padding: 20px; text-align: center;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 10px; font-family: 'Fira Code', monospace; font-size: 0.95rem;">상태 저장</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.6;">JSON + Seed Token<br>완전한 상태 복원</div>
                        </div>
                    </div>
                </div>

                <div class="tab-container">
                    <button class="tab-button active" onclick="switchTabWFK('csv')">CSV 서버 다운로드 및 파싱</button>
                    <button class="tab-button" onclick="switchTabWFK('save')">Seed/Token 세이브 로드</button>
                    <button class="tab-button" onclick="switchTabWFK('loading')">비동기 로딩 시스템</button>
                </div>

                <div id="wfk-csv-tab" class="tab-content active">
                <h2>1. 리플렉션 기반 CSV 파싱 시스템</h2>
                <p>CSV 파일의 헤더와 데이터 클래스의 필드를 자동으로 매핑하여 동적으로 파싱하는 시스템을 구현했습니다. 
                <span class="highlight">리플렉션(Reflection)</span>을 활용하여 타입 안전성을 보장하면서도 확장 가능한 파싱 로직을 설계했습니다.</p>

                <h3>1.1 파싱 과정 개요</h3>
                <p>CSV 파싱은 다음과 같은 단계로 진행됩니다:</p>
                
                <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid var(--border-color); border-radius: 12px; padding: 30px; margin: 30px 0;">
                    <div style="color: var(--accent-color); font-family: 'Fira Code', monospace; font-size: 1.1rem; font-weight: 700; margin-bottom: 20px; text-align: center; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">CSV 파싱 프로세스 플로우</div>
                    
                    <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                        <div style="background: rgba(35, 134, 54, 0.2); border: 2px solid var(--sub-accent); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 8px;">시작: CSV 텍스트 데이터 입력</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">서버에서 다운로드한 CSV 파일의 원시 텍스트</div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">1단계: 타입 정보 수집</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">리플렉션으로 제네릭 타입 T의 모든 필드 정보 추출<br><span style="color: var(--code-comment);">GetFields()로 클래스 구조 분석</span></div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">2단계: 헤더 추출 및 매핑</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">CSV 첫 줄(헤더)을 분리하고 클래스 필드명과 자동 매핑<br><span style="color: var(--code-comment);">예: "m_monsterIndex" ↔ "m_monsterIndex"</span></div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(255, 123, 114, 0.15); border: 2px solid #ff7b72; border-radius: 50px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: #ff7b72; font-weight: 700; margin-bottom: 8px;">3단계: 각 데이터 행 처리</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">각 행을 순회하며 객체 생성 및 데이터 할당</div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; width: 100%; max-width: 600px;">
                            <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 12px; text-align: center;">
                                <div style="color: var(--accent-color); font-weight: 700; font-size: 0.9rem; margin-bottom: 5px;">3-1. SmartSplit</div>
                                <div style="color: #8b949e; font-size: 0.8rem;">정규식으로 쉼표/따옴표 처리<br><span style="color: var(--code-comment);">"이름,설명",100 → ["이름,설명", "100"]</span></div>
                            </div>
                            <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 12px; text-align: center;">
                                <div style="color: var(--accent-color); font-weight: 700; font-size: 0.9rem; margin-bottom: 5px;">3-2. 객체 생성</div>
                                <div style="color: #8b949e; font-size: 0.8rem;">Activator.CreateInstance&lt;T&gt;()<br><span style="color: var(--code-comment);">새 인스턴스 생성</span></div>
                            </div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">4단계: 타입 변환 및 필드 할당</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">string → int/float/string 자동 변환 후 필드에 할당<br><span style="color: var(--code-comment);">리플렉션으로 필드 타입 확인 후 변환</span></div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(35, 134, 54, 0.2); border: 2px solid var(--sub-accent); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 8px;">완료: List&lt;T&gt; 반환</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">파싱된 모든 객체를 리스트로 반환</div>
                        </div>
                    </div>
                </div>
                
                <p style="margin-top: 20px; color: #8b949e;"><strong>핵심 개념:</strong></p>
                <ul style="margin-left: 25px; color: #8b949e;">
                    <li><span class="highlight">타입 정보 수집:</span> 리플렉션을 사용하여 제네릭 타입 T의 모든 필드 정보 추출</li>
                    <li><span class="highlight">헤더 매핑:</span> CSV 첫 번째 줄(헤더)과 클래스 필드명을 자동으로 매핑</li>
                    <li><span class="highlight">데이터 행 파싱:</span> 각 데이터 행을 스마트 분할하여 컬럼 단위로 분리</li>
                    <li><span class="highlight">타입 변환 및 할당:</span> 문자열 데이터를 필드 타입에 맞게 변환하여 객체에 할당</li>
                </ul>

                <h3>1.2 핵심 파싱 로직</h3>
                <p>제네릭 메서드를 사용하여 타입에 독립적인 파싱을 수행합니다. 리플렉션으로 타입 정보를 추출하고, CSV 헤더와 클래스 필드를 자동 매핑하여 객체를 생성합니다.</p>

                <div style="background: rgba(56, 139, 253, 0.1); border-left: 4px solid #388bfd; padding: 20px; margin: 25px 0; border-radius: 6px;">
                    <div style="margin-bottom: 15px;"><strong style="color: var(--accent-color);">작동 원리:</strong></div>
                    <div style="color: var(--text-color); line-height: 1.8; margin-left: 10px;">
                        <div style="margin-bottom: 10px;">• <strong>리플렉션(Reflection):</strong> 런타임에 클래스의 필드 정보를 동적으로 가져옵니다. 이를 통해 새로운 데이터 타입을 추가해도 파싱 코드를 수정할 필요가 없습니다.</div>
                        <div style="margin-bottom: 10px;">• <strong>자동 매핑:</strong> CSV 헤더의 컬럼명과 클래스 필드명이 일치하면 자동으로 매핑됩니다. 예를 들어, CSV에 "m_monsterIndex" 컬럼이 있고 클래스에도 같은 이름의 필드가 있으면 자동으로 연결됩니다.</div>
                        <div style="margin-bottom: 10px;">• <strong>타입 안전성:</strong> 제네릭 타입 T를 사용하여 컴파일 타임에 타입 체크를 수행합니다. BaseData를 상속한 클래스만 파싱할 수 있습니다.</div>
                        <div>• <strong>확장성:</strong> 새로운 데이터 클래스를 만들 때 BaseData만 상속하면 자동으로 파싱이 지원됩니다. 수동 매핑 코드를 작성할 필요가 없습니다.</div>
                    </div>
                </div>

<pre><code><span class="c-cm">// CSVParser.cs: 리플렉션 기반 CSV 파싱</span>
<span class="c-cm">// 제네릭 메서드로 모든 데이터 타입에 대해 동일한 파싱 로직 사용</span>
<span class="c-kw">public</span> <span class="c-ty">List</span>&lt;<span class="c-ty">T</span>&gt; <span class="c-fn">parseCSV</span>&lt;<span class="c-ty">T</span>&gt;(<span class="c-kw">string</span> csvData) <span class="c-kw">where T</span> : <span class="c-ty">BaseData</span>, <span class="c-kw">new</span>()
{
    <span class="c-cm">// 1. 리플렉션으로 타입의 모든 필드 정보 가져오기</span>
    <span class="c-ty">Type</span> myType = <span class="c-kw">typeof</span>(<span class="c-ty">T</span>);
    <span class="c-ty">FieldInfo</span>[] myFieldInfo = myType.<span class="c-fn">GetFields</span>(...);

    <span class="c-cm">// 2. CSV 헤더 추출 및 필드 매핑</span>
    <span class="c-kw">string</span>[] headers = <span class="c-cm">/* CSV 첫 줄 분리 */</span>;
    <span class="c-fn">SetupFieldDict</span>(headers, myFieldInfo);  <span class="c-cm">// 헤더 ↔ 필드 매핑 딕셔너리 생성</span>

    <span class="c-cm">// 3. 각 데이터 행 파싱</span>
    <span class="c-kw">for</span> (<span class="c-kw">int</span> rowIndex = <span class="c-st">1</span>; rowIndex < csvLines.Length; rowIndex++) {
        <span class="c-kw">string</span>[] columns = <span class="c-fn">SmartSplit</span>(csvLines[rowIndex]);  <span class="c-cm">// 쉼표와 따옴표 처리</span>
        <span class="c-ty">T</span> objectData = <span class="c-ty">Activator</span>.<span class="c-fn">CreateInstance</span>&lt;<span class="c-ty">T</span>&gt;();  <span class="c-cm">// 새 객체 생성</span>

        <span class="c-cm">// 4. 각 컬럼 데이터를 해당 필드에 할당 (타입 자동 변환)</span>
        <span class="c-fn">SetFieldValue</span>(objectData, fieldInfo, columns[i]);
        csvDataList.<span class="c-fn">Add</span>(objectData);
    }
    <span class="c-kw">return</span> csvDataList;
}</code></pre>

                <h3>1.3 실제 파싱 예시</h3>
                <p>WorldFirstKill에서 사용하는 실제 CSV 파싱 예시를 통해 동작 방식을 설명합니다.</p>
                
                <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid var(--border-color); border-radius: 12px; padding: 30px; margin: 30px 0;">
                    <div style="color: var(--accent-color); font-family: 'Fira Code', monospace; font-size: 1.1rem; font-weight: 700; margin-bottom: 20px; text-align: center; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">CSV 파싱 예시: 몬스터 데이터</div>
                    
                    <div style="display: flex; flex-direction: column; gap: 25px;">
                        <div>
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 10px; font-family: 'Fira Code', monospace;">1. CSV 파일 형식 (서버에서 다운로드한 원시 텍스트)</div>
                            <div style="background: var(--code-bg); padding: 15px; border-radius: 6px; border: 1px solid var(--border-color); font-family: 'Fira Code', monospace; font-size: 0.85rem; overflow-x: auto;">
<pre style="margin: 0; color: var(--text-color);">m_monsterIndex,m_monsterName,m_hp,m_attack,m_defense,m_dropItemID
1,슬라임,100,10,5,101
2,고블린,150,15,8,102
3,오크,200,25,12,103</pre>
                            </div>
                            <div style="color: #8b949e; font-size: 0.85rem; margin-top: 8px; padding-left: 10px;">
                                • 첫 줄은 헤더(컬럼명), 나머지는 데이터 행<br>
                                • 각 필드는 쉼표(,)로 구분됨
                            </div>
                        </div>
                        
                        <div>
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 10px; font-family: 'Fira Code', monospace;">2. C# 데이터 클래스 정의</div>
                            <div style="background: var(--code-bg); padding: 15px; border-radius: 6px; border: 1px solid var(--border-color); font-family: 'Fira Code', monospace; font-size: 0.85rem; overflow-x: auto;">
<pre style="margin: 0; color: var(--text-color);"><span style="color: var(--code-keyword);">public class</span> <span style="color: var(--code-type);">Data_Monster</span> : <span style="color: var(--code-type);">BaseData</span>
{
    <span style="color: var(--code-keyword);">public int</span> m_monsterIndex;
    <span style="color: var(--code-keyword);">public string</span> m_monsterName;
    <span style="color: var(--code-keyword);">public int</span> m_hp;
    <span style="color: var(--code-keyword);">public int</span> m_attack;
    <span style="color: var(--code-keyword);">public int</span> m_defense;
    <span style="color: var(--code-keyword);">public int</span> m_dropItemID;
}</pre>
                            </div>
                            <div style="color: #8b949e; font-size: 0.85rem; margin-top: 8px; padding-left: 10px;">
                                • BaseData를 상속하여 자동 파싱 지원<br>
                                • 필드명이 CSV 헤더와 정확히 일치해야 함
                            </div>
                        </div>
                        
                        <div>
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 10px; font-family: 'Fira Code', monospace;">3. 파싱 과정</div>
                            <div style="background: rgba(88, 166, 255, 0.1); padding: 15px; border-radius: 6px; border-left: 4px solid var(--accent-color);">
                                <div style="margin-bottom: 12px;">
                                    <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 5px;">Step 1: 헤더 매핑</div>
                                    <div style="color: var(--text-color); font-size: 0.9rem; margin-left: 10px;">
                                        CSV 헤더: <code style="color: var(--code-string);">["m_monsterIndex", "m_monsterName", "m_hp", "m_attack", "m_defense", "m_dropItemID"]</code><br>
                                        클래스 필드와 자동 매핑 → <code style="color: var(--code-comment);">DataIndex_Dict</code>, <code style="color: var(--code-comment);">Data_Dict</code> 생성
                                    </div>
                                </div>
                                <div style="margin-bottom: 12px;">
                                    <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 5px;">Step 2: 첫 번째 행 파싱</div>
                                    <div style="color: var(--text-color); font-size: 0.9rem; margin-left: 10px;">
                                        CSV 행: <code style="color: var(--code-string);">"1,슬라임,100,10,5,101"</code><br>
                                        SmartSplit → <code style="color: var(--code-string);">["1", "슬라임", "100", "10", "5", "101"]</code><br>
                                        타입 변환 및 할당:
                                        <ul style="margin-top: 5px; margin-left: 20px; color: var(--text-color);">
                                            <li>m_monsterIndex = <code style="color: var(--code-type);">int</code>.Parse("1") → <code style="color: var(--code-string);">1</code></li>
                                            <li>m_monsterName = <code style="color: var(--code-type);">string</code>("슬라임") → <code style="color: var(--code-string);">"슬라임"</code></li>
                                            <li>m_hp = <code style="color: var(--code-type);">int</code>.Parse("100") → <code style="color: var(--code-string);">100</code></li>
                                            <li>m_attack = <code style="color: var(--code-type);">int</code>.Parse("10") → <code style="color: var(--code-string);">10</code></li>
                                            <li>m_defense = <code style="color: var(--code-type);">int</code>.Parse("5") → <code style="color: var(--code-string);">5</code></li>
                                            <li>m_dropItemID = <code style="color: var(--code-type);">int</code>.Parse("101") → <code style="color: var(--code-string);">101</code></li>
                                        </ul>
                                    </div>
                                </div>
                                <div>
                                    <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 5px;">Step 3: 결과 객체</div>
                                    <div style="color: var(--text-color); font-size: 0.9rem; margin-left: 10px;">
                                        <code style="color: var(--code-type);">Data_Monster</code> 객체 생성 완료:
                                        <div style="background: rgba(0, 0, 0, 0.3); padding: 10px; border-radius: 4px; margin-top: 5px; font-family: 'Fira Code', monospace; font-size: 0.85rem;">
                                            { m_monsterIndex: 1, m_monsterName: "슬라임", m_hp: 100, m_attack: 10, m_defense: 5, m_dropItemID: 101 }
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div>
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 10px; font-family: 'Fira Code', monospace;">4. 최종 파싱 결과</div>
                            <div style="background: var(--code-bg); padding: 15px; border-radius: 6px; border: 1px solid var(--border-color); font-family: 'Fira Code', monospace; font-size: 0.85rem; overflow-x: auto;">
<pre style="margin: 0; color: var(--text-color);"><span style="color: var(--code-type);">List</span>&lt;<span style="color: var(--code-type);">Data_Monster</span>&gt; monsterList = [
    { m_monsterIndex: 1, m_monsterName: "슬라임", m_hp: 100, m_attack: 10, m_defense: 5, m_dropItemID: 101 },
    { m_monsterIndex: 2, m_monsterName: "고블린", m_hp: 150, m_attack: 15, m_defense: 8, m_dropItemID: 102 },
    { m_monsterIndex: 3, m_monsterName: "오크", m_hp: 200, m_attack: 25, m_defense: 12, m_dropItemID: 103 }
];</pre>
                            </div>
                            <div style="color: #8b949e; font-size: 0.85rem; margin-top: 8px; padding-left: 10px;">
                                • 모든 행이 파싱되어 <code style="color: var(--code-type);">List&lt;Data_Monster&gt;</code>로 반환됨<br>
                                • 게임에서 <code style="color: var(--code-comment);">Managers.Data.MonsterData</code>로 접근 가능
                            </div>
                        </div>
                    </div>
                </div>
                
                <div style="background: rgba(56, 139, 253, 0.1); border-left: 4px solid #388bfd; padding: 20px; margin: 25px 0; border-radius: 6px;">
                    <div style="margin-bottom: 15px;"><strong style="color: var(--accent-color);">예시에서 확인할 수 있는 핵심 사항:</strong></div>
                    <ul style="margin-left: 20px; color: var(--text-color); line-height: 1.8;">
                        <li><strong>자동 매핑:</strong> CSV 헤더의 컬럼명("m_monsterIndex")과 클래스 필드명이 일치하면 자동으로 연결됩니다. 수동 매핑 코드가 필요 없습니다.</li>
                        <li><strong>타입 자동 변환:</strong> CSV의 문자열 데이터("100")가 필드 타입(int)에 맞게 자동으로 변환됩니다.</li>
                        <li><strong>확장성:</strong> 새로운 몬스터를 추가하려면 CSV 파일에 행만 추가하면 됩니다. 코드 수정이 필요 없습니다.</li>
                        <li><strong>일관성:</strong> 몬스터, 아이템, 장비 등 모든 데이터 타입에 대해 동일한 파싱 로직을 사용합니다.</li>
                    </ul>
                </div>

                <h3>1.4 스마트 분할 (SmartSplit)</h3>
                <p>일반적인 <code>Split(',')</code>는 쉼표가 포함된 문자열이나 따옴표로 감싼 필드를 제대로 처리하지 못합니다. 
                정규식을 사용하여 CSV 표준에 맞게 파싱합니다.</p>

<pre><code><span class="c-cm">// 쉼표와 따옴표를 고려한 스마트 분할</span>
<span class="c-kw">string</span>[] <span class="c-fn">SmartSplit</span>(<span class="c-kw">string</span> line)
{
    <span class="c-cm">// 정규식: 따옴표로 감싼 값 또는 일반 값을 매칭</span>
    <span class="c-kw">return</span> <span class="c-ty">Regex</span>.<span class="c-fn">Matches</span>(line, <span class="c-st">@"(?:^|,)(?:""(?<val>[^""]*)""|(?<val>[^,""]*))"</span>)
                .<span class="c-fn">Cast</span>&lt;<span class="c-ty">Match</span>&gt;()
                .<span class="c-fn">Select</span>(m => m.Groups[<span class="c-st">"val"</span>].Value)
                .<span class="c-fn">ToArray</span>();
}
<span class="c-cm">// 예시: "이름,설명",100,200 → ["이름,설명", "100", "200"]</span></code></pre>

                <h3>1.5 타입 자동 변환</h3>
                <p>필드 타입에 따라 문자열 데이터를 자동으로 변환합니다.</p>
                
                <div style="background: rgba(56, 139, 253, 0.1); border-left: 4px solid #388bfd; padding: 20px; margin: 25px 0; border-radius: 6px;">
                    <div style="margin-bottom: 15px;"><strong style="color: var(--accent-color);">타입 변환 예시:</strong></div>
                    <div style="color: var(--text-color); line-height: 1.8; margin-left: 10px;">
                        <div style="margin-bottom: 10px;">
                            <strong>CSV 데이터:</strong> <code style="color: var(--code-string);">"100"</code> (문자열)<br>
                            <strong>필드 타입:</strong> <code style="color: var(--code-type);">int</code><br>
                            <strong>변환 결과:</strong> <code style="color: var(--code-type);">int</code> 값 <code style="color: var(--code-string);">100</code>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <strong>CSV 데이터:</strong> <code style="color: var(--code-string);">"3.14"</code> (문자열)<br>
                            <strong>필드 타입:</strong> <code style="color: var(--code-type);">float</code><br>
                            <strong>변환 결과:</strong> <code style="color: var(--code-type);">float</code> 값 <code style="color: var(--code-string);">3.14f</code>
                        </div>
                        <div>
                            <strong>CSV 데이터:</strong> <code style="color: var(--code-string);">"슬라임"</code> (문자열)<br>
                            <strong>필드 타입:</strong> <code style="color: var(--code-type);">string</code><br>
                            <strong>변환 결과:</strong> <code style="color: var(--code-type);">string</code> 값 <code style="color: var(--code-string);">"슬라임"</code> (변환 없음)
                        </div>
                    </div>
                </div>

<pre><code><span class="c-cm">// 필드 타입에 따라 자동 변환</span>
<span class="c-kw">protected virtual void</span> <span class="c-fn">SetFieldValue</span>(<span class="c-ty">BaseData</span> instance, <span class="c-ty">FieldInfo</span> fieldInfo, <span class="c-kw">string</span> value)
{
    <span class="c-kw">if</span> (fieldInfo.FieldType == <span class="c-kw">typeof</span>(<span class="c-kw">string</span>))
        fieldInfo.<span class="c-fn">SetValue</span>(instance, value);
    <span class="c-kw">else if</span> (fieldInfo.FieldType == <span class="c-kw">typeof</span>(<span class="c-kw">int</span>) && <span class="c-kw">int</span>.<span class="c-fn">TryParse</span>(value, <span class="c-kw">out</span> <span class="c-kw">int</span> intVal))
        fieldInfo.<span class="c-fn">SetValue</span>(instance, intVal);
    <span class="c-kw">else if</span> (fieldInfo.FieldType == <span class="c-kw">typeof</span>(<span class="c-kw">float</span>) && <span class="c-kw">float</span>.<span class="c-fn">TryParse</span>(value, <span class="c-kw">out</span> <span class="c-kw">float</span> floatVal))
        fieldInfo.<span class="c-fn">SetValue</span>(instance, floatVal);
}</code></pre>

                <h3>1.6 기술적 특징</h3>
                <ul>
                    <li><span class="highlight">리플렉션 기반 동적 매핑:</span> CSV 헤더와 클래스 필드를 자동으로 매핑하여 수동 매핑 코드 불필요</li>
                    <li><span class="highlight">스마트 분할:</span> 정규식을 사용하여 쉼표와 따옴표를 포함한 CSV 데이터를 정확히 파싱</li>
                    <li><span class="highlight">타입 안전성:</span> 제네릭과 리플렉션을 활용하여 컴파일 타임 타입 체크 보장</li>
                    <li><span class="highlight">확장성:</span> 새로운 데이터 타입 추가 시 BaseData만 상속하면 자동으로 파싱 지원</li>
                </ul>

                <h2>2. 서버 CSV 다운로드 및 버전 관리 시스템</h2>
                <p>구글 스프레드시트에서 CSV 데이터를 다운로드하고, 버전을 관리하여 변경된 데이터만 업데이트하는 시스템을 구현했습니다. 
                <span class="highlight">버전 비교</span>를 통해 불필요한 다운로드를 방지하고, <span class="highlight">로컬 캐싱</span>으로 오프라인 사용을 지원합니다.</p>

                <h3>2.1 다운로드 프로세스</h3>
                <p>다운로드 프로세스는 다음과 같이 진행됩니다:</p>
                
                <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid var(--border-color); border-radius: 12px; padding: 30px; margin: 30px 0;">
                    <div style="color: var(--accent-color); font-family: 'Fira Code', monospace; font-size: 1.1rem; font-weight: 700; margin-bottom: 20px; text-align: center; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">서버 CSV 다운로드 및 버전 관리 플로우</div>
                    
                    <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                        <div style="background: rgba(35, 134, 54, 0.2); border: 2px solid var(--sub-accent); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 8px;">시작: 게임 시작 / 데이터 업데이트 요청</div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">1단계: 메타 시트 다운로드</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">서버 버전 정보가 담긴 메타 시트를 먼저 다운로드<br><span style="color: var(--code-comment);">각 CSV 파일의 최신 버전 번호 확인</span></div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">2단계: 로컬 버전 정보 로드</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">이전에 저장된 로컬 버전 정보를 불러옴<br><span style="color: var(--code-comment);">LoadLocalVersions()</span></div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(255, 123, 114, 0.15); border: 2px solid #ff7b72; border-radius: 50px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: #ff7b72; font-weight: 700; margin-bottom: 8px;">3단계: 각 CSV 파일 순회</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">몬스터, 아이템, 장비 등 모든 CSV 파일 처리</div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">4단계: 서버 버전 vs 로컬 버전 비교</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">각 파일의 서버 버전과 로컬 버전을 비교<br><span style="color: var(--code-comment);">버전이 다르면 서버 버전을 기준으로 해당 버전의 CSV 파일을 다운로드</span></div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(255, 123, 114, 0.15); border: 2px solid #ff7b72; border-radius: 50px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: #ff7b72; font-weight: 700; margin-bottom: 8px;">버전이 같고 로컬 파일 존재?</div>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; width: 100%; max-width: 600px; margin-top: 10px;">
                            <div style="background: rgba(35, 134, 54, 0.2); border: 2px solid var(--sub-accent); border-radius: 8px; padding: 12px; text-align: center;">
                                <div style="color: var(--sub-accent); font-weight: 700; font-size: 0.9rem; margin-bottom: 5px;">YES</div>
                                <div style="color: #8b949e; font-size: 0.8rem;">로컬 파일 읽기<br><span style="color: var(--code-comment);">File.ReadAllText()</span><br>다운로드 스킵</div>
                            </div>
                            <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 12px; text-align: center;">
                                <div style="color: var(--accent-color); font-weight: 700; font-size: 0.9rem; margin-bottom: 5px;">NO</div>
                                <div style="color: #8b949e; font-size: 0.8rem;">서버에서 비동기 다운로드<br><span style="color: var(--code-comment);">UnityWebRequest.Get()</span><br>서버 버전을 기준으로 해당 버전의 CSV 파일 다운로드<br>로컬에 저장 및 로컬 버전을 서버 버전으로 업데이트</div>
                            </div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">5단계: 진행률 콜백 호출</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">각 파일 다운로드 완료 시 진행률을 UI에 전달<br><span style="color: var(--code-comment);">progressCallback?.Invoke()</span></div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(35, 134, 54, 0.2); border: 2px solid var(--sub-accent); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 8px;">완료: 로컬 버전 정보 저장</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">업데이트된 버전 정보를 로컬에 저장<br><span style="color: var(--code-comment);">SaveLocalVersions()</span></div>
                        </div>
                    </div>
                </div>
                
                <p style="margin-top: 20px; color: #8b949e;"><strong>핵심 개념:</strong></p>
                <ul style="margin-left: 25px; color: #8b949e;">
                    <li><span class="highlight">메타 시트 다운로드:</span> 서버의 버전 정보가 담긴 메타 시트를 먼저 다운로드</li>
                    <li><span class="highlight">버전 비교:</span> 각 CSV 파일의 서버 버전과 로컬 버전을 비교</li>
                    <li><span class="highlight">조건부 다운로드:</span> 버전이 다르거나 로컬 파일이 없을 때만 서버에서 다운로드</li>
                    <li><span class="highlight">로컬 캐싱:</span> 다운로드한 파일을 로컬에 저장하고 버전 정보 업데이트</li>
                    <li><span class="highlight">진행률 보고:</span> 각 파일 다운로드 완료 시 진행률 콜백 호출</li>
                </ul>

                <h3>2.2 버전 관리 시스템</h3>
                <p>각 CSV 파일은 고유한 버전 번호를 가지며, 서버의 메타 시트에서 버전 정보를 가져옵니다. 
                로컬에 저장된 버전 정보와 비교하여 변경된 파일만 다운로드합니다. <span class="highlight">버전이 다를 경우, 서버 버전을 기준으로 해당 버전의 CSV 파일을 다운로드하고 로컬 버전 정보를 서버 버전으로 업데이트합니다.</span></p>
                
                <div style="background: rgba(56, 139, 253, 0.1); border-left: 4px solid #388bfd; padding: 15px 20px; margin: 20px 0; border-radius: 6px;">
                    <div style="margin-bottom: 10px;"><strong>버전 비교 로직:</strong></div>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li><strong>로컬 버전 == 서버 버전:</strong> 로컬 파일 사용 (다운로드 스킵)</li>
                        <li><strong>로컬 버전 != 서버 버전:</strong> 서버에서 해당 서버 버전의 CSV 파일을 다운로드하고, 로컬 버전 정보를 서버 버전으로 업데이트</li>
                        <li><strong>로컬 파일 없음:</strong> 서버에서 최신 버전의 CSV 파일을 다운로드하고, 로컬 버전 정보를 서버 버전으로 저장</li>
                    </ul>
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color);">
                        <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">핵심 원칙:</div>
                        <div style="color: var(--text-color); line-height: 1.6;">서버 버전이 항상 기준이 되며, 로컬 버전과 다를 경우 서버 버전의 데이터로 업데이트합니다. 이를 통해 서버에서 데이터가 변경되었을 때 항상 최신 데이터를 사용할 수 있습니다.</div>
                    </div>
                </div>

                <p>버전 비교는 다음과 같이 수행됩니다:</p>

<pre><code><span class="c-cm">// ServerCSV_ConvertData.cs: 버전 비교 로직</span>
<span class="c-cm">// 1. 서버 버전과 로컬 버전 가져오기</span>
<span class="c-kw">string</span> serverVersion = _serverVersions.<span class="c-fn">TryGetValue</span>(dataType, <span class="c-kw">out</span> <span class="c-kw">var</span> sAttrVerDict) 
    && sAttrVerDict.<span class="c-fn">TryGetValue</span>(attribute, <span class="c-kw">out</span> <span class="c-kw">var</span> sVer) ? sVer : <span class="c-st">"0"</span>;
<span class="c-kw">string</span> localVersion = _localVersions.<span class="c-fn">TryGetValue</span>(dataType, <span class="c-kw">out</span> <span class="c-kw">var</span> lAttrVerDict) 
    && lAttrVerDict.<span class="c-fn">TryGetValue</span>(attribute, <span class="c-kw">out</span> <span class="c-kw">var</span> lVer) ? lVer : <span class="c-st">"0"</span>;

<span class="c-cm">// 2. 버전 비교 및 다운로드 결정</span>
<span class="c-kw">if</span> (<span class="c-ty">File</span>.<span class="c-fn">Exists</span>(localFilePath) && localVersion == serverVersion) {
    fileContent = <span class="c-ty">File</span>.<span class="c-fn">ReadAllText</span>(localFilePath);  <span class="c-cm">// 로컬 캐시 사용</span>
} <span class="c-kw">else</span> {
    fileContent = <span class="c-kw">await</span> <span class="c-fn">DownloadFileAsync</span>(url);  <span class="c-cm">// 서버에서 다운로드</span>
    <span class="c-ty">File</span>.<span class="c-fn">WriteAllText</span>(localFilePath, fileContent);
    _localVersions[dataType][attribute] = serverVersion;  <span class="c-cm">// 로컬 버전 업데이트</span>
}</code></pre>

                <h3>2.3 핵심 다운로드 로직</h3>
                <p>비동기 다운로드를 통해 UI 블로킹 없이 데이터를 가져옵니다. 서버에서 CSV 파일을 다운로드하여 게임 데이터(몬스터, 아이템, 장비 등)를 가져옵니다.</p>
                
                <div style="background: rgba(56, 139, 253, 0.1); border-left: 4px solid #388bfd; padding: 20px; margin: 25px 0; border-radius: 6px;">
                    <div style="margin-bottom: 15px;"><strong style="color: var(--accent-color);">다운로드 대상과 목적:</strong></div>
                    <div style="color: var(--text-color); line-height: 1.8; margin-left: 10px;">
                        <div style="margin-bottom: 10px;">• <strong>다운로드 대상:</strong> 구글 스프레드시트에서 CSV 파일을 텍스트 형식으로 다운로드합니다. 각 CSV 파일은 게임 데이터(몬스터 스탯, 아이템 정보, 장비 옵션 등)를 포함합니다.</div>
                        <div style="margin-bottom: 10px;">• <strong>데이터 형식:</strong> CSV 파일은 쉼표로 구분된 텍스트 데이터입니다. 첫 줄은 헤더(컬럼명), 나머지는 데이터 행입니다.</div>
                        <div style="margin-bottom: 10px;">• <strong>비동기 처리:</strong> UnityWebRequest를 사용하여 비동기로 다운로드하므로, UI가 멈추지 않고 진행률을 실시간으로 표시할 수 있습니다.</div>
                        <div>• <strong>로컬 캐싱:</strong> 다운로드한 CSV 파일을 로컬에 저장하여, 다음 게임 실행 시 버전이 같으면 서버에서 다시 다운로드하지 않고 로컬 파일을 사용합니다.</div>
                    </div>
                </div>

<pre><code><span class="c-cm">// ServerCSV_ConvertData.cs: 서버 CSV 다운로드 및 버전 관리</span>
<span class="c-cm">// 서버에서 CSV 파일을 다운로드하여 게임 데이터(몬스터, 아이템, 장비 등)를 가져옵니다.</span>
<span class="c-kw">public static async</span> <span class="c-ty">Task</span>&lt;<span class="c-kw">bool</span>&gt; <span class="c-fn">DownloadAllCSVAsync</span>(<span class="c-ty">Action</span>&lt;<span class="c-kw">float</span>&gt; progressCallback = <span class="c-kw">null</span>)
{
    <span class="c-fn">LoadLocalVersions</span>();  <span class="c-cm">// 로컬 버전 정보 로드</span>

    <span class="c-kw">foreach</span> (<span class="c-kw">var</span> kvp <span class="c-kw">in</span> csvURLDict) {
        <span class="c-ty">CSVDataType</span> dataType = kvp.Key;
        <span class="c-kw">var</span> attrUrlDict = kvp.Value;

        <span class="c-kw">foreach</span> (<span class="c-kw">var</span> attrKvp <span class="c-kw">in</span> attrUrlDict) {
            <span class="c-kw">string</span> attribute = attrKvp.Key;
            <span class="c-kw">string</span> url = attrKvp.Value;

            <span class="c-cm">// 1. 서버 버전과 로컬 버전 비교</span>
            <span class="c-cm">// ...</span>
            <span class="c-kw">string</span> serverVersion = <span class="c-cm">/* 서버 버전 조회 로직 */</span>;
            <span class="c-kw">string</span> localVersion = <span class="c-cm">/* 로컬 버전 조회 로직 */</span>;
            <span class="c-kw">string</span> localFilePath = <span class="c-cm">/* 로컬 파일 경로 생성 */</span>;

            <span class="c-cm">// 2. 버전이 같으면 로컬 파일 사용, 다르면 서버에서 다운로드</span>
            <span class="c-kw">if</span> (<span class="c-ty">File</span>.<span class="c-fn">Exists</span>(localFilePath) && localVersion == serverVersion) {
                fileContent = <span class="c-ty">File</span>.<span class="c-fn">ReadAllText</span>(localFilePath);  <span class="c-cm">// 로컬 캐시 사용</span>
            } <span class="c-kw">else</span> {
                <span class="c-cm">// 3. 서버에서 비동기 다운로드 (CSV 파일 텍스트 데이터)</span>
                fileContent = <span class="c-kw">await</span> <span class="c-fn">DownloadFileAsync</span>(url);
                <span class="c-kw">if</span> (fileContent != <span class="c-kw">null</span>) {
                    <span class="c-ty">File</span>.<span class="c-fn">WriteAllText</span>(localFilePath, fileContent);  <span class="c-cm">// 로컬에 저장</span>
                    <span class="c-cm">// 4. 로컬 버전 정보 업데이트</span>
                    <span class="c-cm">// ...</span>
                }
            }

            csvDataDict.<span class="c-fn">Add</span>(attribute, fileContent);
            progressCallback?.<span class="c-fn">Invoke</span>((<span class="c-kw">float</span>)currentCount / totalCount);  <span class="c-cm">// 진행률 콜백</span>
        }
    }

    <span class="c-fn">SaveLocalVersions</span>();  <span class="c-cm">// 업데이트된 버전 정보 저장</span>
    <span class="c-kw">return true</span>;
}</code></pre>

                <h3>2.4 비동기 다운로드 구현</h3>
                <p>UnityWebRequest를 사용하여 비동기로 파일을 다운로드합니다. 서버 URL에서 CSV 파일의 텍스트 데이터를 다운로드하여 반환합니다.</p>
                
                <div style="background: rgba(56, 139, 253, 0.1); border-left: 4px solid #388bfd; padding: 20px; margin: 25px 0; border-radius: 6px;">
                    <div style="margin-bottom: 15px;"><strong style="color: var(--accent-color);">작동 원리:</strong></div>
                    <div style="color: var(--text-color); line-height: 1.8; margin-left: 10px;">
                        <div style="margin-bottom: 10px;">• <strong>UnityWebRequest.Get(url):</strong> 서버 URL로 HTTP GET 요청을 생성합니다. 이 요청은 비동기로 실행되므로 UI 스레드를 블로킹하지 않습니다.</div>
                        <div style="margin-bottom: 10px;">• <strong>await request.SendWebRequest():</strong> 요청을 전송하고 완료될 때까지 기다립니다. await 키워드를 사용하여 비동기 작업을 동기적으로 처리합니다.</div>
                        <div style="margin-bottom: 10px;">• <strong>request.downloadHandler.text:</strong> 다운로드된 데이터를 텍스트 형식으로 가져옵니다. CSV 파일의 경우 이 텍스트가 쉼표로 구분된 데이터입니다.</div>
                        <div>• <strong>에러 처리:</strong> 다운로드 실패 시 null을 반환하여 호출하는 쪽에서 안전하게 처리할 수 있도록 합니다.</div>
                    </div>
                </div>

<pre><code><span class="c-cm">// UnityWebRequest를 사용한 비동기 다운로드</span>
<span class="c-cm">// 서버 URL에서 CSV 파일의 텍스트 데이터를 다운로드하여 반환합니다.</span>
<span class="c-kw">private static async</span> <span class="c-ty">Task</span>&lt;<span class="c-kw">string</span>&gt; <span class="c-fn">DownloadFileAsync</span>(<span class="c-kw">string</span> url)
{
    <span class="c-kw">using</span> (<span class="c-ty">UnityWebRequest</span> request = <span class="c-ty">UnityWebRequest</span>.<span class="c-fn">Get</span>(url)) {
        <span class="c-kw">await</span> request.<span class="c-fn">SendWebRequest</span>();
        
        <span class="c-kw">if</span> (request.result == <span class="c-ty">UnityWebRequest</span>.<span class="c-ty">Result</span>.Success) {
            <span class="c-kw">return</span> request.downloadHandler.text;  <span class="c-cm">// CSV 텍스트 데이터 반환</span>
        } <span class="c-kw">else</span> {
            <span class="c-cm">// ...</span>
    <span class="c-kw">return null</span>;
        }
    }
}</code></pre>

                <h3>2.5 기술적 특징</h3>
                <ul>
                    <li><span class="highlight">버전 기반 업데이트:</span> 서버 버전과 로컬 버전을 비교하여 변경된 데이터만 다운로드</li>
                    <li><span class="highlight">비동기 다운로드:</span> UnityWebRequest를 사용한 비동기 CSV 다운로드로 UI 블로킹 방지</li>
                    <li><span class="highlight">로컬 캐싱:</span> 다운로드한 CSV 파일을 로컬에 저장하여 오프라인 사용 가능</li>
                    <li><span class="highlight">진행률 콜백:</span> 다운로드 진행률을 실시간으로 전달하여 UI 업데이트</li>
                    <li><span class="highlight">에러 처리:</span> 다운로드 실패 시 null 반환하여 안전하게 처리</li>
                </ul>

                <h2>전체 시스템 기술적 특징</h2>
                <p>CSV 서버 다운로드 및 파싱 시스템의 핵심 기술적 특징입니다.</p>
                <ul>
                    <li><span class="highlight">리플렉션 기반 동적 파싱:</span> 수동 매핑 코드 없이 CSV 헤더와 클래스 필드 자동 매핑</li>
                    <li><span class="highlight">버전 관리 시스템:</span> 서버와 로컬 버전 비교를 통한 효율적인 데이터 업데이트</li>
                    <li><span class="highlight">비동기 다운로드:</span> UnityWebRequest를 활용한 비동기 CSV 다운로드로 UI 반응성 유지</li>
                    <li><span class="highlight">타입 안전성:</span> 제네릭과 리플렉션을 활용한 컴파일 타임 타입 체크</li>
                </ul>
                </div>

                <div id="wfk-save-tab" class="tab-content">
                <h2>1. JSON 기반 저장/불러오기 시스템</h2>
                <p>게임 상태를 JSON 형식으로 저장하고 불러오는 시스템을 구현했습니다. Unity의 JsonUtility를 활용하여 직렬화/역직렬화를 수행합니다.</p>

<pre><code><span class="c-cm">// DataManager.cs: JSON 기반 저장/불러오기</span>
<span class="c-kw">public void</span> <span class="c-fn">SaveData</span>()
{
    <span class="c-ty">PlayerData</span> saveData = <span class="c-kw">new</span> <span class="c-ty">PlayerData</span>();

    <span class="c-kw">if</span> (Managers.nowPlayerData == <span class="c-kw">null</span>) <span class="c-kw">return</span>;

    saveData = Managers.nowPlayerData;

    <span class="c-cm">// JSON 직렬화</span>
    <span class="c-kw">string</span> data = <span class="c-ty">JsonUtility</span>.<span class="c-fn">ToJson</span>(saveData);
    <span class="c-ty">File</span>.<span class="c-fn">WriteAllText</span>(FilePath + DataNum, data);
}

<span class="c-kw">public void</span> <span class="c-fn">LoadData</span>()
{
    <span class="c-kw">if</span> (!<span class="c-ty">File</span>.<span class="c-fn">Exists</span>(FilePath + DataNum)) <span class="c-kw">return</span>;

    <span class="c-kw">string</span> data = <span class="c-ty">File</span>.<span class="c-fn">ReadAllText</span>(FilePath);

    <span class="c-cm">// JSON 역직렬화</span>
    <span class="c-ty">PlayerData</span> LoadData = <span class="c-ty">JsonUtility</span>.<span class="c-fn">FromJson</span>&lt;<span class="c-ty">PlayerData</span>&gt;(data);

    Managers.nowPlayerData = LoadData;

    <span class="c-cm">// 설정 데이터 복원</span>
    Managers.Sound.BGMSoundVolume = Managers.nowPlayerData.BGMSound;
    Managers.Sound.SFXSoundVolume = Managers.nowPlayerData.SFXSound;
}</code></pre>

                <h2>2. Seed/Token 시스템</h2>
                <p>게임의 랜덤 시드(RNG) 상태를 문자열 토큰으로 인코딩하여 저장하고 복원하는 시스템을 구현했습니다. 
                단순히 초기 시드만 저장하는 것이 아니라, <span class="highlight">각 Domain별로 사용된 랜덤 값의 개수</span>를 추적하여 
                게임의 RNG 상태를 <span class="highlight">완전히 복원</span>할 수 있습니다.</p>

                <h3>2.1 시스템 개요</h3>
                <p>게임에서 랜덤 값이 사용되는 영역(Domain)은 여러 개입니다. 예를 들어, 몬스터 드롭 아이템, 장비 옵션, 던전 생성 등 
                각각 독립적인 RNG 스트림을 사용합니다. 단순히 초기 시드만 저장하면, 세이브 파일을 불러왔을 때 
                <span class="highlight">이미 사용된 랜덤 값들이 다시 생성</span>되어 게임 밸런스가 깨질 수 있습니다.</p>
                
                <p>Seed/Token 시스템은 다음과 같이 동작합니다:</p>
                <ul>
                    <li><span class="highlight">BaseSeed 저장:</span> 게임 시작 시 설정된 초기 시드 값</li>
                    <li><span class="highlight">Domain별 사용량 추적:</span> 각 Domain에서 생성된 랜덤 값의 개수를 카운트</li>
                    <li><span class="highlight">고정 폭 인코딩:</span> 토큰을 고정 길이 문자열로 인코딩하여 파싱 안정성 확보</li>
                    <li><span class="highlight">완전한 상태 복원:</span> BaseSeed와 각 Domain의 사용량을 복원하여 정확한 RNG 상태 재현</li>
                </ul>

                <h3>2.2 토큰 구조</h3>
                <p>토큰은 다음과 같은 구조로 구성됩니다. 고정 폭 인코딩을 사용하여 각 부분의 위치가 고정되어 있어 파싱이 안정적입니다.</p>
                
                <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid var(--border-color); border-radius: 12px; padding: 30px; margin: 30px 0;">
                    <div style="color: var(--accent-color); font-family: 'Fira Code', monospace; font-size: 1.1rem; font-weight: 700; margin-bottom: 20px; text-align: center; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">Seed Token 구조 다이어그램</div>
                    
                    <div style="display: flex; flex-direction: column; gap: 20px; margin-top: 25px;">
                        <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
                            <div style="background: rgba(88, 166, 255, 0.2); padding: 15px 20px; border-radius: 8px; border: 2px solid var(--accent-color); flex: 1; min-width: 200px;">
                                <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px; font-family: 'Fira Code', monospace;">BaseSeed</div>
                                <div style="font-size: 0.9rem; color: var(--text-color); margin-bottom: 5px;">10자리 고정</div>
                                <div style="color: var(--code-comment); font-size: 0.85rem; margin-top: 5px;">예: <code style="color: var(--accent-color);">0000000123</code></div>
                                <div style="color: #8b949e; font-size: 0.8rem; margin-top: 8px;">게임 시작 시 설정된 초기 시드 값</div>
                    </div>
                            <div style="color: var(--accent-color); font-size: 1.5rem;">+</div>
                            <div style="background: rgba(88, 166, 255, 0.2); padding: 15px 20px; border-radius: 8px; border: 2px solid var(--accent-color); flex: 1; min-width: 200px;">
                                <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px; font-family: 'Fira Code', monospace;">Domain 개수</div>
                                <div style="font-size: 0.9rem; color: var(--text-color); margin-bottom: 5px;">3자리 고정</div>
                                <div style="color: var(--code-comment); font-size: 0.85rem; margin-top: 5px;">예: <code style="color: var(--accent-color);">003</code></div>
                                <div style="color: #8b949e; font-size: 0.8rem; margin-top: 8px;">랜덤 값이 사용되는 영역의 개수</div>
                    </div>
                        </div>
                        
                        <div style="margin: 20px 0; padding: 20px; background: rgba(0, 0, 0, 0.3); border-radius: 8px; border-left: 4px solid var(--sub-accent);">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 15px; font-family: 'Fira Code', monospace;">Domain 정보 (반복)</div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                <div style="background: rgba(35, 134, 54, 0.1); padding: 12px; border-radius: 6px; border: 1px solid var(--sub-accent);">
                                    <div style="color: var(--sub-accent); font-size: 0.9rem; margin-bottom: 5px; font-weight: 700;">Domain ID</div>
                                    <div style="font-size: 0.85rem; color: var(--text-color); margin-bottom: 5px;">3자리 고정</div>
                                    <div style="color: var(--code-comment); font-size: 0.8rem;">예: <code>001</code> (몬스터 드롭), <code>002</code> (장비 옵션)</div>
                                </div>
                                <div style="background: rgba(35, 134, 54, 0.1); padding: 12px; border-radius: 6px; border: 1px solid var(--sub-accent);">
                                    <div style="color: var(--sub-accent); font-size: 0.9rem; margin-bottom: 5px; font-weight: 700;">Usage Count</div>
                                    <div style="font-size: 0.85rem; color: var(--text-color); margin-bottom: 5px;">12자리 고정</div>
                                    <div style="color: var(--code-comment); font-size: 0.8rem;">예: <code>000000000042</code> (42번 사용)</div>
                                </div>
                            </div>
                        </div>
                        
                        <div style="background: rgba(88, 166, 255, 0.1); padding: 20px; border-radius: 8px; margin-top: 15px; border: 1px solid var(--accent-color);">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 12px; font-family: 'Fira Code', monospace;">전체 토큰 예시:</div>
                            <div style="font-family: 'Fira Code', monospace; font-size: 0.9rem; word-break: break-all; line-height: 1.8; color: var(--text-color);">
                                <span style="color: var(--accent-color);">0000000123</span>
                                <span style="color: var(--sub-accent);">003</span>
                                <span style="color: #ffa657;">001</span><span style="color: #ffa657;">000000000042</span>
                                <span style="color: #ffa657;">002</span><span style="color: #ffa657;">000000000015</span>
                                <span style="color: #ffa657;">003</span><span style="color: #ffa657;">000000000008</span>
                            </div>
                            <div style="font-size: 0.85rem; color: var(--code-comment); margin-top: 12px; line-height: 1.6;">
                                <strong>해석:</strong> BaseSeed(123) + 3개 Domain + Domain1(몬스터 드롭, 42회 사용) + Domain2(장비 옵션, 15회 사용) + Domain3(던전 생성, 8회 사용)
                            </div>
                        </div>
                    </div>
                </div>
                
                <div style="background: rgba(56, 139, 253, 0.1); border-left: 4px solid #388bfd; padding: 20px; margin: 25px 0; border-radius: 6px;">
                    <div style="margin-bottom: 15px;"><strong style="color: var(--accent-color);">고정 폭 인코딩의 장점:</strong></div>
                    <ul style="margin-left: 20px; color: var(--text-color); line-height: 1.8;">
                        <li><strong>파싱 안정성:</strong> 각 필드의 위치가 고정되어 있어 파싱 오류 가능성 최소화</li>
                        <li><strong>검증 용이성:</strong> 토큰 길이를 계산하여 유효성 검증 가능 (예: BaseSeed 10자리 + Domain 개수 3자리 + ...)</li>
                        <li><strong>인덱스 기반 접근:</strong> 구분자 없이 인덱스만으로 각 필드 추출 가능 (예: 토큰[0:10] = BaseSeed)</li>
                    </ul>
                </div>

                <h3>2.3 토큰 생성 (BuildSeedToken)</h3>
                <p>현재 게임의 RNG 상태를 문자열 토큰으로 변환합니다. BaseSeed와 각 Domain별 사용량을 고정 폭으로 인코딩하여 
                일관된 토큰 형식을 보장합니다.</p>
                
                <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid var(--border-color); border-radius: 12px; padding: 30px; margin: 30px 0;">
                    <div style="color: var(--accent-color); font-family: 'Fira Code', monospace; font-size: 1.1rem; font-weight: 700; margin-bottom: 20px; text-align: center; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">Seed Token 생성 프로세스</div>
                    
                    <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                        <div style="background: rgba(35, 134, 54, 0.2); border: 2px solid var(--sub-accent); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 8px;">시작: 게임 상태 저장 요청</div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">1단계: BaseSeed 추출</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">게임 시작 시 설정된 초기 시드 값 가져오기<br><span style="color: var(--code-comment);">GameSeed.BaseSeed</span></div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">2단계: Domain별 사용량 수집</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">각 Domain의 RNG 사용 횟수 스냅샷 가져오기<br><span style="color: var(--code-comment);">GameSeed.GetUsageSnapshot()</span></div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">3단계: 고정 폭 인코딩</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">BaseSeed(10자리) + Domain 개수(3자리) + 각 Domain 정보<br><span style="color: var(--code-comment);">BuildSeedToken()</span></div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">4단계: JSON으로 저장</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">생성된 토큰을 PlayerData에 포함하여 JSON 파일로 저장<br><span style="color: var(--code-comment);">JsonUtility.ToJson()</span></div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(35, 134, 54, 0.2); border: 2px solid var(--sub-accent); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 8px;">완료: 토큰 생성 완료</div>
                        </div>
                    </div>
                </div>

<pre><code><span class="c-cm">// SaveLoadManager.cs: Seed Token 생성</span>
<span class="c-kw">public static string</span> <span class="c-fn">BuildSeedToken</span>()
{
    <span class="c-kw">int</span> baseSeed = <span class="c-ty">GameSeed</span>.BaseSeed;  <span class="c-cm">// 초기 시드 값</span>
    <span class="c-ty">Dictionary</span>&lt;<span class="c-ty">GameSeed</span>.<span class="c-ty">Domain</span>, <span class="c-kw">ulong</span>&gt; usage = <span class="c-ty">GameSeed</span>.<span class="c-fn">GetUsageSnapshot</span>();  <span class="c-cm">// Domain별 사용량 스냅샷</span>

    <span class="c-cm">// BaseSeed를 10자리 고정 폭으로 인코딩</span>
    <span class="c-kw">string</span> token = <span class="c-fn">Pad</span>(<span class="c-fn">EncodeIntToUInt</span>(baseSeed), BASE_SEED_WIDTH);

    <span class="c-cm">// Domain 목록을 정렬하여 일관된 토큰 생성</span>
    <span class="c-ty">List</span>&lt;<span class="c-ty">GameSeed</span>.<span class="c-ty">Domain</span>&gt; domains = <span class="c-kw">new</span> <span class="c-ty">List</span>&lt;<span class="c-ty">GameSeed</span>.<span class="c-ty">Domain</span>&gt;((<span class="c-ty">GameSeed</span>.<span class="c-ty">Domain</span>[])<span class="c-ty">Enum</span>.<span class="c-fn">GetValues</span>(<span class="c-kw">typeof</span>(<span class="c-ty">GameSeed</span>.<span class="c-ty">Domain</span>)));
    domains.<span class="c-fn">Sort</span>((a, b) => (a).<span class="c-fn">CompareTo</span>(b));

    <span class="c-cm">// Domain 개수 추가 (3자리)</span>
    token += <span class="c-fn">Pad</span>((<span class="c-kw">uint</span>)domains.Count, COUNT_WIDTH);
    
    <span class="c-cm">// 각 Domain의 ID와 사용량을 토큰에 추가</span>
    <span class="c-kw">foreach</span> (<span class="c-kw">var</span> d <span class="c-kw">in</span> domains) {
        <span class="c-kw">ulong</span> count = usage.<span class="c-fn">GetValueOrDefault</span>(d, <span class="c-st">0UL</span>);
        token += <span class="c-fn">Pad</span>((<span class="c-kw">uint</span>)d, DOMAIN_ID_WIDTH);      <span class="c-cm">// Domain ID (3자리)</span>
        token += <span class="c-fn">Pad</span>(count, USAGE_WIDTH);                    <span class="c-cm">// 사용량 (12자리)</span>
    }

    <span class="c-kw">return</span> token;
}</code></pre>

                <h3>2.4 토큰 복원 (RestoreSeedToken)</h3>
                <p>저장된 토큰을 파싱하여 게임의 RNG 상태를 완전히 복원합니다. 고정 폭 인코딩을 활용하여 
                토큰의 각 부분을 정확히 추출하고, BaseSeed와 Domain별 사용량을 복원합니다.</p>
                
                <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid var(--border-color); border-radius: 12px; padding: 30px; margin: 30px 0;">
                    <div style="color: var(--accent-color); font-family: 'Fira Code', monospace; font-size: 1.1rem; font-weight: 700; margin-bottom: 20px; text-align: center; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">Seed Token 복원 프로세스</div>
                    
                    <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                        <div style="background: rgba(35, 134, 54, 0.2); border: 2px solid var(--sub-accent); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 8px;">시작: 세이브 파일 불러오기</div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">1단계: JSON 역직렬화</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">JSON 파일을 읽어 PlayerData 객체로 변환<br><span style="color: var(--code-comment);">JsonUtility.FromJson()</span></div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">2단계: 토큰 파싱</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">고정 폭으로 토큰을 분리하여 각 부분 추출<br><span style="color: var(--code-comment);">토큰[0:10] = BaseSeed, 토큰[10:13] = Domain 개수, ...</span></div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">3단계: BaseSeed 복원</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">토큰에서 BaseSeed 값을 디코딩하여 복원</div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">4단계: Domain별 사용량 복원</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">각 Domain의 ID와 사용 횟수를 복원<br><span style="color: var(--code-comment);">RestoreSeedToken()</span></div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">5단계: RNG 상태 복원</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">GameSeed 시스템에 BaseSeed와 사용량을 적용<br><span style="color: var(--code-comment);">GameSeed.RestoreFromSnapshot()</span></div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(35, 134, 54, 0.2); border: 2px solid var(--sub-accent); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 8px;">완료: 게임 상태 복원 완료</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">이제 RNG가 저장 시점과 동일한 상태로 복원됨</div>
                        </div>
                    </div>
                </div>
                
                <div style="background: rgba(56, 139, 253, 0.1); border-left: 4px solid #388bfd; padding: 20px; margin: 25px 0; border-radius: 6px;">
                    <div style="margin-bottom: 15px;"><strong style="color: var(--accent-color);">완전한 상태 복원의 의미:</strong></div>
                    <div style="color: var(--text-color); line-height: 1.8; margin-left: 10px;">
                        <div style="margin-bottom: 10px;">• <strong>문제 상황:</strong> 단순히 초기 시드만 저장하면, 세이브 파일을 불러왔을 때 이미 사용된 랜덤 값들이 다시 생성되어 게임 밸런스가 깨질 수 있습니다.</div>
                        <div style="margin-bottom: 10px;">• <strong>해결 방법:</strong> BaseSeed와 각 Domain별 사용량을 함께 저장하여, RNG가 정확히 저장 시점의 상태로 복원되도록 합니다.</div>
                        <div>• <strong>결과:</strong> 세이브 파일을 불러와도 몬스터 드롭, 장비 옵션, 던전 생성 등 모든 랜덤 요소가 저장 시점과 동일하게 생성됩니다.</div>
                    </div>
                </div>

<pre><code><span class="c-cm">// SaveLoadManager.cs: Seed Token 복원</span>
<span class="c-kw">public static bool</span> <span class="c-fn">RestoreSeedToken</span>(<span class="c-kw">string</span> token)
{
    <span class="c-kw">try</span> {
        <span class="c-kw">int</span> idx = <span class="c-st">0</span>;  <span class="c-cm">// 토큰 읽기 위치 인덱스</span>

        <span class="c-cm">// BaseSeed 디코딩 (10자리)</span>
        <span class="c-kw">ulong</span> baseSeedEncoded = <span class="c-fn">ReadUInt</span>(token, <span class="c-kw">ref</span> idx, BASE_SEED_WIDTH);
        <span class="c-kw">int</span> baseSeed = <span class="c-fn">DecodeUlongToInt</span>(baseSeedEncoded);

        <span class="c-cm">// Domain 개수 읽기 (3자리)</span>
        <span class="c-kw">uint</span> count = (<span class="c-kw">uint</span>)<span class="c-fn">ReadUInt</span>(token, <span class="c-kw">ref</span> idx, COUNT_WIDTH);
        
        <span class="c-ty">Dictionary</span>&lt;<span class="c-ty">GameSeed</span>.<span class="c-ty">Domain</span>, <span class="c-kw">ulong</span>&gt; usage = <span class="c-kw">new</span> <span class="c-ty">Dictionary</span>&lt;<span class="c-ty">GameSeed</span>.<span class="c-ty">Domain</span>, <span class="c-kw">ulong</span>&gt;();
        
        <span class="c-cm">// 각 Domain의 ID와 사용량 복원</span>
        <span class="c-kw">for</span> (<span class="c-kw">int</span> i = <span class="c-st">0</span>; i < count; i++) {
            <span class="c-kw">uint</span> domIdU = (<span class="c-kw">uint</span>)<span class="c-fn">ReadUInt</span>(token, <span class="c-kw">ref</span> idx, DOMAIN_ID_WIDTH);  <span class="c-cm">// Domain ID (3자리)</span>
            <span class="c-kw">ulong</span> u = <span class="c-fn">ReadUInt</span>(token, <span class="c-kw">ref</span> idx, USAGE_WIDTH);              <span class="c-cm">// 사용량 (12자리)</span>
            
            <span class="c-kw">if</span> (<span class="c-ty">Enum</span>.<span class="c-fn">IsDefined</span>(<span class="c-kw">typeof</span>(<span class="c-ty">GameSeed</span>.<span class="c-ty">Domain</span>), domIdU)) {
                usage[(<span class="c-ty">GameSeed</span>.<span class="c-ty">Domain</span>)domIdU] = u;
            }
        }

        <span class="c-cm">// GameSeed 시스템에 상태 복원</span>
        <span class="c-ty">GameSeed</span>.<span class="c-fn">RestoreFromSnapshot</span>(baseSeed, usage);
        <span class="c-kw">return true</span>;
    }
    <span class="c-kw">catch</span> {
        <span class="c-kw">return false</span>;  <span class="c-cm">// 토큰 파싱 실패 시 false 반환</span>
    }
}</code></pre>

                <h3>2.5 고정 폭 인코딩의 장점</h3>
                <p>고정 폭 인코딩을 사용하는 이유는 다음과 같습니다:</p>
                <ul>
                    <li><span class="highlight">파싱 안정성:</span> 각 필드의 위치가 고정되어 있어 파싱 오류 가능성 최소화</li>
                    <li><span class="highlight">검증 용이성:</span> 토큰 길이를 계산하여 유효성 검증 가능</li>
                    <li><span class="highlight">인덱스 기반 접근:</span> 구분자 없이 인덱스만으로 각 필드 추출 가능</li>
                </ul>

                <h3>2.6 기술적 특징</h3>
                <ul>
                    <li><span class="highlight">고정 폭 인코딩:</span> BaseSeed(10자리), Domain ID(3자리), Usage(12자리)로 고정 폭 인코딩하여 파싱 안정성 확보</li>
                    <li><span class="highlight">완전한 RNG 복원:</span> BaseSeed와 각 Domain별 사용량을 저장하여 RNG 상태를 완전히 복원</li>
                    <li><span class="highlight">Domain별 독립 추적:</span> 각 게임 영역의 RNG 사용량을 독립적으로 추적하여 정확한 상태 복원</li>
                    <li><span class="highlight">JSON 저장:</span> Seed Token을 JSON 파일에 저장하여 영구 보존</li>
                    <li><span class="highlight">에러 처리:</span> 토큰 파싱 실패 시 안전하게 false 반환하여 게임 크래시 방지</li>
                </ul>

                <h2>전체 시스템 기술적 특징</h2>
                <p>Seed/Token 기반 세이브 로드 시스템의 핵심 기술적 특징입니다.</p>
                <ul>
                    <li><span class="highlight">완전한 RNG 복원:</span> Seed Token 시스템으로 게임의 랜덤 상태 완전 복원</li>
                    <li><span class="highlight">JSON 기반 저장:</span> Unity JsonUtility를 활용한 직렬화/역직렬화</li>
                    <li><span class="highlight">고정 폭 인코딩:</span> BaseSeed(10자리), Domain ID(3자리), Usage(12자리)로 고정 폭 인코딩하여 파싱 안정성 확보</li>
                </ul>
                </div>

                <div id="wfk-loading-tab" class="tab-content">
                <h2>1. 비동기 로딩 시스템</h2>
                <p>게임 데이터 로딩과 씬 전환 시 UI 블로킹을 방지하기 위해 <span class="highlight">비동기 로딩 시스템</span>을 구현했습니다. 
                Unity의 <code>async/await</code>와 <code>Task</code>를 활용하여 로딩 진행률을 실시간으로 표시하고, 사용자 경험을 향상시켰습니다.</p>

                <h3>1.1 로딩 프로세스 개요</h3>
                <p>게임 시작 시 필요한 모든 데이터를 순차적으로 비동기로 로드합니다:</p>
                
                <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid var(--border-color); border-radius: 12px; padding: 30px; margin: 30px 0;">
                    <div style="color: var(--accent-color); font-family: 'Fira Code', monospace; font-size: 1.1rem; font-weight: 700; margin-bottom: 20px; text-align: center; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">비동기 로딩 프로세스 플로우</div>
                    
                    <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                        <div style="background: rgba(35, 134, 54, 0.2); border: 2px solid var(--sub-accent); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 8px;">시작: 게임 시작</div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.2); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">1단계: 메타 시트 다운로드</div>
                            <div style="color: #8b949e; font-size: 0.85rem; margin-bottom: 8px;">서버의 버전 정보가 담긴 메타 시트를 먼저 다운로드</div>
                            <div style="color: var(--code-comment); font-size: 0.8rem; background: rgba(0,0,0,0.3); padding: 5px; border-radius: 4px; margin-top: 5px;">0% ~ 20%</div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.2); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">2단계: CSV 데이터 다운로드</div>
                            <div style="color: #8b949e; font-size: 0.85rem; margin-bottom: 8px;">버전 비교 후 조건부 다운로드<br>각 파일 다운로드 진행률을 0.2 ~ 0.8 범위로 매핑</div>
                            <div style="color: var(--code-comment); font-size: 0.8rem; background: rgba(0,0,0,0.3); padding: 5px; border-radius: 4px; margin-top: 5px;">20% ~ 80%</div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.2); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">3단계: 데이터 파싱</div>
                            <div style="color: #8b949e; font-size: 0.85rem; margin-bottom: 8px;">Task.Run()으로 백그라운드 스레드에서 파싱<br>CSV 텍스트를 게임 객체로 변환</div>
                            <div style="color: var(--code-comment); font-size: 0.8rem; background: rgba(0,0,0,0.3); padding: 5px; border-radius: 4px; margin-top: 5px;">80% ~ 90%</div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.2); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">4단계: 최종 초기화</div>
                            <div style="color: #8b949e; font-size: 0.85rem; margin-bottom: 8px;">Managers.Game.Init()<br>Managers.UI.Init()</div>
                            <div style="color: var(--code-comment); font-size: 0.8rem; background: rgba(0,0,0,0.3); padding: 5px; border-radius: 4px; margin-top: 5px;">90% ~ 100%</div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(35, 134, 54, 0.2); border: 2px solid var(--sub-accent); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 8px;">완료: 게임 준비 완료</div>
                        </div>
                    </div>
                </div>
                
                <div style="background: rgba(56, 139, 253, 0.1); border-left: 4px solid #388bfd; padding: 20px; margin: 25px 0; border-radius: 6px;">
                    <div style="margin-bottom: 15px;"><strong style="color: var(--accent-color);">진행률 분배 설명:</strong></div>
                    <ul style="margin-left: 20px; color: var(--text-color); line-height: 1.8;">
                        <li><strong>메타 시트 다운로드 (0% ~ 20%):</strong> 서버의 버전 정보를 가져오는 단계입니다. 파일 크기가 작아 빠르게 완료되므로 전체 진행률의 20%를 할당합니다.</li>
                        <li><strong>CSV 데이터 다운로드 (20% ~ 80%):</strong> 모든 게임 데이터 CSV 파일을 다운로드하는 단계입니다. 파일이 많고 크기가 크므로 전체 진행률의 60%를 할당합니다. 각 파일의 다운로드 진행률을 0.2 ~ 0.8 범위로 매핑하여 표시합니다.</li>
                        <li><strong>데이터 파싱 (80% ~ 90%):</strong> 다운로드한 CSV 텍스트를 게임 객체로 변환하는 단계입니다. 백그라운드 스레드에서 실행되므로 UI가 멈추지 않습니다.</li>
                        <li><strong>최종 초기화 (90% ~ 100%):</strong> Managers 시스템을 초기화하고 게임을 시작할 준비를 하는 단계입니다.</li>
                    </ul>
                </div>

                <h3>1.2 핵심 로딩 로직</h3>
                <p>각 단계를 순차적으로 실행하며 진행률을 실시간으로 보고합니다.</p>

<pre><code><span class="c-cm">// LoadingManager.cs: 비동기 게임 데이터 로딩</span>
<span class="c-kw">public async</span> <span class="c-ty">Task</span>&lt;<span class="c-kw">bool</span>&gt; <span class="c-fn">LoadGameDataAsync</span>(<span class="c-ty">Action</span>&lt;<span class="c-kw">float</span>&gt; progressCallback = <span class="c-kw">null</span>)
{
    <span class="c-cm">// 1. 메타 시트 다운로드 (0% ~ 20%)</span>
    <span class="c-kw">bool</span> metaSuccess = <span class="c-kw">await</span> <span class="c-ty">ServerCSV_ConvertData</span>.<span class="c-fn">DownloadMetaSheetAsync</span>();
    <span class="c-kw">if</span> (!metaSuccess) {
        <span class="c-ty">Debug</span>.<span class="c-fn">LogError</span>(<span class="c-st">"메타 시트 다운로드 실패"</span>);
        <span class="c-kw">return false</span>;
    }
    progressCallback?.<span class="c-fn">Invoke</span>(<span class="c-st">0.2f</span>);

    <span class="c-cm">// 2. 모든 CSV 데이터 다운로드 (20% ~ 80%)</span>
    <span class="c-kw">bool</span> csvSuccess = <span class="c-kw">await</span> <span class="c-ty">ServerCSV_ConvertData</span>.<span class="c-fn">DownloadAllCSVAsync</span>((progress) => {
        <span class="c-cm">// CSV 다운로드 진행률을 20% ~ 80% 범위로 매핑</span>
        <span class="c-kw">float</span> mappedProgress = <span class="c-st">0.2f</span> + (progress * <span class="c-st">0.6f</span>);
        progressCallback?.<span class="c-fn">Invoke</span>(mappedProgress);
    });
    <span class="c-kw">if</span> (!csvSuccess) {
        <span class="c-ty">Debug</span>.<span class="c-fn">LogError</span>(<span class="c-st">"CSV 데이터 다운로드 실패"</span>);
        <span class="c-kw">return false</span>;
    }

    <span class="c-cm">// 3. 데이터 파싱 및 초기화 (80% ~ 90%)</span>
    <span class="c-kw">await</span> <span class="c-ty">Task</span>.<span class="c-fn">Run</span>(() => {
        Managers.Data.<span class="c-fn">ServerDataLoad</span>();  <span class="c-cm">// 백그라운드 스레드에서 파싱</span>
    });
    progressCallback?.<span class="c-fn">Invoke</span>(<span class="c-st">0.9f</span>);

    <span class="c-cm">// 4. 최종 초기화 (90% ~ 100%)</span>
    <span class="c-kw">await</span> <span class="c-ty">Task</span>.<span class="c-fn">Yield</span>();  <span class="c-cm">// 메인 스레드로 복귀</span>
    Managers.Game.<span class="c-fn">Init</span>();
    Managers.UI.<span class="c-fn">Init</span>();
    progressCallback?.<span class="c-fn">Invoke</span>(<span class="c-st">1.0f</span>);

    <span class="c-kw">return true</span>;
}</code></pre>

                <h3>1.3 진행률 매핑</h3>
                <p>각 단계의 진행률을 전체 로딩 진행률로 매핑하여 사용자에게 일관된 피드백을 제공합니다.</p>
                <div style="background: rgba(56, 139, 253, 0.1); border-left: 4px solid #388bfd; padding: 15px 20px; margin: 20px 0; border-radius: 6px;">
                    <div style="margin-bottom: 10px;"><strong>진행률 분배:</strong></div>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li>메타 시트 다운로드: 0% ~ 20%</li>
                        <li>CSV 데이터 다운로드: 20% ~ 80% (각 파일 다운로드 진행률을 0.2 ~ 0.8 범위로 매핑)</li>
                        <li>데이터 파싱: 80% ~ 90%</li>
                        <li>최종 초기화: 90% ~ 100%</li>
                    </ul>
                </div>

                <h3>1.4 로딩 UI 업데이트</h3>
                <p>비동기 작업은 백그라운드 스레드에서 실행되므로, UI 업데이트는 메인 스레드에서 안전하게 수행해야 합니다. 
                <span class="highlight">UnityMainThreadDispatcher</span>를 사용하여 백그라운드 스레드에서 메인 스레드로 작업을 전달합니다.</p>

<pre><code><span class="c-cm">// LoadingUI.cs: 로딩 UI 업데이트</span>
<span class="c-kw">public async void</span> <span class="c-fn">StartLoading</span>()
{
    <span class="c-ty">LoadingUI</span> loadingUI = <span class="c-fn">GetLoadingUI</span>();
    loadingUI.<span class="c-fn">Show</span>();  <span class="c-cm">// 로딩 UI 표시</span>

    <span class="c-kw">bool</span> success = <span class="c-kw">await</span> <span class="c-fn">LoadGameDataAsync</span>((progress) => {
        <span class="c-cm">// 백그라운드 스레드에서 호출되므로 메인 스레드로 전달</span>
        <span class="c-ty">UnityMainThreadDispatcher</span>.<span class="c-fn">Instance</span>().<span class="c-fn">Enqueue</span>(() => {
            loadingUI.<span class="c-fn">UpdateProgress</span>(progress);  <span class="c-cm">// 진행률 바 업데이트</span>
            loadingUI.<span class="c-fn">UpdateText</span>($<span class="c-st">"로딩 중... {progress * 100:F0}%"</span>);  <span class="c-cm">// 텍스트 업데이트</span>
        });
    });

    <span class="c-kw">if</span> (success) {
        loadingUI.<span class="c-fn">Hide</span>();
        <span class="c-fn">OnLoadingComplete</span>();  <span class="c-cm">// 로딩 완료 처리</span>
    } <span class="c-kw">else</span> {
        loadingUI.<span class="c-fn">ShowError</span>(<span class="c-st">"로딩 실패"</span>);  <span class="c-cm">// 에러 표시</span>
    }
}</code></pre>

                <h3>1.5 UnityMainThreadDispatcher</h3>
                <p>비동기 작업 중 UI 업데이트를 위해 사용하는 유틸리티입니다. 백그라운드 스레드에서 메인 스레드로 작업을 큐에 추가하여 
                다음 프레임에 실행되도록 합니다.</p>

<pre><code><span class="c-cm">// UnityMainThreadDispatcher.cs: 메인 스레드 작업 큐</span>
<span class="c-kw">public void</span> <span class="c-fn">Enqueue</span>(<span class="c-ty">Action</span> action)
{
    lock (executionQueue) {
        executionQueue.<span class="c-fn">Enqueue</span>(action);  <span class="c-cm">// 작업을 큐에 추가</span>
    }
}

<span class="c-kw">void</span> <span class="c-fn">Update</span>()
{
    <span class="c-cm">// 매 프레임 큐에 있는 작업들을 메인 스레드에서 실행</span>
    <span class="c-kw">while</span> (executionQueue.Count > <span class="c-st">0</span>) {
        executionQueue.<span class="c-fn">Dequeue</span>().<span class="c-fn">Invoke</span>();
    }
}</code></pre>

                <h2>전체 시스템 기술적 특징</h2>
                <p>비동기 로딩 시스템의 핵심 기술적 특징입니다.</p>
                <ul>
                    <li><span class="highlight">비동기 처리:</span> async/await를 활용하여 메인 스레드 블로킹 방지</li>
                    <li><span class="highlight">진행률 표시:</span> 실시간 진행률 콜백으로 사용자에게 명확한 피드백 제공</li>
                    <li><span class="highlight">에러 처리:</span> 각 단계별 실패 시 적절한 에러 메시지 표시</li>
                    <li><span class="highlight">UI 반응성:</span> UnityMainThreadDispatcher를 통한 안전한 UI 업데이트</li>
                    <li><span class="highlight">백그라운드 파싱:</span> Task.Run을 사용하여 무거운 파싱 작업을 백그라운드에서 수행</li>
                    <li><span class="highlight">순차적 로딩:</span> 각 단계를 순차적으로 실행하여 의존성 문제 방지</li>
                </ul>
                </div>

                <div style="height: 100px;"></div>
            </div>
        </div>
    </div>

    <!-- Slime Project Modal -->
    <div id="modal-overlay-slime" class="modal-overlay" onclick="closeModal('slime')">
        <div class="modal-container" onclick="event.stopPropagation()">
            <div class="modal-body">
                <div class="modal-header-nav">
                    <div class="mono" style="color: var(--accent-color);">PROJECT REPORT // SLIME PROJECT</div>
                    <button onclick="closeModal('slime')" style="background: none; border: 1px solid var(--accent-color); color: var(--accent-color); padding: 8px 20px; border-radius: 6px; cursor: pointer; font-family: 'Fira Code'; font-size: 0.8rem;">[X] DISCONNECT</button>
                </div>
                
                <h1 style="font-size: 2.5rem; margin-bottom: 30px; color: #f0f6fc;">Slime Project: 상태머신 기반 게임 로직 시스템</h1>
                
                <div style="background: rgba(88, 166, 255, 0.1); border: 2px solid var(--accent-color); border-radius: 12px; padding: 30px; margin-bottom: 40px;">
                    <h3 style="color: var(--accent-color); margin-bottom: 20px; font-family: 'Fira Code', monospace; font-size: 1.2rem;">프로젝트 개요</h3>
                    <p style="color: var(--text-color); line-height: 1.8; margin-bottom: 25px;">
                        Slime Project는 하드코어 액션 퍼즐 플랫포머 게임으로, <span class="highlight">FiniteStateMachine 기반 상태 관리 시스템</span>을 통해 
                        모든 게임 엔티티의 행동을 체계적으로 관리합니다. 플레이어 슬라임의 움직임, 변신 능력, 그리고 변신 시 능력 변화를 구현했으며, 
                        보스 몬스터와 일반 몬스터의 AI 로직을 담당하여 확장 가능한 게임 시스템을 구축했습니다.
                    </p>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 20px; margin-top: 25px;">
                        <div style="background: rgba(88, 166, 255, 0.05); border: 1px solid var(--accent-color); border-radius: 8px; padding: 20px; text-align: center;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 10px; font-family: 'Fira Code', monospace; font-size: 0.95rem;">상태머신 시스템</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.6;">FiniteStateMachine 기반<br>상태 전환 관리</div>
                        </div>
                        <div style="background: rgba(88, 166, 255, 0.05); border: 1px solid var(--accent-color); border-radius: 8px; padding: 20px; text-align: center;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 10px; font-family: 'Fira Code', monospace; font-size: 0.95rem;">플레이어 시스템</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.6;">슬라임 움직임/공격<br>변신 능력 구현</div>
                        </div>
                        <div style="background: rgba(88, 166, 255, 0.05); border: 1px solid var(--accent-color); border-radius: 8px; padding: 20px; text-align: center;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 10px; font-family: 'Fira Code', monospace; font-size: 0.95rem;">보스 AI</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.6;">델리게이트 기반 스킬<br>HP 기반 업그레이드</div>
                        </div>
                        <div style="background: rgba(88, 166, 255, 0.05); border: 1px solid var(--accent-color); border-radius: 8px; padding: 20px; text-align: center;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 10px; font-family: 'Fira Code', monospace; font-size: 0.95rem;">일반 몬스터 AI</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.6;">상태머신 기반<br>행동 패턴 구현</div>
                        </div>
                    </div>
                </div>

                <div class="tab-container">
                    <button class="tab-button active" onclick="switchTabSlime('state-machine')">상태머신 시스템</button>
                    <button class="tab-button" onclick="switchTabSlime('player')">플레이어 슬라임 시스템</button>
                    <button class="tab-button" onclick="switchTabSlime('enemy')">보스/일반 몬스터 AI</button>
                </div>

                <div id="slime-state-machine-tab" class="tab-content active">
                <h2>1. FiniteStateMachine 기반 상태 관리 시스템</h2>
                <p>모든 몬스터와 게임 엔티티의 행동을 <span class="highlight">FiniteStateMachine</span> 패턴으로 관리하는 시스템을 구현했습니다. 
                State 베이스 클래스를 통해 각 상태의 Enter/Exit/LogicUpdate/PhysicsUpdate 라이프사이클을 체계적으로 관리합니다.</p>

                <h3>1.1 상태머신 구조</h3>
                <p>FiniteStateMachine은 현재 상태를 관리하고, 상태 전환 시 이전 상태의 Exit와 새 상태의 Enter를 자동으로 호출합니다.</p>

                <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid var(--border-color); border-radius: 12px; padding: 30px; margin: 30px 0;">
                    <div style="color: var(--accent-color); font-family: 'Fira Code', monospace; font-size: 1.1rem; font-weight: 700; margin-bottom: 20px; text-align: center; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">상태머신 상태 전환 플로우</div>
                    
                    <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                        <div style="background: rgba(35, 134, 54, 0.2); border: 2px solid var(--sub-accent); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 8px;">시작: 상태머신 초기화</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">Init(startingState) 호출<br><span style="color: var(--code-comment);">초기 상태 설정 및 Enter() 호출</span></div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">현재 상태 실행</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">LogicUpdate() - 매 프레임 호출<br>PhysicsUpdate() - FixedUpdate에서 호출<br>DoChecks() - 상태 전환 조건 확인</div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(255, 123, 114, 0.15); border: 2px solid #ff7b72; border-radius: 50px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: #ff7b72; font-weight: 700; margin-bottom: 8px;">상태 전환 조건 충족?</div>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; width: 100%; max-width: 600px; margin-top: 10px;">
                            <div style="background: rgba(35, 134, 54, 0.2); border: 2px solid var(--sub-accent); border-radius: 8px; padding: 12px; text-align: center;">
                                <div style="color: var(--sub-accent); font-weight: 700; font-size: 0.9rem; margin-bottom: 5px;">NO</div>
                                <div style="color: #8b949e; font-size: 0.8rem;">현재 상태 유지<br>계속 실행</div>
                            </div>
                            <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 12px; text-align: center;">
                                <div style="color: var(--accent-color); font-weight: 700; font-size: 0.9rem; margin-bottom: 5px;">YES</div>
                                <div style="color: #8b949e; font-size: 0.8rem;">ChangeState(newState)<br>이전 상태 Exit()<br>새 상태 Enter()</div>
                            </div>
                        </div>
                    </div>
                </div>

<pre><code><span class="c-cm">// FiniteStateMachine.cs: 상태머신 핵심 로직</span>
<span class="c-kw">public class</span> <span class="c-ty">FiniteStateMachine</span>
{
    <span class="c-kw">public</span> <span class="c-ty">State</span> currentState { <span class="c-kw">get</span>; <span class="c-kw">private set</span>; } 

    <span class="c-cm">// 상태머신 초기화: 시작 상태 설정 및 Enter() 호출</span>
    <span class="c-kw">public void</span> <span class="c-fn">Init</span>(<span class="c-ty">State</span> startingState) 
    {
        currentState = startingState;     <span class="c-cm">// 현재 상태 설정</span>
        currentState.<span class="c-fn">Enter</span>();             <span class="c-cm">// 시작 상태 진입</span>
    }

    <span class="c-cm">// 상태 전환: 이전 상태 종료 후 새 상태 진입</span>
    <span class="c-kw">public void</span> <span class="c-fn">ChangeState</span>(<span class="c-ty">State</span> newState) 
    {
        currentState.<span class="c-fn">Exit</span>();                <span class="c-cm">// 이전 상태 종료</span>
        currentState = newState;            <span class="c-cm">// 새 상태로 전환</span>
        currentState.<span class="c-fn">Enter</span>();               <span class="c-cm">// 새 상태 진입</span>
    }
}</code></pre>

                <h3>1.2 State 베이스 클래스</h3>
                <p>모든 상태는 State 베이스 클래스를 상속받아 구현됩니다. 각 상태는 Enter/Exit/LogicUpdate/PhysicsUpdate 라이프사이클을 가집니다.</p>

<pre><code><span class="c-cm">// State.cs: 모든 상태의 베이스 클래스</span>
<span class="c-kw">public class</span> <span class="c-ty">State</span>
{
    <span class="c-kw">protected</span> <span class="c-ty">FiniteStateMachine</span> stateMachine;  <span class="c-cm">// 상태머신 참조</span>
    <span class="c-kw">protected</span> <span class="c-ty">Entity</span> entity;                    <span class="c-cm">// 엔티티 참조</span>
    <span class="c-kw">protected float</span> startTime;                  <span class="c-cm">// 상태 시작 시간</span>
    <span class="c-kw">protected string</span> animBoolName;              <span class="c-cm">// 애니메이션 파라미터 이름</span>

    <span class="c-kw">public virtual void</span> <span class="c-fn">Enter</span>()                     <span class="c-cm">// 상태 진입 시 호출</span>
    {
        startTime = <span class="c-ty">Time</span>.time;                      <span class="c-cm">// 시작 시간 기록</span>
        entity.anim.<span class="c-fn">SetBool</span>(animBoolName, <span class="c-kw">true</span>);    <span class="c-cm">// 애니메이션 트리거</span>
        <span class="c-fn">DoChecks</span>();                                 <span class="c-cm">// 상태 전환 조건 확인</span>
    }
    
    <span class="c-kw">public virtual void</span> <span class="c-fn">Exit</span>()                     <span class="c-cm">// 상태 종료 시 호출</span>
    {
        entity.anim.<span class="c-fn">SetBool</span>(animBoolName, <span class="c-kw">false</span>);   <span class="c-cm">// 애니메이션 종료</span>
    }
    
    <span class="c-kw">public virtual void</span> <span class="c-fn">LogicUpdate</span>()         <span class="c-cm">// Update()에서 호출</span>
    {
        <span class="c-cm">// 상태별 로직 업데이트</span>
    }
    
    <span class="c-kw">public virtual void</span> <span class="c-fn">PhysicsUpdate</span>()      <span class="c-cm">// FixedUpdate()에서 호출</span>
    {
        <span class="c-fn">DoChecks</span>();                                 <span class="c-cm">// 물리 업데이트마다 조건 확인</span>
    }

    <span class="c-kw">public virtual void</span> <span class="c-fn">DoChecks</span>()          <span class="c-cm">// 상태 전환 조건 확인</span>
    {
        <span class="c-cm">// 플레이어 감지, 벽/절벽 감지 등</span>
    }
}</code></pre>

                <h3>1.3 상태 전환 예시</h3>
                <p>IdleState와 MoveState를 예시로 상태 전환 로직을 설명합니다.</p>

                <div style="background: rgba(56, 139, 253, 0.1); border-left: 4px solid #388bfd; padding: 20px; margin: 25px 0; border-radius: 6px;">
                    <div style="margin-bottom: 15px;"><strong style="color: var(--accent-color);">IdleState → MoveState 전환:</strong></div>
                    <div style="color: var(--text-color); line-height: 1.8; margin-left: 10px;">
                        <div style="margin-bottom: 10px;">• <strong>IdleState.Enter():</strong> 속도를 0으로 설정, 랜덤 Idle 시간 생성</div>
                        <div style="margin-bottom: 10px;">• <strong>IdleState.LogicUpdate():</strong> Idle 시간이 지나면 isIdleTimeOver = true</div>
                        <div style="margin-bottom: 10px;">• <strong>IdleState.DoChecks():</strong> 플레이어가 최소 감지 범위 내에 있는지 확인</div>
                        <div style="margin-bottom: 10px;">• <strong>전환 조건:</strong> isIdleTimeOver == true 또는 isPlayerInMinAgroRange == true</div>
                        <div>• <strong>MoveState.Enter():</strong> 이동 속도 설정, 랜덤 Move 시간 생성</div>
                    </div>
                </div>

                <h3>1.4 기술적 특징</h3>
                <ul>
                    <li><span class="highlight">확장성:</span> 새로운 상태를 추가할 때 State를 상속받아 구현하면 자동으로 상태머신에 통합</li>
                    <li><span class="highlight">관심사 분리:</span> 각 상태의 로직이 독립적으로 관리되어 코드 유지보수성 향상</li>
                    <li><span class="highlight">애니메이션 연동:</span> 상태 전환 시 자동으로 애니메이션 파라미터를 설정하여 애니메이션과 동기화</li>
                    <li><span class="highlight">조건 기반 전환:</span> DoChecks()를 통해 상태 전환 조건을 명확하게 관리</li>
                </ul>
                </div>

                <div id="slime-player-tab" class="tab-content">
                <h2>1. 플레이어 슬라임 시스템</h2>
                <p>플레이어 슬라임의 움직임, 공격, 대시, 피격 처리를 구현했습니다. <span class="highlight">컴포지션 패턴</span>을 활용하여 
                각 기능을 독립적인 클래스로 분리하고, Player_Slime에서 통합 관리합니다.</p>

                <h3>1.1 시스템 구조</h3>
                <p>Player_Slime은 Player_Entity를 상속받고, 각 기능을 컴포넌트로 관리합니다.</p>

                <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid var(--border-color); border-radius: 12px; padding: 30px; margin: 30px 0;">
                    <div style="color: var(--accent-color); font-family: 'Fira Code', monospace; font-size: 1.1rem; font-weight: 700; margin-bottom: 20px; text-align: center; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">플레이어 슬라임 시스템 구조</div>
                    
                    <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">Player_Slime (메인 컨트롤러)</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">Player_Entity 상속<br>모든 컴포넌트 통합 관리</div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; width: 100%; max-width: 600px;">
                            <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 12px; text-align: center;">
                                <div style="color: var(--accent-color); font-weight: 700; font-size: 0.9rem; margin-bottom: 5px;">Player_SlimeMovement</div>
                                <div style="color: #8b949e; font-size: 0.8rem;">이동, 점프 처리<br>키보드 입력 관리</div>
                            </div>
                            <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 12px; text-align: center;">
                                <div style="color: var(--accent-color); font-weight: 700; font-size: 0.9rem; margin-bottom: 5px;">Player_Attack</div>
                                <div style="color: #8b949e; font-size: 0.8rem;">근접 공격 처리<br>데미지 트리거</div>
                            </div>
                            <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 12px; text-align: center;">
                                <div style="color: var(--accent-color); font-weight: 700; font-size: 0.9rem; margin-bottom: 5px;">Player_Dash</div>
                                <div style="color: #8b949e; font-size: 0.8rem;">대시 이동<br>무적 프레임</div>
                            </div>
                            <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 12px; text-align: center;">
                                <div style="color: var(--accent-color); font-weight: 700; font-size: 0.9rem; margin-bottom: 5px;">Player_Dead</div>
                                <div style="color: #8b949e; font-size: 0.8rem;">죽음 처리<br>게임 오버 연동</div>
                            </div>
                        </div>
                    </div>
                </div>

<pre><code><span class="c-cm">// Player_Slime.cs: 플레이어 슬라임 메인 클래스</span>
<span class="c-kw">public class</span> <span class="c-ty">Player_Slime</span> : <span class="c-ty">Player_Entity</span>
{
    <span class="c-kw">public</span> <span class="c-ty">Player_SlimeMovement</span> movement { <span class="c-kw">get</span>; <span class="c-kw">private set</span>; }
    <span class="c-kw">public</span> <span class="c-ty">Player_Attack</span> attack { <span class="c-kw">get</span>; <span class="c-kw">private set</span>; }
    <span class="c-kw">public</span> <span class="c-ty">Player_Dash</span> dash { <span class="c-kw">get</span>; <span class="c-kw">private set</span>; }
    <span class="c-kw">public</span> <span class="c-ty">Player_Dead</span> dead { <span class="c-kw">get</span>; <span class="c-kw">private set</span>; }

    <span class="c-kw">protected override void</span> <span class="c-fn">Start</span>()
    {
        <span class="c-kw">base</span>.<span class="c-fn">Start</span>();
        
        <span class="c-cm">// 각 기능 컴포넌트 초기화</span>
        movement = <span class="c-kw">new</span> <span class="c-ty">Player_SlimeMovement</span>(<span class="c-kw">this</span>, movementData, <span class="c-kw">this</span>);
        attack = <span class="c-kw">new</span> <span class="c-ty">Player_Attack</span>(<span class="c-kw">this</span>, attackData, meleePos);
        dash = <span class="c-kw">new</span> <span class="c-ty">Player_Dash</span>(<span class="c-kw">this</span>, dashData);
        dead = <span class="c-kw">new</span> <span class="c-ty">Player_Dead</span>(<span class="c-kw">this</span>, deadData);
    }

    <span class="c-kw">protected override void</span> <span class="c-fn">Update</span>()
    {
        <span class="c-kw">base</span>.<span class="c-fn">Update</span>();
        <span class="c-kw">if</span> (isDead) <span class="c-kw">return</span>;

        <span class="c-fn">HandleDash</span>();      <span class="c-cm">// 대시 처리</span>
        <span class="c-fn">HandleAttack</span>();     <span class="c-cm">// 공격 처리</span>
        <span class="c-fn">HandleStun</span>();     <span class="c-cm">// 스턴 처리</span>
    }

    <span class="c-kw">private void</span> <span class="c-fn">HandleStun</span>()
    {
        <span class="c-kw">if</span> (isStunned) {
            <span class="c-cm">// 스턴 시간 관리</span>
            <span class="c-cm">// ...</span>
        } <span class="c-kw">else</span> {
            <span class="c-fn">HandleMovement</span>();  <span class="c-cm">// 스턴이 아닐 때만 이동 처리</span>
        }
    }
}</code></pre>

                <h3>1.2 움직임 시스템</h3>
                <p>Player_SlimeMovement는 키보드 입력을 받아 플레이어를 이동시키고 점프를 처리합니다.</p>

<pre><code><span class="c-cm">// Player_SlimeMovement.cs: 슬라임 움직임 처리</span>
<span class="c-kw">public class</span> <span class="c-ty">Player_SlimeMovement</span> : <span class="c-ty">Player_Movement</span>
{
    <span class="c-kw">private</span> <span class="c-ty">Player_Slime</span> player;
    
    <span class="c-kw">public void</span> <span class="c-fn">OnKeyboard</span>()
    {
        <span class="c-kw">if</span> (!entity.isStunned && !entity.isDead && !player.dash.canDash) {
            <span class="c-cm">// 좌우 이동 입력 처리</span>
            <span class="c-kw">if</span> (Managers.Input.isMovingLeft) {
                input_Direction = -1f;
            } <span class="c-kw">else if</span> (Managers.Input.isMovingRight) {
                input_Direction = 1f;
            } <span class="c-kw">else</span> {
                entity.anim.<span class="c-fn">SetBool</span>(<span class="c-st">"Walk"</span>, <span class="c-kw">false</span>);
                input_Direction = 0f;
            }

            <span class="c-cm">// 캐릭터 방향 전환</span>
            <span class="c-kw">if</span> (input_Direction != 0f) {
                entity.anim.<span class="c-fn">SetBool</span>(<span class="c-st">"Walk"</span>, <span class="c-kw">true</span>);
                entity.<span class="c-fn">Direction_Flip</span>((<span class="c-kw">int</span>)input_Direction);
            }

            <span class="c-cm">// 점프 처리</span>
            <span class="c-kw">if</span> (<span class="c-ty">Input</span>.<span class="c-fn">GetKeyDown</span>((<span class="c-ty">KeyCode</span>.Space)) && <span class="c-fn">CanJump</span>()) {
                <span class="c-fn">HandleJumping</span>();
            }

            <span class="c-fn">MovementUpdate</span>();
        }
    }
}</code></pre>

                <h3>1.3 변신 능력 시스템</h3>
                <p>플레이어가 몬스터를 처치하면 해당 몬스터의 형태로 변신할 수 있습니다. 변신 시 각 형태의 고유 능력을 사용할 수 있습니다.</p>

                <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid var(--border-color); border-radius: 12px; padding: 30px; margin: 30px 0;">
                    <div style="color: var(--accent-color); font-family: 'Fira Code', monospace; font-size: 1.1rem; font-weight: 700; margin-bottom: 20px; text-align: center; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">변신 능력 시스템</div>
                    
                    <div style="display: flex; flex-direction: column; gap: 20px;">
                        <div>
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 10px; font-family: 'Fira Code', monospace;">슬라임 (기본 형태)</div>
                            <div style="background: rgba(88, 166, 255, 0.1); padding: 15px; border-radius: 6px; border-left: 4px solid var(--accent-color);">
                                <div style="color: var(--text-color); line-height: 1.8;">
                                    • <strong>기본 이동:</strong> 좌우 이동, 점프<br>
                                    • <strong>공격:</strong> 원거리 포물선 공격 (탄알 개수 제한)<br>
                                    • <strong>대시:</strong> 짧은 거리 빠른 이동 (무적 프레임)
                                </div>
                            </div>
                        </div>
                        
                        <div>
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 10px; font-family: 'Fira Code', monospace;">토끼 (변신 형태)</div>
                            <div style="background: rgba(88, 166, 255, 0.1); padding: 15px; border-radius: 6px; border-left: 4px solid var(--accent-color);">
                                <div style="color: var(--text-color); line-height: 1.8;">
                                    • <strong>추가 능력:</strong> 더블 점프, 벽 점프<br>
                                    • <strong>Player_FormMovement:</strong> Rabbit_ability와 연동하여 벽 점프 중 입력 차단<br>
                                    • <strong>변신 시 변화:</strong> 이동 속도 증가, 점프 능력 향상
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

<pre><code><span class="c-cm">// Player_Form.cs: 변신 형태 플레이어</span>
<span class="c-kw">public class</span> <span class="c-ty">Player_Form</span> : <span class="c-ty">Player_Entity</span>
{
    <span class="c-kw">public</span> <span class="c-ty">Player_FormMovement</span> movement { <span class="c-kw">get</span>; <span class="c-kw">private set</span>; }
    <span class="c-cm">// ... 공격, 대시, 죽음 컴포넌트</span>

    <span class="c-kw">protected override void</span> <span class="c-fn">Start</span>()
    {
        <span class="c-kw">base</span>.<span class="c-fn">Start</span>();
        <span class="c-cm">// 변신 형태 전용 컴포넌트 초기화</span>
        movement = <span class="c-kw">new</span> <span class="c-ty">Player_FormMovement</span>(<span class="c-kw">this</span>, movementData, <span class="c-kw">this</span>);
        <span class="c-cm">// ...</span>
    }
}

<span class="c-cm">// Player_FormMovement.cs: 변신 형태 움직임 (토끼 능력 연동)</span>
<span class="c-kw">public class</span> <span class="c-ty">Player_FormMovement</span> : <span class="c-ty">Player_Movement</span>
{
    <span class="c-kw">private</span> <span class="c-ty">Rabbit_ability</span> rabbit_Ability;
    
    <span class="c-kw">public void</span> <span class="c-fn">OnKeyboard</span>()
    {
        <span class="c-kw">if</span> (rabbit_Ability != <span class="c-kw">null</span> && rabbit_Ability.isWallJumping)            
            <span class="c-kw">return</span>;  <span class="c-cm">// 벽 점프 중에는 입력 차단</span>
        
        <span class="c-cm">// 기본 이동 로직 (슬라임과 동일)</span>
        <span class="c-cm">// ...</span>
        
        <span class="c-cm">// 점프 처리 (토끼 능력과 연동)</span>
        <span class="c-kw">if</span>(<span class="c-ty">Input</span>.<span class="c-fn">GetKeyDown</span>((<span class="c-ty">KeyCode</span>.Space)) && <span class="c-fn">CanJump</span>()) {
            <span class="c-kw">if</span>(rabbit_Ability == <span class="c-kw">null</span>)
                <span class="c-fn">HandleJumping</span>();
            <span class="c-kw">else if</span>(rabbit_Ability != <span class="c-kw">null</span> && !rabbit_Ability.isWallJumping)
                <span class="c-fn">HandleJumping</span>();
        }
    }
}</code></pre>

                <h3>1.4 피격 및 스턴 처리</h3>
                <p>피격 시 무적 시간과 스턴 상태를 관리하여 게임 플레이의 공정성을 보장합니다.</p>

                <div style="background: rgba(56, 139, 253, 0.1); border-left: 4px solid #388bfd; padding: 20px; margin: 25px 0; border-radius: 6px;">
                    <div style="margin-bottom: 15px;"><strong style="color: var(--accent-color);">피격 처리 로직:</strong></div>
                    <div style="color: var(--text-color); line-height: 1.8; margin-left: 10px;">
                        <div style="margin-bottom: 10px;">• <strong>무적 상태:</strong> 대시 중이거나 피격 중일 때는 추가 피격 무시</div>
                        <div style="margin-bottom: 10px;">• <strong>스턴 처리:</strong> 피격 시 일정 시간 동안 이동 불가 (Last_StunTime 관리)</div>
                        <div style="margin-bottom: 10px;">• <strong>시각적 피드백:</strong> 피격 시 스프라이트 색상 변경 또는 히트 이펙트 적용</div>
                        <div>• <strong>HP 관리:</strong> HP가 0 이하가 되면 죽음 상태로 전환하고 게임 오버 처리</div>
                    </div>
                </div>

                <h3>1.5 기술적 특징</h3>
                <ul>
                    <li><span class="highlight">컴포지션 패턴:</span> 각 기능을 독립적인 클래스로 분리하여 코드 재사용성과 유지보수성 향상</li>
                    <li><span class="highlight">상태 기반 처리:</span> 스턴, 대시, 죽음 등 상태에 따라 입력 처리 로직 분기</li>
                    <li><span class="highlight">변신 시스템:</span> 슬라임과 변신 형태를 별도 클래스로 구현하여 각 형태의 고유 능력 제공</li>
                    <li><span class="highlight">능력 연동:</span> 변신 형태의 특수 능력(Rabbit_ability 등)과 움직임 시스템 연동</li>
                </ul>
                </div>

                <div id="slime-enemy-tab" class="tab-content">
                <h2>1. 보스 몬스터 AI 시스템</h2>
                <p>보스 몬스터의 스킬 시스템을 <span class="highlight">델리게이트 기반</span>으로 구현하여 확장 가능한 AI를 설계했습니다. 
                HP에 따라 스킬이 업그레이드되며, 거리와 상황에 따라 적절한 스킬을 선택합니다.</p>

                <h3>1.1 보스 스킬 시스템 구조</h3>
                <p>MainBossBear는 델리게이트 배열을 사용하여 스킬을 관리합니다.</p>

                <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid var(--border-color); border-radius: 12px; padding: 30px; margin: 30px 0;">
                    <div style="color: var(--accent-color); font-family: 'Fira Code', monospace; font-size: 1.1rem; font-weight: 700; margin-bottom: 20px; text-align: center; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">보스 AI 의사결정 플로우</div>
                    
                    <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                        <div style="background: rgba(35, 134, 54, 0.2); border: 2px solid var(--sub-accent); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 8px;">시작: 보스 활성화</div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">1단계: 플레이어 거리 계산</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">플레이어와의 거리 및 방향 계산<br><span style="color: var(--code-comment);">Distance_Player = magnitude * normalized.x</span></div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">2단계: 스킬 사용 가능 여부 확인</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">현재 스킬이 실행 중인지 확인<br><span style="color: var(--code-comment);">!IsSmash && !IsDash && !IsRumbling</span></div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(255, 123, 114, 0.15); border: 2px solid #ff7b72; border-radius: 50px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: #ff7b72; font-weight: 700; margin-bottom: 8px;">3단계: 랜덤 스킬 선택</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">Smash, Dash, Rumbling 중 랜덤 선택<br><span style="color: var(--code-comment);">Random.Range(Smash, Skill_Max)</span></div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">4단계: 스킬 범위 확인 및 실행</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">각 스킬의 범위 조건 확인<br>HP 50% 이하 시 업그레이드 버전 실행<br><span style="color: var(--code-comment);">IsSkillUpgrade 플래그</span></div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(35, 134, 54, 0.2); border: 2px solid var(--sub-accent); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 8px;">완료: 스킬 실행</div>
                        </div>
                    </div>
                </div>

<pre><code><span class="c-cm">// MainBossBear.cs: 보스 스킬 시스템</span>
<span class="c-kw">public class</span> <span class="c-ty">MainBossBear</span> : <span class="c-ty">BossBearSetting</span>
{
    <span class="c-kw">enum</span> <span class="c-ty">BossBear_SkillEnum</span>
    {
        Rest, Smash, Dash, Rumbling, Skill_Max
    }

    <span class="c-kw">private delegate void</span> <span class="c-ty">BossBear_SkillAction</span>();
    <span class="c-kw">private</span> <span class="c-ty">BossBear_SkillAction</span>[] BossBear_Skills;

    <span class="c-kw">public bool</span> IsSkillUpgrade;  <span class="c-cm">// HP 50% 이하 시 true</span>

    <span class="c-kw">public override void</span> <span class="c-fn">Start</span>()
    {
        <span class="c-kw">base</span>.<span class="c-fn">Start</span>();
        <span class="c-cm">// 델리게이트 배열에 스킬 메서드 할당</span>
        BossBear_Skills = <span class="c-kw">new</span> <span class="c-ty">BossBear_SkillAction</span>[<span class="c-st">4</span>] { Rest, Smash, Dash, Rumbling };
    }

    <span class="c-kw">private void</span> <span class="c-fn">RandomBossBearSkillState</span>()
    {
        <span class="c-kw">int</span> RandomSkill_Index = <span class="c-ty">Random</span>.<span class="c-fn">Range</span>((<span class="c-kw">int</span>)<span class="c-ty">BossBear_SkillEnum</span>.Smash, (<span class="c-kw">int</span>)<span class="c-ty">BossBear_SkillEnum</span>.Skill_Max);
        
        <span class="c-cm">// 플레이어와의 거리에 따라 이동 또는 대기</span>
        <span class="c-kw">if</span> (IsWalking && <span class="c-st">0.7f</span> < <span class="c-ty">Mathf</span>.<span class="c-fn">Abs</span>(Distance_Player)) {
            rb.velocity = <span class="c-kw">new</span> <span class="c-ty">Vector2</span>(_PublicBossBear_Flip.Direction * Speed, rb.velocity.y);
            anim.<span class="c-fn">SetBool</span>(<span class="c-st">"Walk"</span>, <span class="c-kw">true</span>);
        }
        
        <span class="c-cm">// 선택된 스킬 실행</span>
        BossBear_Skills[RandomSkill_Index].<span class="c-fn">Invoke</span>();
    }

    <span class="c-kw">private void</span> <span class="c-fn">Smash</span>()
    {
        <span class="c-kw">if</span> (_MainBossBear_Smash.<span class="c-fn">IsInRangeSmash</span>()) {
            _MainBossBear_Smash.<span class="c-fn">Smash_Start</span>(IsSkillUpgrade);  <span class="c-cm">// 업그레이드 여부 전달</span>
        }
    }

    <span class="c-kw">public override void</span> <span class="c-fn">OnDamaged</span>(<span class="c-ty">AttackDetail</span> attackDetails)
    {
        <span class="c-kw">base</span>.<span class="c-fn">OnDamaged</span>(attackDetails);
        <span class="c-cm">// HP 50% 이하 시 스킬 업그레이드 활성화</span>
        <span class="c-kw">if</span> (currentHealth <= maxHealth * <span class="c-st">0.5f</span>)
            IsSkillUpgrade = <span class="c-kw">true</span>;
    }
}</code></pre>

                <h3>1.2 스킬별 범위 및 조건</h3>
                <p>각 스킬은 플레이어와의 거리나 위치에 따라 사용 가능 여부를 판단합니다.</p>

                <div style="background: rgba(56, 139, 253, 0.1); border-left: 4px solid #388bfd; padding: 20px; margin: 25px 0; border-radius: 6px;">
                    <div style="margin-bottom: 15px;"><strong style="color: var(--accent-color);">스킬별 특징:</strong></div>
                    <ul style="margin-left: 20px; color: var(--text-color); line-height: 1.8;">
                        <li><strong>Smash:</strong> 근거리 강력한 공격. 범위 내에 플레이어가 있을 때만 사용</li>
                        <li><strong>Dash:</strong> 중거리 돌진 공격. 플레이어 방향으로 빠르게 이동하며 공격</li>
                        <li><strong>Rumbling:</strong> 원거리 범위 공격. 플레이어가 멀리 있을 때 사용, 연속 사용 방지</li>
                        <li><strong>Rest:</strong> 스킬 쿨타임 대기. 짧은 시간 대기 후 다음 스킬 선택</li>
                    </ul>
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color);">
                        <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">HP 기반 업그레이드:</div>
                        <div style="color: var(--text-color); line-height: 1.6;">HP가 50% 이하로 떨어지면 IsSkillUpgrade가 true가 되어 모든 스킬이 강화된 버전으로 실행됩니다. 이를 통해 보스전의 난이도가 점진적으로 증가합니다.</div>
                    </div>
                </div>

                <h2>2. 일반 몬스터 AI 시스템</h2>
                <p>일반 몬스터는 <span class="highlight">상태머신 기반 AI</span>를 사용하여 플레이어를 감지하고 추적하며 공격합니다. 
                각 몬스터 타입(Ant, Bear, Rabbit, Spider)은 공통 상태를 상속받아 구현되며, 필요에 따라 특수 상태를 추가합니다.</p>

                <h3>2.1 몬스터 상태 구조</h3>
                <p>AntMonster를 예시로 상태머신 기반 AI 구조를 설명합니다.</p>

                <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid var(--border-color); border-radius: 12px; padding: 30px; margin: 30px 0;">
                    <div style="color: var(--accent-color); font-family: 'Fira Code', monospace; font-size: 1.1rem; font-weight: 700; margin-bottom: 20px; text-align: center; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">일반 몬스터 AI 상태 전환 플로우</div>
                    
                    <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                        <div style="background: rgba(35, 134, 54, 0.2); border: 2px solid var(--sub-accent); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--sub-accent); font-weight: 700; margin-bottom: 8px;">시작: MoveState</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">초기 상태로 이동 시작</div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">MoveState 실행</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">이동 중 벽/절벽 감지<br>플레이어 감지 범위 확인</div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(255, 123, 114, 0.15); border: 2px solid #ff7b72; border-radius: 50px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: #ff7b72; font-weight: 700; margin-bottom: 8px;">플레이어 감지?</div>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; width: 100%; max-width: 600px; margin-top: 10px;">
                            <div style="background: rgba(35, 134, 54, 0.2); border: 2px solid var(--sub-accent); border-radius: 8px; padding: 12px; text-align: center;">
                                <div style="color: var(--sub-accent); font-weight: 700; font-size: 0.9rem; margin-bottom: 5px;">NO</div>
                                <div style="color: #8b949e; font-size: 0.8rem;">IdleState 또는<br>계속 MoveState</div>
                            </div>
                            <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 12px; text-align: center;">
                                <div style="color: var(--accent-color); font-weight: 700; font-size: 0.9rem; margin-bottom: 5px;">YES</div>
                                <div style="color: #8b949e; font-size: 0.8rem;">PlayerDetectedState<br>→ LookForPlayerState</div>
                            </div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">공격 범위 내?</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">MeleeAttackState 실행<br>공격 쿨타임 확인</div>
                        </div>
                        
                        <div style="color: var(--accent-color); font-size: 1.5rem;">↓</div>
                        
                        <div style="background: rgba(88, 166, 255, 0.15); border: 2px solid var(--accent-color); border-radius: 8px; padding: 15px 25px; text-align: center; width: 100%; max-width: 600px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px;">피격 시</div>
                            <div style="color: #8b949e; font-size: 0.85rem;">StunState (스턴 시)<br>DeadState (HP 0 이하)</div>
                        </div>
                    </div>
                </div>

<pre><code><span class="c-cm">// AntMonster.cs: 일반 몬스터 AI 구조</span>
<span class="c-kw">public class</span> <span class="c-ty">AntMonster</span> : <span class="c-ty">Monster_Entity</span>
{
    <span class="c-kw">public</span> <span class="c-ty">Ant_IdleState</span> idleState { <span class="c-kw">get</span>; <span class="c-kw">private set</span>; }
    <span class="c-kw">public</span> <span class="c-ty">Ant_MoveState</span> moveState { <span class="c-kw">get</span>; <span class="c-kw">private set</span>; }
    <span class="c-kw">public</span> <span class="c-ty">Ant_PlayerDetectedState</span> playerDetectedState { <span class="c-kw">get</span>; <span class="c-kw">private set</span>; }
    <span class="c-kw">public</span> <span class="c-ty">Ant_MeleeAttackState</span> meleeAttackState { <span class="c-kw">get</span>; <span class="c-kw">private set</span>; }
    <span class="c-kw">public</span> <span class="c-ty">Ant_StunState</span> stunState { <span class="c-kw">get</span>; <span class="c-kw">private set</span>; }
    <span class="c-kw">public</span> <span class="c-ty">Ant_DeadState</span> deadState { <span class="c-kw">get</span>; <span class="c-kw">private set</span>; }

    <span class="c-kw">public override void</span> <span class="c-fn">Start</span>()
    {
        <span class="c-kw">base</span>.<span class="c-fn">Start</span>();
        <span class="c-cm">// 각 상태 인스턴스 생성</span>
        idleState = <span class="c-kw">new</span> <span class="c-ty">Ant_IdleState</span>(stateMachine, <span class="c-kw">this</span>, <span class="c-st">"idle"</span>, idleStateData, <span class="c-kw">this</span>);
        moveState = <span class="c-kw">new</span> <span class="c-ty">Ant_MoveState</span>(stateMachine, <span class="c-kw">this</span>, <span class="c-st">"move"</span>, moveStateData, <span class="c-kw">this</span>);
        <span class="c-cm">// ... 다른 상태들 초기화</span>
        
        <span class="c-cm">// 상태머신 초기화 (MoveState부터 시작)</span>
        stateMachine.<span class="c-fn">Init</span>(moveState);
    }

    <span class="c-kw">public override void</span> <span class="c-fn">OnDamaged</span>(<span class="c-ty">AttackDetail</span> attackDetails)
    {
        <span class="c-kw">base</span>.<span class="c-fn">OnDamaged</span>(attackDetails);

        <span class="c-kw">if</span> (isDead) {
            stateMachine.<span class="c-fn">ChangeState</span>(deadState);  <span class="c-cm">// 죽음 상태로 전환</span>
        } <span class="c-kw">else if</span> (isStunned && stateMachine.currentState != stunState) {
            stateMachine.<span class="c-fn">ChangeState</span>(stunState);  <span class="c-cm">// 스턴 상태로 전환</span>
        }
    }
}</code></pre>

                <h3>2.2 상태별 동작 예시</h3>
                <p>IdleState와 MoveState의 동작 방식을 설명합니다.</p>

                <div style="background: rgba(56, 139, 253, 0.1); border-left: 4px solid #388bfd; padding: 20px; margin: 25px 0; border-radius: 6px;">
                    <div style="margin-bottom: 15px;"><strong style="color: var(--accent-color);">IdleState 동작:</strong></div>
                    <ul style="margin-left: 20px; color: var(--text-color); line-height: 1.8;">
                        <li><strong>Enter():</strong> 속도를 0으로 설정, 랜덤 Idle 시간 생성 (minIdleTime ~ maxIdleTime)</li>
                        <li><strong>LogicUpdate():</strong> 경과 시간을 확인하여 isIdleTimeOver 플래그 설정</li>
                        <li><strong>DoChecks():</strong> 플레이어가 최소 감지 범위 내에 있는지 확인 (CheckPlayerInMinAgroRange)</li>
                        <li><strong>전환 조건:</strong> isIdleTimeOver == true 또는 isPlayerInMinAgroRange == true → MoveState 또는 PlayerDetectedState</li>
                    </ul>
                    
                    <div style="margin-top: 20px; margin-bottom: 15px;"><strong style="color: var(--accent-color);">MoveState 동작:</strong></div>
                    <ul style="margin-left: 20px; color: var(--text-color); line-height: 1.8;">
                        <li><strong>Enter():</strong> 이동 속도 설정, 랜덤 Move 시간 생성</li>
                        <li><strong>DoChecks():</strong> 벽 감지(CheckWall), 절벽 감지(CheckLedge), 플레이어 감지, 점프 가능 여부 확인</li>
                        <li><strong>전환 조건:</strong> 벽/절벽 감지 시 방향 전환, 플레이어 감지 시 PlayerDetectedState, Move 시간 종료 시 IdleState</li>
                    </ul>
                </div>

                <h3>2.3 몬스터별 특수 상태</h3>
                <p>각 몬스터 타입은 공통 상태를 상속받아 구현하며, 필요에 따라 특수 상태를 추가합니다.</p>

                <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid var(--border-color); border-radius: 12px; padding: 30px; margin: 30px 0;">
                    <div style="color: var(--accent-color); font-family: 'Fira Code', monospace; font-size: 1.1rem; font-weight: 700; margin-bottom: 20px; text-align: center; border-bottom: 2px solid var(--border-color); padding-bottom: 10px;">몬스터별 특수 상태</div>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
                        <div style="background: rgba(88, 166, 255, 0.1); border: 1px solid var(--accent-color); border-radius: 8px; padding: 15px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px; font-family: 'Fira Code', monospace;">Ant (개미)</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.6;">
                                • 공통 상태 사용<br>
                                • 공격 범위 체크 로직<br>
                                • 공격 쿨타임 관리
                            </div>
                        </div>
                        <div style="background: rgba(88, 166, 255, 0.1); border: 1px solid var(--accent-color); border-radius: 8px; padding: 15px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px; font-family: 'Fira Code', monospace;">Bear (곰)</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.6;">
                                • DashState 추가<br>
                                • 근거리 강력 공격<br>
                                • 벽 타기 능력
                            </div>
                        </div>
                        <div style="background: rgba(88, 166, 255, 0.1); border: 1px solid var(--accent-color); border-radius: 8px; padding: 15px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px; font-family: 'Fira Code', monospace;">Rabbit (토끼)</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.6;">
                                • ChargeState 추가<br>
                                • 돌진 공격 패턴<br>
                                • 빠른 이동 속도
                            </div>
                        </div>
                        <div style="background: rgba(88, 166, 255, 0.1); border: 1px solid var(--accent-color); border-radius: 8px; padding: 15px;">
                            <div style="color: var(--accent-color); font-weight: 700; margin-bottom: 8px; font-family: 'Fira Code', monospace;">Spider (거미)</div>
                            <div style="color: var(--text-color); font-size: 0.85rem; line-height: 1.6;">
                                • JumpState 활용<br>
                                • 벽 타기 능력<br>
                                • 원거리 공격 패턴
                            </div>
                        </div>
                    </div>
                </div>

                <h3>2.4 기술적 특징</h3>
                <ul>
                    <li><span class="highlight">상태머신 기반 AI:</span> 모든 몬스터가 동일한 상태머신 구조를 사용하여 일관된 AI 동작 보장</li>
                    <li><span class="highlight">상속 기반 확장:</span> 공통 상태를 상속받아 몬스터별 특수 상태만 추가하면 새로운 몬스터 구현 가능</li>
                    <li><span class="highlight">조건 기반 전환:</span> DoChecks()를 통해 명확한 상태 전환 조건 관리</li>
                    <li><span class="highlight">애니메이션 연동:</span> 상태 전환 시 자동으로 애니메이션 파라미터 설정</li>
                    <li><span class="highlight">플레이어 감지 시스템:</span> 레이어 마스크를 활용한 효율적인 플레이어 감지</li>
                </ul>
                </div>

                <div style="height: 100px;"></div>
            </div>
        </div>
    </div>

    <script>
        function openMLAgentsModal(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            console.log('openMLAgentsModal called');
            try {
                // 다른 모달이 열려있으면 먼저 닫기
                const fileTowerModal = document.getElementById('modal-overlay');
                if (fileTowerModal && fileTowerModal.style.display === 'flex') {
                    console.log('Closing File Tower Defense modal first');
                    fileTowerModal.style.display = 'none';
                }
                
                // 모달 찾기
                const modal = document.getElementById('modal-overlay-racing');
                
                // 모달 요소 검증
                if (!modal) {
                    console.error('modal-overlay-racing not found!');
                    console.log('All modals:', document.querySelectorAll('.modal-overlay'));
                    alert('모달을 찾을 수 없습니다. 페이지를 새로고침해주세요.');
                    return;
                }
                
                console.log('Modal element found:', modal);
                console.log('Modal ID:', modal.id);
                console.log('Modal classList:', modal.classList.toString());
                console.log('Modal innerHTML preview:', modal.innerHTML.substring(0, 100));
                
                // 모달 위치 및 크기 확인
                const initialRect = modal.getBoundingClientRect();
                console.log('Modal initial bounding rect:', {
                    top: initialRect.top,
                    left: initialRect.left,
                    width: initialRect.width,
                    height: initialRect.height,
                    bottom: initialRect.bottom,
                    right: initialRect.right
                });
                
                // modal-container와 modal-body 확인
                const modalContainer = modal.querySelector('.modal-container');
                const modalBody = modal.querySelector('.modal-body');
                console.log('Modal container:', modalContainer);
                console.log('Modal body:', modalBody);
                
                if (modalContainer) {
                    const containerStyle = window.getComputedStyle(modalContainer);
                    console.log('Container display:', containerStyle.display);
                    console.log('Container visibility:', containerStyle.visibility);
                }
                
                if (modalBody) {
                    const bodyStyle = window.getComputedStyle(modalBody);
                    console.log('Body display:', bodyStyle.display);
                    console.log('Body visibility:', bodyStyle.visibility);
                }
                
                // 모달이 body의 직접 자식인지 확인하고, 아니면 이동
                if (modal.parentElement !== document.body) {
                    console.log('Moving modal to body');
                    document.body.appendChild(modal);
                }
                
                // 모달의 기본 스타일 강제 적용 (인라인 스타일)
                modal.style.setProperty('display', 'flex', 'important');
                modal.style.setProperty('position', 'fixed', 'important');
                modal.style.setProperty('top', '0', 'important');
                modal.style.setProperty('left', '0', 'important');
                modal.style.setProperty('width', '100vw', 'important');
                modal.style.setProperty('height', '100vh', 'important');
                modal.style.setProperty('z-index', '99999', 'important');
                modal.style.setProperty('background', 'rgba(0,0,0,0.92)', 'important');
                modal.style.setProperty('justify-content', 'center', 'important');
                modal.style.setProperty('align-items', 'center', 'important');
                modal.style.setProperty('visibility', 'visible', 'important');
                modal.style.setProperty('opacity', '1', 'important');
                modal.style.setProperty('margin', '0', 'important');
                modal.style.setProperty('padding', '0', 'important');
                
            document.body.style.overflow = 'hidden';
                
                // 자식 요소 강제 표시 및 크기 확인
                if (modalContainer) {
                    modalContainer.style.setProperty('display', 'block', 'important');
                    modalContainer.style.setProperty('visibility', 'visible', 'important');
                    modalContainer.style.setProperty('opacity', '1', 'important');
                    modalContainer.style.setProperty('width', '95%', 'important');
                    modalContainer.style.setProperty('max-width', '1000px', 'important');
                }
                
                if (modalBody) {
                    modalBody.style.setProperty('display', 'block', 'important');
                    modalBody.style.setProperty('visibility', 'visible', 'important');
                    modalBody.style.setProperty('opacity', '1', 'important');
                }
                
                // 강제 리플로우 트리거
                void modal.offsetHeight;
                
                // 리플로우 후 크기 확인
                requestAnimationFrame(function() {
                    const checkRect = modal.getBoundingClientRect();
                    const checkComputed = window.getComputedStyle(modal);
                    console.log('After reflow - Modal state:', {
                        computedDisplay: checkComputed.display,
                        computedWidth: checkComputed.width,
                        computedHeight: checkComputed.height,
                        rectWidth: checkRect.width,
                        rectHeight: checkRect.height,
                        offsetWidth: modal.offsetWidth,
                        offsetHeight: modal.offsetHeight,
                        parentElement: modal.parentElement.tagName
                    });
                    
                    if (checkRect.width === 0 || checkRect.height === 0) {
                        console.error('Modal still zero size! Trying alternative approach...');
                        // 최후의 수단: 모달을 완전히 재생성
                        modal.style.cssText = 'display: flex !important; position: fixed !important; top: 0 !important; left: 0 !important; width: 100vw !important; height: 100vh !important; z-index: 99999 !important; background: rgba(0,0,0,0.92) !important; justify-content: center !important; align-items: center !important; visibility: visible !important; opacity: 1 !important; margin: 0 !important; padding: 0 !important;';
                    }
                    
                    // 기본 탭 설정 (navigation 탭 활성화)
                    switchTabML('navigation');
                });
                
            } catch (error) {
                console.error('Error in openMLAgentsModal:', error);
                alert('모달을 열 수 없습니다: ' + error.message);
            }
        }
        
        function openWFKModal(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            console.log('openWFKModal called');
            try {
                // 다른 모달이 열려있으면 먼저 닫기
                const fileTowerModal = document.getElementById('modal-overlay');
                if (fileTowerModal && fileTowerModal.style.display === 'flex') {
                    fileTowerModal.style.display = 'none';
                }
                const mlAgentsModal = document.getElementById('modal-overlay-racing');
                if (mlAgentsModal && mlAgentsModal.style.display === 'flex') {
                    mlAgentsModal.style.display = 'none';
                }
                
                const modal = document.getElementById('modal-overlay-wfk');
                if (!modal) {
                    console.error('modal-overlay-wfk not found!');
                    console.log('All modals:', document.querySelectorAll('.modal-overlay'));
                    alert('모달을 찾을 수 없습니다. 페이지를 새로고침해주세요.');
                    return;
                }
                
                console.log('WFK Modal element found:', modal);
                
                // 모달이 body의 직접 자식이 아니면 body에 추가
                if (modal.parentElement !== document.body) {
                    document.body.appendChild(modal);
                    console.log('Modal moved to body');
                }
                
                const modalContainer = modal.querySelector('.modal-container');
                const modalBody = modal.querySelector('.modal-body');
                
                // 강제 스타일 적용
                modal.style.setProperty('display', 'flex', 'important');
                modal.style.setProperty('position', 'fixed', 'important');
                modal.style.setProperty('top', '0', 'important');
                modal.style.setProperty('left', '0', 'important');
                modal.style.setProperty('width', '100vw', 'important');
                modal.style.setProperty('height', '100vh', 'important');
                modal.style.setProperty('z-index', '99999', 'important');
                modal.style.setProperty('background', 'rgba(0,0,0,0.92)', 'important');
                modal.style.setProperty('justify-content', 'center', 'important');
                modal.style.setProperty('align-items', 'center', 'important');
                modal.style.setProperty('visibility', 'visible', 'important');
                modal.style.setProperty('opacity', '1', 'important');
                modal.style.setProperty('margin', '0', 'important');
                modal.style.setProperty('padding', '0', 'important');
                
                document.body.style.overflow = 'hidden';
                
                // 첫 번째 탭(csv) 활성화
                switchTabWFK('csv');
                
                // 자식 요소 강제 표시
                if (modalContainer) {
                    modalContainer.style.setProperty('display', 'block', 'important');
                    modalContainer.style.setProperty('visibility', 'visible', 'important');
                    modalContainer.style.setProperty('opacity', '1', 'important');
                    modalContainer.style.setProperty('width', '95%', 'important');
                    modalContainer.style.setProperty('max-width', '1000px', 'important');
                }
                
                if (modalBody) {
                    modalBody.style.setProperty('display', 'block', 'important');
                    modalBody.style.setProperty('visibility', 'visible', 'important');
                    modalBody.style.setProperty('opacity', '1', 'important');
                }
                
                // 강제 리플로우 트리거
                void modal.offsetHeight;
                
                // 리플로우 후 크기 확인
                requestAnimationFrame(function() {
                    const checkRect = modal.getBoundingClientRect();
                    const checkComputed = window.getComputedStyle(modal);
                    console.log('WFK Modal after reflow:', {
                        computedDisplay: checkComputed.display,
                        computedWidth: checkComputed.width,
                        computedHeight: checkComputed.height,
                        rectWidth: checkRect.width,
                        rectHeight: checkRect.height,
                        offsetWidth: modal.offsetWidth,
                        offsetHeight: modal.offsetHeight
                    });
                    
                    if (checkRect.width === 0 || checkRect.height === 0) {
                        console.warn('WFK Modal has zero size, forcing dimensions');
                        modal.style.setProperty('width', '100vw', 'important');
                        modal.style.setProperty('height', '100vh', 'important');
                    }
                });
            } catch (error) {
                console.error('Error in openWFKModal:', error);
                alert('모달을 열 수 없습니다: ' + error.message);
            }
        }
        
        function closeWFKModal() {
            const modal = document.getElementById('modal-overlay-wfk');
            if (modal) {
                modal.style.display = 'none';
                modal.style.visibility = 'hidden';
                modal.style.opacity = '0';
                document.body.style.overflow = '';
            }
        }
        
        function openModal(projectType) {
            console.log('openModal called with:', projectType);
            try {
                if (projectType === 'mlAgentsRacing') {
                    openMLAgentsModal(null);
                } else if (projectType === 'wfk') {
                    const modal = document.getElementById('modal-overlay-wfk');
                    if (modal) {
                        const fileTowerModal = document.getElementById('modal-overlay');
                        if (fileTowerModal) fileTowerModal.style.display = 'none';
                        const mlAgentsModal = document.getElementById('modal-overlay-racing');
                        if (mlAgentsModal) mlAgentsModal.style.display = 'none';
                        modal.style.display = 'flex';
                        document.body.style.overflow = 'hidden';
                    }
                } else {
                    const modal = document.getElementById('modal-overlay');
                    if (modal) {
                        modal.style.display = 'flex';
                        // 기본적으로 리팩토링 탭 활성화
                        if (typeof switchTab === 'function') {
                            switchTab('refactoring');
                        }
                        document.body.style.overflow = 'hidden';
                    } else {
                        console.error('modal-overlay element not found');
                        return;
                    }
                }
            } catch (error) {
                console.error('Error opening modal:', error);
                alert('모달을 열 수 없습니다: ' + error.message);
            }
        }
        function closeModal(projectType) {
            if (projectType === 'racing' || projectType === 'mlAgentsRacing') {
                document.getElementById('modal-overlay-racing').style.display = 'none';
            } else if (projectType === 'wfk') {
                document.getElementById('modal-overlay-wfk').style.display = 'none';
            } else if (projectType === 'slime') {
                document.getElementById('modal-overlay-slime').style.display = 'none';
            } else {
            document.getElementById('modal-overlay').style.display = 'none';
            }
            document.body.style.overflow = 'auto';
        }
        function switchTab(tabName) {
            // 모든 탭 버튼 비활성화
            const buttons = document.querySelectorAll('.tab-button');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            // 모든 탭 콘텐츠 숨기기
            const contents = document.querySelectorAll('.tab-content');
            contents.forEach(content => content.classList.remove('active'));
            
            // 선택된 탭 활성화
            if (tabName === 'refactoring') {
                document.querySelector('.tab-button:first-child').classList.add('active');
                document.getElementById('refactoring-tab').classList.add('active');
            } else if (tabName === 'existing') {
                document.querySelector('.tab-button:last-child').classList.add('active');
                document.getElementById('existing-tab').classList.add('active');
            }
        }

        function switchTabML(tabName) {
            // ML-Agents 모달 내의 탭 버튼만 선택
            const mlModal = document.getElementById('modal-overlay-racing');
            if (!mlModal) return;
            
            const buttons = mlModal.querySelectorAll('.tab-button');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            const contents = mlModal.querySelectorAll('.tab-content');
            contents.forEach(content => content.classList.remove('active'));
            
            // 선택된 탭 활성화
            if (tabName === 'navigation') {
                const btn = mlModal.querySelector('.tab-button:first-child');
                if (btn) btn.classList.add('active');
                const content = document.getElementById('ml-navigation-tab');
                if (content) content.classList.add('active');
            } else if (tabName === 'sensing') {
                const btn = mlModal.querySelector('.tab-button:nth-child(2)');
                if (btn) btn.classList.add('active');
                const content = document.getElementById('ml-sensing-tab');
                if (content) content.classList.add('active');
            } else if (tabName === 'training') {
                const btn = mlModal.querySelector('.tab-button:last-child');
                if (btn) btn.classList.add('active');
                const content = document.getElementById('ml-training-tab');
                if (content) content.classList.add('active');
            }
        }

        function switchTabWFK(tabName) {
            // WFK 모달 내의 탭 버튼만 선택
            const wfkModal = document.getElementById('modal-overlay-wfk');
            if (!wfkModal) return;
            
            const buttons = wfkModal.querySelectorAll('.tab-button');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            const contents = wfkModal.querySelectorAll('.tab-content');
            contents.forEach(content => content.classList.remove('active'));
            
            // 선택된 탭 활성화
            if (tabName === 'csv') {
                buttons[0].classList.add('active');
                document.getElementById('wfk-csv-tab').classList.add('active');
            } else if (tabName === 'save') {
                buttons[1].classList.add('active');
                document.getElementById('wfk-save-tab').classList.add('active');
            } else if (tabName === 'loading') {
                buttons[2].classList.add('active');
                document.getElementById('wfk-loading-tab').classList.add('active');
            }
        }

        function openSlimeModal(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            try {
                // 다른 모달이 열려있으면 먼저 닫기
                const fileTowerModal = document.getElementById('modal-overlay');
                if (fileTowerModal && fileTowerModal.style.display === 'flex') {
                    fileTowerModal.style.display = 'none';
                }
                const mlAgentsModal = document.getElementById('modal-overlay-racing');
                if (mlAgentsModal && mlAgentsModal.style.display === 'flex') {
                    mlAgentsModal.style.display = 'none';
                }
                const wfkModal = document.getElementById('modal-overlay-wfk');
                if (wfkModal && wfkModal.style.display === 'flex') {
                    wfkModal.style.display = 'none';
                }
                
                const modal = document.getElementById('modal-overlay-slime');
                if (!modal) {
                    alert('모달을 찾을 수 없습니다. 페이지를 새로고침해주세요.');
                    return;
                }
                
                // modal-container와 modal-body 확인
                const modalContainer = modal.querySelector('.modal-container');
                const modalBody = modal.querySelector('.modal-body');
                
                // 모달이 body의 직접 자식인지 확인하고, 아니면 이동
                if (modal.parentElement !== document.body) {
                    document.body.appendChild(modal);
                }
                
                // 모달의 기본 스타일 강제 적용 (인라인 스타일)
                modal.style.setProperty('display', 'flex', 'important');
                modal.style.setProperty('position', 'fixed', 'important');
                modal.style.setProperty('top', '0', 'important');
                modal.style.setProperty('left', '0', 'important');
                modal.style.setProperty('width', '100vw', 'important');
                modal.style.setProperty('height', '100vh', 'important');
                modal.style.setProperty('z-index', '99999', 'important');
                modal.style.setProperty('background', 'rgba(0,0,0,0.92)', 'important');
                modal.style.setProperty('justify-content', 'center', 'important');
                modal.style.setProperty('align-items', 'center', 'important');
                modal.style.setProperty('visibility', 'visible', 'important');
                modal.style.setProperty('opacity', '1', 'important');
                modal.style.setProperty('margin', '0', 'important');
                modal.style.setProperty('padding', '0', 'important');
                
                document.body.style.overflow = 'hidden';
                
                // 첫 번째 탭(state-machine) 활성화
                switchTabSlime('state-machine');
                
                // 자식 요소 강제 표시
                if (modalContainer) {
                    modalContainer.style.setProperty('display', 'block', 'important');
                    modalContainer.style.setProperty('visibility', 'visible', 'important');
                    modalContainer.style.setProperty('opacity', '1', 'important');
                }
                
                if (modalBody) {
                    modalBody.style.setProperty('display', 'block', 'important');
                    modalBody.style.setProperty('visibility', 'visible', 'important');
                    modalBody.style.setProperty('opacity', '1', 'important');
                }
            } catch (error) {
                alert('모달을 열 수 없습니다: ' + error.message);
            }
        }

        function switchTabSlime(tabName) {
            // Slime 모달 내의 탭 버튼만 선택
            const slimeModal = document.getElementById('modal-overlay-slime');
            if (!slimeModal) return;
            
            const buttons = slimeModal.querySelectorAll('.tab-button');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            const contents = slimeModal.querySelectorAll('.tab-content');
            contents.forEach(content => content.classList.remove('active'));
            
            // 선택된 탭 활성화
            if (tabName === 'state-machine') {
                buttons[0].classList.add('active');
                document.getElementById('slime-state-machine-tab').classList.add('active');
            } else if (tabName === 'player') {
                buttons[1].classList.add('active');
                document.getElementById('slime-player-tab').classList.add('active');
            } else if (tabName === 'enemy') {
                buttons[2].classList.add('active');
                document.getElementById('slime-enemy-tab').classList.add('active');
            }
        }
        
        // 페이지 로드 시 이벤트 리스너 추가 (백업용)
        document.addEventListener('DOMContentLoaded', function() {
            // ML-Agents 카드 클릭 이벤트 (백업)
            const mlAgentsCard = document.getElementById('ml-agents-card');
            if (mlAgentsCard) {
                mlAgentsCard.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    openMLAgentsModal(e);
                }, true);
            }
            
            // File Tower Defense 카드 클릭 이벤트
            const fileTowerDefenseCard = document.getElementById('file-tower-defense-card');
            if (fileTowerDefenseCard) {
                fileTowerDefenseCard.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    openModal('fileTowerDefense');
                });
            }
            
            // WFK 카드 이벤트 리스너
            const wfkCard = document.getElementById('wfk-card');
            if (wfkCard) {
                wfkCard.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    openWFKModal(e);
                }, true);
            }
            
            // Slime 카드 이벤트 리스너
            const slimeCard = document.getElementById('slime-card');
            if (slimeCard) {
                slimeCard.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    openSlimeModal(e);
                }, true);
            }
        });
    </script>
</body>
</html>
